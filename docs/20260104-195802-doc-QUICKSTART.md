# UMA Quick Start Guide

This guide will help you get started with UMA (Unified Model Access) in just a few minutes.

## Installation

### Using uv (recommended)

```bash
# Clone the repository
git clone <repository-url>
cd uma2

# Install dependencies
uv sync

# Install with dev dependencies
uv sync --dev
```

### Using pip

```bash
pip install -e .

# With dev dependencies
pip install -e ".[dev]"
```

## Basic Usage

UMA provides a high-level API through the `UMA` class for working with database entities.

### 1. Setup Database and Schema

```python
from sqlalchemy import Column, Integer, String, MetaData, Table
from sqlalchemy.ext.asyncio import create_async_engine

# Define schema
metadata = MetaData()

users = Table(
    'users',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(100)),
    Column('email', String(100)),
)

# Create async engine
engine = create_async_engine('sqlite+aiosqlite:///test.db')

# Create tables
async with engine.begin() as conn:
    await conn.run_sync(metadata.create_all)
```

### 2. Initialize UMA

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

# Create metadata provider
metadata_provider = DefaultMetadataProvider()

# Initialize UMA (call once at application startup)
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})
```

### 3. Work with Entities

```python
# List all entities
entities = await uma.entity_list()
print(f"Available: {entities}")

# Get metadata
user_meta = await uma.entity_details('users')
print(f"Columns: {[col['name'] for col in user_meta['columns']]}")

# Create record
user_id = await uma.save(
    'users',
    {'name': 'John Doe', 'email': 'john@example.com'}
)

# Read record
user = await uma.read('users', user_id)
print(f"User: {user}")

# Update record
await uma.save(
    'users',
    {'id': user_id, 'name': 'John Smith', 'email': 'john.smith@example.com'}
)

# Delete record
await uma.delete('users', user_id)
```

### 4. Add Access Control

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    """Custom provider with access control."""
    
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        user_context: Any,
    ) -> bool:
        """Check access based on user role."""
        if not user_context:
            return False
        
        # Admin can do everything
        if user_context.role == 'admin':
            return True
        
        # Regular user: read only
        if user_context.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False

# Initialize with custom provider
metadata_provider = MyMetadataProvider()
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})

# Use with user context
class User:
    def __init__(self, role):
        self.role = role

admin = User(role='admin')
regular_user = User(role='user')

# Admin can write
await uma.save(
    'users',
    {'name': 'Admin User'},
    user_context=admin,
)

# Regular user can only read
user = await uma.read('users', 1, user_context=regular_user)

# Regular user cannot write (raises UMAAccessDeniedError)
try:
    await uma.save('users', {'name': 'Hacker'}, user_context=regular_user)
except UMAAccessDeniedError:
    print("Access denied!")
```

### 5. Create Virtual View

```python
from namerec.uma import VirtualViewHandler, copy_field_meta
from sqlalchemy import select, func

class UserStatsView(VirtualViewHandler):
    """Virtual view with user statistics."""
    
    description = "User statistics"
    
    @classmethod
    async def select(cls, entity_name, params, context):
        users = context.metadata.tables['users']
        
        query = select(
            users.c.id,
            users.c.name,
            func.length(users.c.email).label('email_length')
        )
        
        return query
    
    @classmethod
    async def meta(cls, entity_name, context, registry):
        columns_metadata = [
            await copy_field_meta('users', 'id', context, registry),
            await copy_field_meta('users', 'name', context, registry),
            {
                'name': 'email_length',
                'type': 'integer',
                'description': 'Length of email'
            }
        ]
        
        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': columns_metadata
        }

# Register virtual view
uma.registry.register('user_stats', UserStatsView)

# Use virtual view
view_meta = await uma.entity_details('user_stats')
```

### 6. Using JSQL Queries

UMA supports complex queries using JSQL (JSON-SQL) format:

```python
# Simple query with WHERE
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name', 'email'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        },
        'order_by': [{'field': 'name', 'direction': 'asc'}],
        'limit': 10
    },
    user_context=current_user
)

# Result format
# {
#     'meta': [
#         {'name': 'id', 'type': 'INTEGER', 'nullable': False, ...},
#         {'name': 'name', 'type': 'VARCHAR(255)', 'nullable': False, ...},
#         ...
#     ],
#     'data': [
#         [1, 'Alice', 'alice@example.com'],
#         [2, 'Bob', 'bob@example.com'],
#         ...
#     ]
# }
```

JSQL supports:
- Complex WHERE conditions with AND/OR/NOT
- JOINs (INNER, LEFT, RIGHT, FULL)
- Aggregations (COUNT, SUM, AVG, MIN, MAX)
- GROUP BY and HAVING
- ORDER BY (including by column aliases)
- Window functions
- CTEs (Common Table Expressions)
- Subqueries and parameterized queries

For complete JSQL syntax and examples, see [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md).

## Running Examples

```bash
# Run API usage example (recommended)
uv run python examples/api_usage.py

# Run basic usage example
uv run python examples/basic_usage.py

# Run JSQL usage example
uv run python examples/jsql_usage.py
```

## Running Tests

```bash
# Run all tests
uv run pytest

# Run with coverage
uv run pytest --cov=namerec.uma

# Run specific test
uv run pytest tests/test_basic.py::test_parse_entity_name
```

## Code Quality

```bash
# Run Ruff linter
ruff check src/

# Run Ruff formatter
ruff format src/

# Run MyPy type checker
mypy src/
```

## Common Patterns

### Pattern 1: Entity with Access Control

```python
class SecureEntityHandler(DefaultEntityHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        query = await super().select(entity_name, params, context)
        
        # Apply row-level security
        user_role = context.user_context.get('role')
        if user_role != 'admin':
            table = context.metadata.tables[entity_name.entity]
            query = query.where(table.c.is_public == True)
        
        return query
```

### Pattern 2: Computed Fields in Virtual View

```python
class ComputedView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        table = context.metadata.tables['products']
        
        return select(
            table.c.id,
            table.c.price,
            (table.c.price * 1.2).label('price_with_tax')
        )
```

### Pattern 3: Custom Metadata Provider

```python
class RedisMetadataProvider:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def get_metadata(self, entity_name, context):
        key = f"uma:meta:{entity_name}"
        data = await self.redis.get(key)
        return json.loads(data) if data else {}

# Use in UMA initialization
metadata_provider = RedisMetadataProvider(redis_client)
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})
```

## Next Steps

- Read the [README.md](../README.md) for project overview
- Check [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md) for query syntax
- Review [API Summary](20260104-195632-doc-API_SUMMARY.md) for complete API reference
- Explore [examples/jsql_usage.py](../examples/jsql_usage.py) for JSQL examples
- Check [PROJECT_STRUCTURE.md](20260104-195714-doc-PROJECT_STRUCTURE.md) for architecture details

## Troubleshooting

### Import Error

If you get import errors, make sure you're using the correct import path:

```python
# Correct
from namerec.uma import UMA, NamespaceConfig

# Wrong
from uma import UMA
```

### Async Engine Required

UMA uses async operations. Make sure to use async engine:

```python
# Correct
from sqlalchemy.ext.asyncio import create_async_engine
engine = create_async_engine('sqlite+aiosqlite:///test.db')

# Wrong
from sqlalchemy import create_engine
engine = create_engine('sqlite:///test.db')
```

### UMA Not Initialized

If you get errors about UMA, make sure to initialize it:

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

## Support

For questions and issues, please refer to the project documentation or create an issue in the repository.
