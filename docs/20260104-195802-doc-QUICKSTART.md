# UMA Quick Start Guide

This guide will help you get started with UMA (Unified Model Access) in just a few minutes.

## Installation

### Using uv (recommended)

```bash
# Clone the repository
git clone <repository-url>
cd uma2

# Install dependencies
uv sync

# Install with dev dependencies
uv sync --dev
```

### Using pip

```bash
pip install -e .

# With dev dependencies
pip install -e ".[dev]"
```

## Basic Usage

There are two ways to use UMA:
1. **High-level API** - Simple functions like `uma_read()`, `uma_save()` (recommended for most cases)
2. **Low-level API** - Direct handler usage for advanced scenarios

### High-Level API (Recommended)

#### 1. Setup Database and Schema

```python
from sqlalchemy import Column, Integer, String, MetaData, Table, create_engine
from sqlalchemy.ext.asyncio import create_async_engine

# Define schema
metadata = MetaData()

users = Table(
    'users',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(100)),
    Column('email', String(100)),
)

# Create async engine
engine = create_async_engine('sqlite+aiosqlite:///test.db')

# Create tables
async with engine.begin() as conn:
    await conn.run_sync(metadata.create_all)
```

#### 2. Initialize UMA

```python
from namerec.uma import initialize_uma

# Initialize UMA (call once at application startup)
registry = initialize_uma(
    engine=engine,
    metadata=metadata,
)
```

#### 3. Work with Entities

```python
from namerec.uma import uma_read, uma_save, uma_delete, uma_meta, uma_list_entities

# List all entities
entities = await uma_list_entities()
print(f"Available: {entities}")

# Get metadata
user_meta = await uma_meta('users')
print(f"Columns: {[col['name'] for col in user_meta['columns']]}")

# Create record
user_id = await uma_save('users', {
    'name': 'John Doe',
    'email': 'john@example.com'
})

# Read record
user = await uma_read('users', user_id)
print(f"User: {user}")

# Update record
await uma_save('users', {
    'id': user_id,
    'name': 'John Smith',
    'email': 'john.smith@example.com'
})

# Delete record
await uma_delete('users', user_id)
```

#### 4. Add Access Control

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext, initialize_uma

class MyMetadataProvider(DefaultMetadataProvider):
    """Custom provider with access control."""
    
    def can(self, entity_name: str, operation: Operation, context: UMAContext) -> bool:
        """Check access based on user role."""
        user = context.user_context
        if not user:
            return False
        
        # Admin can do everything
        if user.role == 'admin':
            return True
        
        # Regular user: read only
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False

# Initialize with custom provider
registry = initialize_uma(
    engine=engine,
    metadata=metadata,
    metadata_provider=MyMetadataProvider(),
)

# Use with user context
class User:
    def __init__(self, role):
        self.role = role

admin = User(role='admin')
regular_user = User(role='user')

# Admin can write
await uma_save('users', {'name': 'Admin User'}, user_context=admin)

# Regular user can only read
user = await uma_read('users', 1, user_context=regular_user)

# Regular user cannot write (raises UMAAccessDeniedError)
try:
    await uma_save('users', {'name': 'Hacker'}, user_context=regular_user)
except UMAAccessDeniedError:
    print("Access denied!")
```

#### 5. Create Virtual View

```python
from namerec.uma import VirtualViewHandler, copy_field_meta, get_registry

class UserStatsView(VirtualViewHandler):
    """Virtual view with user statistics."""
    
    description = "User statistics"
    
    @classmethod
    async def select(cls, entity_name, params, context):
        users = context.metadata.tables['users']
        
        query = select(
            users.c.id,
            users.c.name,
            func.length(users.c.email).label('email_length')
        )
        
        return query
    
    @classmethod
    async def meta(cls, entity_name, context):
        columns_metadata = [
            await copy_field_meta('users', 'id', context),
            await copy_field_meta('users', 'name', context),
            {
                'name': 'email_length',
                'type': 'integer',
                'description': 'Length of email'
            }
        ]
        
        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': columns_metadata
        }

# Register virtual view
registry = get_registry()
registry.register('user_stats', UserStatsView)

# Use virtual view
view_meta = await uma_meta('user_stats')
```

### Low-Level API (Advanced)

For advanced scenarios, you can work directly with handlers:

#### 1. Initialize

```python
from namerec.uma import (
    UMAContext,
    DefaultMetadataProvider,
    get_global_registry,
    init_global_registry,
    parse_entity_name,
)

# Initialize global registry (alternative to initialize_uma)
init_global_registry()
registry = get_global_registry()

# Create context
metadata_provider = DefaultMetadataProvider()
context = UMAContext(
    engine=engine,
    metadata=metadata,
    metadata_provider=metadata_provider,
)
```

#### 2. Work with Handlers Directly

```python
# Get handler for entity
entity_name = parse_entity_name('users')
handler = registry.get_handler(entity_name, context)

# Use handler methods
metadata = await handler.meta(entity_name, context)
user_id = await handler.save(entity_name, {'name': 'John'}, context)
user = await handler.read(entity_name, user_id, context)
```

#### 3. Custom Default Handler

```python
from namerec.uma import DefaultEntityHandler

class MyDefaultHandler(DefaultEntityHandler):
    """Custom default handler with access control."""
    
    @classmethod
    async def select(cls, entity_name, params, context):
        # Get base query
        query = await super().select(entity_name, params, context)
        
        # Add access control
        if context.user_context:
            user_id = context.user_context.get('user_id')
            table = context.metadata.tables[entity_name.entity]
            if 'user_id' in table.columns:
                query = query.where(table.c.user_id == user_id)
        
        return query

# Set as default
registry.set_default_handler(MyDefaultHandler)
```

## Running Examples

```bash
# Run API usage example (recommended)
uv run python examples/api_usage.py

# Run basic usage example (low-level API)
uv run python examples/basic_usage.py
```

## Running Tests

```bash
# Run all tests
uv run pytest

# Run with coverage
uv run pytest --cov=namerec.uma

# Run specific test
uv run pytest tests/test_basic.py::test_parse_entity_name
```

## Code Quality

```bash
# Run Ruff linter
ruff check src/

# Run Ruff formatter
ruff format src/

# Run MyPy type checker
mypy src/
```

## Common Patterns

### Pattern 1: Entity with Access Control

```python
class SecureEntityHandler(DefaultEntityHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        query = await super().select(entity_name, params, context)
        
        # Apply row-level security
        user_role = context.user_context.get('role')
        if user_role != 'admin':
            table = context.metadata.tables[entity_name.entity]
            query = query.where(table.c.is_public == True)
        
        return query
```

### Pattern 2: Computed Fields in Virtual View

```python
class ComputedView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        table = context.metadata.tables['products']
        
        return select(
            table.c.id,
            table.c.price,
            (table.c.price * 1.2).label('price_with_tax')
        )
```

### Pattern 3: Custom Metadata Provider

```python
class RedisMetadataProvider:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def get_metadata(self, entity_name, context):
        key = f"uma:meta:{entity_name}"
        data = await self.redis.get(key)
        return json.loads(data) if data else {}

# Use in context
context = UMAContext(
    engine=engine,
    metadata=metadata,
    metadata_provider=RedisMetadataProvider(redis_client)
)
```

## Next Steps

- Read the [README.md](README.md) for project overview
- Check [PROJECT_STRUCTURE.md](PROJECT_STRUCTURE.md) for architecture details
- Review [examples/basic_usage.py](examples/basic_usage.py) for complete example
- Explore the design documents in [docs/](docs/)

## Troubleshooting

### Import Error

If you get import errors, make sure you're using the correct import path:

```python
# Correct
from namerec.uma import UMAContext

# Wrong
from uma import UMAContext
```

### Async Engine Required

UMA uses async operations. Make sure to use async engine:

```python
# Correct
from sqlalchemy.ext.asyncio import create_async_engine
engine = create_async_engine('sqlite+aiosqlite:///test.db')

# Wrong
from sqlalchemy import create_engine
engine = create_engine('sqlite:///test.db')
```

### Registry Not Initialized

If you get errors about registry, make sure to initialize it:

```python
from namerec.uma import init_global_registry

init_global_registry()
```

## Support

For questions and issues, please refer to the project documentation or create an issue in the repository.
