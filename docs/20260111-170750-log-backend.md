# План FastAPI-приложения UMA
_Exported on 11.01.2026 at 17:07:38 GMT+3 from Cursor (2.3.29)_

---

**User**

(20260107-203334)
(20260107-204435) Пожалуйста, загрузи данные о проекте из ConPort.

(20260107-204440) Сейчас предлагается создать FastAPI-приложение, которое будет демонстрировать возможности UMA по обработке JSQL-запросов с frontend.
Позже мы займёмся созданием frontend-приложения.

(20260107-204451) Сейчас я вижу решение так: в каталоге examples создаём подкаталог backend_demo, в котором создаём инфраструктуру FastAPI-backend в src-дизайне. Т.е. все исходные тексты располагаем в каталоге src.

(20260107-204459) Для приложения создаём отдельное виртуальное окружение, соответственно, там должен быть свой `pyproject/toml`, в котором должна быть зависимость от git-репозитория UMA на GitHub.

(20260107-204509) Приложение должно содержать endpoint-ы функций UMA, доступные по основному пути `/api/uma`:
`/api/uma/select` – запрос на выборку по JSQL
`/api/uma/read` – `uma_read`
`/api/uma/save` – `uma_save`
`/api/uma/delete` – `uma_delete`
`/api/uma/meta/list` – перечисление доступных сущностей
`/api/uma/meta/detail` – детали (структура) сущности по её имени из `/api/uma/meta/list`

(20260107-204752) В `.env` (нужен `.env.example`) должен настраиваться путь соединения с БД.

(20260107-204930) Нужно обеспечить подробное логгирование с выводом на консоль. Используй `logging`, учитывай требования 12-факторного приложения. Формат логгирования текстовый (JSON пока ненужно), формат сообщения `ts log_level: log_message`.
Здесь `ts` текущие локальные дата/время в формате ISO, `log_level` – уровень логгирования (например, `INFO`), `log_message` – текст сообщения.
Колоризации ненужно, но подробности проблем в логе (значения локальных переменных, хорошо оформленный контекст) пригодятся – посмотри, какие библиотеки уместны для этого в 2026.
В целом, я ожидаю предложения по ведению логов, уровня "production ready".

(20260107-204517) На всякий случай, но это важно: приложение должно быть асинхронным.

(20260107-205637) Ожидаю от тебя предложений по реализации обозначенного выше.
На данном этапе интересует только план, никаких изменений в проект не вноси до моего одобрения плана.


---

**Cursor**

Изучаю проект и загружаю данные ConPort. Затем предложу план реализации.


Изучаю примеры использования и структуру проекта:


Изучаю правила проекта и готовлю план:


План реализации FastAPI-приложения для демонстрации UMA:

## План реализации FastAPI-приложения для демонстрации UMA

### 1. Структура проекта

```
examples/backend_demo/
├── src/
│   ├── __init__.py
│   ├── main.py                 # Точка входа FastAPI приложения
│   ├── config.py               # Конфигурация (загрузка из .env)
│   ├── logging_config.py        # Настройка логирования
│   ├── dependencies.py         # FastAPI dependencies (инициализация UMA, user_context)
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # Роутер для всех UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic модели для запросов
│       └── responses.py         # Pydantic модели для ответов
├── .env                        # Локальные настройки (не в git)
├── .env.example                # Пример настроек
├── pyproject.toml              # Зависимости и конфигурация проекта
├── README.md                   # Документация по запуску
└── .gitignore                  # Игнорируемые файлы
```

### 2. Зависимости и виртуальное окружение

**pyproject.toml:**
- Использовать `uv` как менеджер пакетов (как в основном проекте)
- Зависимость от UMA через git: `git+https://github.com/aka-NameRec/uma2.git`
- Основные зависимости:
  - `fastapi>=0.104.0` — веб-фреймворк
  - `uvicorn[standard]>=0.24.0` — ASGI сервер
  - `pydantic-settings>=2.0.0` — загрузка настроек из .env
  - `python-dotenv>=1.0.0` — для .env (опционально, если pydantic-settings недостаточно)
  - `structlog>=23.2.0` — структурированное логирование (production-ready)
  - Соответствующий async драйвер БД (например, `asyncpg` для PostgreSQL, `aiosqlite` для SQLite)

### 3. Конфигурация (.env)

**.env.example:**
```env
# Database connection string
# Examples:
# PostgreSQL: postgresql+asyncpg://user:password@localhost/dbname
# SQLite: sqlite+aiosqlite:///./database.db
DATABASE_URL=sqlite+aiosqlite:///./database.db

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO
```

**config.py:**
- Использовать `pydantic-settings.BaseSettings` для загрузки из .env
- Валидация обязательных полей
- Значения по умолчанию где уместно

### 4. Логирование (production-ready)

**logging_config.py:**
- Использовать `structlog` для структурированного логирования
- Текстовый рендеринг (не JSON) с форматом: `ts log_level: log_message`
- ISO формат даты/времени (локальное время)
- Уровни: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Контекст: включать значения переменных, traceback для ошибок
- Настройка через переменную окружения `LOG_LEVEL`

**Предлагаемая библиотека:** `structlog` с `structlog.dev.ConsoleRenderer` для текстового вывода. Преимущества:
- Структурированное логирование с контекстом
- Производительность
- Легко переключиться на JSON для production
- Поддержка цепочек вызовов и контекста

**Пример формата:**
```
2026-01-07T20:45:12.123456 INFO: UMA initialized successfully engine=<Engine> metadata=<MetaData>
2026-01-07T20:45:13.234567 ERROR: Failed to execute query entity=users error=AccessDenied user_id=123
```

### 5. Инициализация UMA

**dependencies.py:**
- Функция для инициализации UMA при старте приложения (lifespan event)
- Создание async engine из `DATABASE_URL`
- Рефлексия метаданных через `metadata.reflect()`
- Вызов `initialize_uma()` с engine и metadata
- Закрытие соединений при завершении
- Dependency для получения `user_context` (пока заглушка, позже — аутентификация)

### 6. API Endpoints

**routers/uma.py:**

Все endpoints под префиксом `/api/uma`:

1. **POST `/api/uma/select`**
   - Тело: JSQL query (dict)
   - Вызов: `uma_select(jsql, params, user_context)`
   - Ответ: `{"meta": [...], "data": [...]}`

2. **GET `/api/uma/read`**
   - Query params: `entity_name`, `id`
   - Вызов: `uma_read(entity_name, id_value, user_context)`
   - Ответ: `{...}` (данные записи)

3. **POST `/api/uma/save`**
   - Тело: `{"entity_name": "...", "data": {...}}`
   - Вызов: `uma_save(entity_name, data, user_context)`
   - Ответ: `{"id": ...}` (ID сохранённой записи)

4. **DELETE `/api/uma/delete`**
   - Query params: `entity_name`, `id`
   - Вызов: `uma_delete(entity_name, id_value, user_context)`
   - Ответ: `{"deleted": true}`

5. **GET `/api/uma/meta/list`**
   - Вызов: `uma_list_entities(user_context)`
   - Ответ: `{"entities": ["entity1", "entity2", ...]}`

6. **GET `/api/uma/meta/detail`**
   - Query params: `entity_name`
   - Вызов: `uma_meta(entity_name, user_context)`
   - Ответ: метаданные сущности (структура колонок и т.д.)

**Особенности:**
- Все endpoints асинхронные
- Использование Pydantic моделей для валидации запросов/ответов
- Обработка исключений UMA с корректными HTTP статусами:
  - `UMAAccessDeniedError` → 403 Forbidden
  - `UMANotFoundError` → 404 Not Found
  - `JSQLSyntaxError` → 400 Bad Request
  - `JSQLExecutionError` → 500 Internal Server Error
  - `RuntimeError` (UMA not initialized) → 500 Internal Server Error
- Подробное логирование всех операций с контекстом

### 7. Модели запросов/ответов

**models/requests.py:**
- `JSQLSelectRequest` — для `/select`
- `UMASaveRequest` — для `/save`
- Query параметры через Pydantic

**models/responses.py:**
- `JSQLSelectResponse` — ответ от `/select`
- `UMAMetaListResponse` — ответ от `/meta/list`
- `UMAMetaDetailResponse` — ответ от `/meta/detail`
- Стандартные ответы для остальных endpoints

### 8. Главный файл приложения

**main.py:**
- Создание FastAPI приложения
- Подключение роутера `/api/uma`
- Lifespan events для инициализации/закрытия UMA
- Middleware для логирования запросов (опционально)
- Настройка CORS (для будущего frontend)
- Обработчики исключений (exception handlers)

### 9. Дополнительные соображения

**Безопасность:**
- Валидация всех входных данных через Pydantic
- Обработка ошибок без раскрытия внутренних деталей
- CORS настройка (пока разрешить все, позже ограничить)

**Производительность:**
- Асинхронные операции везде
- Connection pooling через SQLAlchemy
- Логирование без блокировок

**Документация:**
- OpenAPI/Swagger автоматически через FastAPI
- Описания endpoints и моделей
- Примеры запросов в docstrings

### 10. Порядок реализации

1. Создать структуру каталогов
2. Настроить `pyproject.toml` с зависимостями
3. Реализовать `config.py` и `.env.example`
4. Настроить логирование (`logging_config.py`)
5. Реализовать инициализацию UMA (`dependencies.py`)
6. Создать Pydantic модели
7. Реализовать endpoints в `routers/uma.py`
8. Собрать всё в `main.py`
9. Добавить обработку ошибок
10. Создать README с инструкциями по запуску

### 11. Вопросы для уточнения

1. URL репозитория UMA: использовать `https://github.com/aka-NameRec/uma2.git` (из ConPort) или другой?
2. База данных по умолчанию: SQLite для простоты или PostgreSQL?
3. User context: пока заглушка (например, `{"user_id": 1, "role": "admin"}`) или нужна базовая аутентификация?
4. Дополнительные endpoints: health check, версия API и т.д.?

Готов приступить к реализации после одобрения плана.

```plaintext
examples/backend_demo/
├── src/
│   ├── __init__.py
│   ├── main.py                 # Точка входа FastAPI приложения
│   ├── config.py               # Конфигурация (загрузка из .env)
│   ├── logging_config.py        # Настройка логирования
│   ├── dependencies.py         # FastAPI dependencies (инициализация UMA, user_context)
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # Роутер для всех UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic модели для запросов
│       └── responses.py         # Pydantic модели для ответов
├── .env                        # Локальные настройки (не в git)
├── .env.example                # Пример настроек
├── pyproject.toml              # Зависимости и конфигурация проекта
├── README.md                   # Документация по запуску
└── .gitignore                  # Игнорируемые файлы
```

```env
# Database connection string
# Examples:
# PostgreSQL: postgresql+asyncpg://user:password@localhost/dbname
# SQLite: sqlite+aiosqlite:///./database.db
DATABASE_URL=sqlite+aiosqlite:///./database.db

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO
```

```plaintext
2026-01-07T20:45:12.123456 INFO: UMA initialized successfully engine=<Engine> metadata=<MetaData>
2026-01-07T20:45:13.234567 ERROR: Failed to execute query entity=users error=AccessDenied user_id=123
```

---

**User**

(20260107-211156)

(20260107-211200)
> 9. Дополнительные соображения
> Безопасность:
> Обработка ошибок без раскрытия внутренних деталей

Да, но в "debug_mode" (должно задаваться в `.env`) детали должны приводиться для упрощения отладки.

(20260107-211358)
> 11. Вопросы для уточнения
> URL репозитория UMA: использовать https://github.com/aka-NameRec/uma2.git (из ConPort) или другой?

Да, URL репозитория указан корректно.

> База данных по умолчанию: SQLite для простоты или PostgreSQL?

PostgreSQL – у меня нет релевантных БД SQLite для проверки.

> User context: пока заглушка (например, {"user_id": 1, "role": "admin"}) или нужна базовая аутентификация?

Давай пока сделаем заглушку. Но позже доработаем.

> Дополнительные endpoints: health check, версия API и т.д.?

Это всё-таки demo — давай не будем спешить с этим.

(20260107-212446) Обрати внимание, что все без исключения endpoint-ы UMA должны быть на HTTP POST – это унифицирует решение.
Впрочем, если ты видишь противопоказания – пожалуйста, обозначь.

(20260107-212326) Я думаю, нам следует унифицировать возврат ошибок сервером.
Приходит в голову что-то вроде правила:
1) Если ошибки нет, возвращаем статус 200 и результаты
2) Если ошибка есть (любая), то помимо соответствующего статуса в результате возвращаем структуру вида:
   `id` – идентификатор проблемы. Можно использовать тип исключения.
   `message` – текст ошибки для конечного пользователя.
   `details` – словарь (JSON-объект) со структурным описанием ошибки для упрощения обработки на frontend. 

(20260107-212923) Каталог в `examples` лучше назвать `backend` вместо `backend_demo`.

(20260107-213010) Пожалуйста, уточни свои предложения по реализации в свете обозначенного выше.


---

**Cursor**

Уточняю план с учетом ваших требований:


## Уточнённый план реализации FastAPI-приложения для демонстрации UMA

### 1. Структура проекта

```
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # Точка входа FastAPI приложения
│   ├── config.py               # Конфигурация (загрузка из .env)
│   ├── logging_config.py        # Настройка логирования
│   ├── dependencies.py         # FastAPI dependencies (инициализация UMA, user_context)
│   ├── exceptions.py           # Обработка исключений и унифицированный формат ошибок
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # Роутер для всех UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic модели для запросов
│       └── responses.py         # Pydantic модели для ответов (включая формат ошибок)
├── .env                        # Локальные настройки (не в git)
├── .env.example                # Пример настроек
├── pyproject.toml              # Зависимости и конфигурация проекта
├── README.md                   # Документация по запуску
└── .gitignore                  # Игнорируемые файлы
```

### 2. Конфигурация (.env)

**.env.example:**
```env
# Database connection string
# PostgreSQL example: postgresql+asyncpg://user:password@localhost:5432/dbname
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/uma_demo

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Debug mode: если true, в ответах ошибок будут детальные traceback и внутренние детали
DEBUG_MODE=false
```

**config.py:**
- `DATABASE_URL` (обязательно)
- `LOG_LEVEL` (по умолчанию `INFO`)
- `DEBUG_MODE` (по умолчанию `false`, тип `bool`)

### 3. Унифицированный формат ответов

**models/responses.py:**

**Успешный ответ (200 OK):**
```python
class SuccessResponse(BaseModel):
    """Успешный ответ - данные зависят от endpoint."""
    # Данные endpoint-а напрямую в корне или в поле data
    pass
```

**Формат ошибки (любой статус ошибки):**
```python
class ErrorResponse(BaseModel):
    """Унифицированный формат ошибки."""
    id: str  # Тип исключения (например, "UMAAccessDeniedError", "JSQLSyntaxError")
    message: str  # Текст ошибки для пользователя
    details: dict[str, Any]  # Структурированные детали для frontend
```

**Примеры `details` для разных ошибок:**
- `UMAAccessDeniedError`: `{"entity_name": "...", "operation": "read"}`
- `UMANotFoundError`: `{"entity_name": "...", "id": 123}`
- `JSQLSyntaxError`: `{"path": "where.conditions[0].op", "jsql": {...}}`
- `JSQLExecutionError`: `{"query": {...}, "original_error": "..."}` (в debug_mode)
- `RuntimeError`: `{"error_type": "RuntimeError"}` (в debug_mode - полный traceback)

**exceptions.py:**
- Функция `handle_uma_exception(exception, debug_mode: bool) -> ErrorResponse`
- Маппинг исключений UMA на HTTP статусы:
  - `UMAAccessDeniedError` → 403 Forbidden
  - `UMANotFoundError` → 404 Not Found
  - `JSQLSyntaxError` → 400 Bad Request
  - `JSQLExecutionError` → 500 Internal Server Error
  - `UMAValidationError` → 400 Bad Request
  - `RuntimeError` (UMA not initialized) → 500 Internal Server Error
  - Остальные → 500 Internal Server Error
- В `debug_mode=true` добавлять в `details`:
  - Полный traceback
  - Внутренние атрибуты исключений
  - Контекст выполнения

### 4. API Endpoints (все POST)

**routers/uma.py:**

Все endpoints под префиксом `/api/uma`, все методы — POST:

1. **POST `/api/uma/select`**
   - Тело: `{"jsql": {...}, "params": {...}}` (params опционально)
   - Вызов: `uma_select(jsql, params, user_context)`
   - Успешный ответ (200): `{"meta": [...], "data": [...]}`
   - Ошибка: `ErrorResponse` с соответствующим статусом

2. **POST `/api/uma/read`**
   - Тело: `{"entity_name": "...", "id": ...}`
   - Вызов: `uma_read(entity_name, id_value, user_context)`
   - Успешный ответ (200): `{...}` (данные записи)
   - Ошибка: `ErrorResponse`

3. **POST `/api/uma/save`**
   - Тело: `{"entity_name": "...", "data": {...}}`
   - Вызов: `uma_save(entity_name, data, user_context)`
   - Успешный ответ (200): `{"id": ...}` (ID сохранённой записи)
   - Ошибка: `ErrorResponse`

4. **POST `/api/uma/delete`**
   - Тело: `{"entity_name": "...", "id": ...}`
   - Вызов: `uma_delete(entity_name, id_value, user_context)`
   - Успешный ответ (200): `{"deleted": true}`
   - Ошибка: `ErrorResponse`

5. **POST `/api/uma/meta/list`**
   - Тело: `{}` (пустое или опциональные параметры)
   - Вызов: `uma_list_entities(user_context)`
   - Успешный ответ (200): `{"entities": ["entity1", "entity2", ...]}`
   - Ошибка: `ErrorResponse`

6. **POST `/api/uma/meta/detail`**
   - Тело: `{"entity_name": "..."}`
   - Вызов: `uma_meta(entity_name, user_context)`
   - Успешный ответ (200): метаданные сущности (структура колонок и т.д.)
   - Ошибка: `ErrorResponse`

**Особенности реализации:**
- Все endpoints используют `@router.post(...)`
- Валидация через Pydantic модели
- Обработка исключений через `handle_uma_exception()`
- Логирование всех операций с контекстом
- В `debug_mode` логировать больше деталей

### 5. Обработка ошибок в FastAPI

**main.py:**
- Глобальный exception handler для всех исключений
- Использование `handle_uma_exception()` для UMA-исключений
- Для остальных исключений — общий обработчик с `ErrorResponse`
- В `debug_mode` включать traceback в `details`

**Пример структуры:**
```python
@app.exception_handler(UMAAccessDeniedError)
async def uma_access_denied_handler(request, exc):
    error = handle_uma_exception(exc, debug_mode=settings.DEBUG_MODE)
    return JSONResponse(
        status_code=403,
        content=error.model_dump()
    )
```

### 6. Модели запросов

**models/requests.py:**

```python
class JSQLSelectRequest(BaseModel):
    jsql: dict[str, Any]
    params: dict[str, Any] | None = None

class UMAReadRequest(BaseModel):
    entity_name: str
    id: Any  # Может быть int, str, UUID и т.д.

class UMASaveRequest(BaseModel):
    entity_name: str
    data: dict[str, Any]

class UMADeleteRequest(BaseModel):
    entity_name: str
    id: Any

class UMAMetaDetailRequest(BaseModel):
    entity_name: str

class UMAMetaListRequest(BaseModel):
    # Пока пустое, но может быть namespace и т.д.
    pass
```

### 7. Логирование

**logging_config.py:**
- `structlog` с текстовым рендерингом
- Формат: `ts log_level: log_message`
- ISO дата/время (локальное)
- Контекст: значения переменных, entity_name, operation и т.д.
- В `debug_mode` — более подробные логи

**Пример логов:**
```
2026-01-07T21:15:23.456789 INFO: UMA endpoint called endpoint=/api/uma/select entity_name=users
2026-01-07T21:15:23.567890 ERROR: UMA operation failed endpoint=/api/uma/read entity_name=users id=123 error=UMANotFoundError
```

### 8. Зависимости

**pyproject.toml:**
```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",  # PostgreSQL async driver
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]
```

### 9. User Context (заглушка)

**dependencies.py:**
- Функция `get_user_context()` возвращает заглушку:
  ```python
  {"user_id": 1, "role": "admin"}
  ```
- Позже можно расширить до реальной аутентификации
- Использовать как FastAPI dependency

### 10. Инициализация UMA

**dependencies.py:**
- Lifespan функция для FastAPI
- При старте:
  - Создание async engine из `DATABASE_URL`
  - Рефлексия метаданных: `await engine.run_sync(metadata.reflect)`
  - Вызов `initialize_uma(engine, metadata)`
  - Логирование успешной инициализации
- При завершении:
  - `await engine.dispose()`
  - Логирование закрытия

### 11. Обоснование использования POST для всех endpoints

Преимущества:
- Унификация: один метод для всех операций
- Гибкость: сложные параметры в теле запроса
- Безопасность: чувствительные данные не в URL
- Соответствие REST для операций с побочными эффектами

Противопоказания:
- Нет для данного случая: все операции либо изменяют состояние, либо требуют сложных параметров

### 12. Порядок реализации

1. Структура каталогов
2. `pyproject.toml` с зависимостями
3. `config.py` и `.env.example` (с `DEBUG_MODE`)
4. `logging_config.py`
5. `exceptions.py` с `handle_uma_exception()`
6. `dependencies.py` (инициализация UMA, user_context)
7. Pydantic модели (requests и responses, включая `ErrorResponse`)
8. Endpoints в `routers/uma.py` (все POST)
9. `main.py` с exception handlers
10. README с инструкциями

### 13. Примеры ответов

**Успешный запрос:**
```json
HTTP 200 OK
{
  "meta": [...],
  "data": [...]
}
```

**Ошибка (DEBUG_MODE=false):**
```json
HTTP 403 Forbidden
{
  "id": "UMAAccessDeniedError",
  "message": "Access denied for read on users",
  "details": {
    "entity_name": "users",
    "operation": "read"
  }
}
```

**Ошибка (DEBUG_MODE=true):**
```json
HTTP 403 Forbidden
{
  "id": "UMAAccessDeniedError",
  "message": "Access denied for read on users",
  "details": {
    "entity_name": "users",
    "operation": "read",
    "user_context": {"user_id": 1, "role": "user"},
    "traceback": "...",
    "internal_error": "..."
  }
}
```

Готов приступить к реализации после одобрения.

```plaintext
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # Точка входа FastAPI приложения
│   ├── config.py               # Конфигурация (загрузка из .env)
│   ├── logging_config.py        # Настройка логирования
│   ├── dependencies.py         # FastAPI dependencies (инициализация UMA, user_context)
│   ├── exceptions.py           # Обработка исключений и унифицированный формат ошибок
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # Роутер для всех UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic модели для запросов
│       └── responses.py         # Pydantic модели для ответов (включая формат ошибок)
├── .env                        # Локальные настройки (не в git)
├── .env.example                # Пример настроек
├── pyproject.toml              # Зависимости и конфигурация проекта
├── README.md                   # Документация по запуску
└── .gitignore                  # Игнорируемые файлы
```

```env
# Database connection string
# PostgreSQL example: postgresql+asyncpg://user:password@localhost:5432/dbname
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/uma_demo

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Debug mode: если true, в ответах ошибок будут детальные traceback и внутренние детали
DEBUG_MODE=false
```

```python
class SuccessResponse(BaseModel):
    """Успешный ответ - данные зависят от endpoint."""
    # Данные endpoint-а напрямую в корне или в поле data
    pass
```

```python
class ErrorResponse(BaseModel):
    """Унифицированный формат ошибки."""
    id: str  # Тип исключения (например, "UMAAccessDeniedError", "JSQLSyntaxError")
    message: str  # Текст ошибки для пользователя
    details: dict[str, Any]  # Структурированные детали для frontend
```

```python
@app.exception_handler(UMAAccessDeniedError)
async def uma_access_denied_handler(request, exc):
    error = handle_uma_exception(exc, debug_mode=settings.DEBUG_MODE)
    return JSONResponse(
        status_code=403,
        content=error.model_dump()
    )
```

```python
class JSQLSelectRequest(BaseModel):
    jsql: dict[str, Any]
    params: dict[str, Any] | None = None

class UMAReadRequest(BaseModel):
    entity_name: str
    id: Any  # Может быть int, str, UUID и т.д.

class UMASaveRequest(BaseModel):
    entity_name: str
    data: dict[str, Any]

class UMADeleteRequest(BaseModel):
    entity_name: str
    id: Any

class UMAMetaDetailRequest(BaseModel):
    entity_name: str

class UMAMetaListRequest(BaseModel):
    # Пока пустое, но может быть namespace и т.д.
    pass
```

```plaintext
2026-01-07T21:15:23.456789 INFO: UMA endpoint called endpoint=/api/uma/select entity_name=users
2026-01-07T21:15:23.567890 ERROR: UMA operation failed endpoint=/api/uma/read entity_name=users id=123 error=UMANotFoundError
```

```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",  # PostgreSQL async driver
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]
```

```python
  {"user_id": 1, "role": "admin"}
```

```json
HTTP 200 OK
{
  "meta": [...],
  "data": [...]
}
```

```json
HTTP 403 Forbidden
{
  "id": "UMAAccessDeniedError",
  "message": "Access denied for read on users",
  "details": {
    "entity_name": "users",
    "operation": "read"
  }
}
```

```json
HTTP 403 Forbidden
{
  "id": "UMAAccessDeniedError",
  "message": "Access denied for read on users",
  "details": {
    "entity_name": "users",
    "operation": "read",
    "user_context": {"user_id": 1, "role": "user"},
    "traceback": "...",
    "internal_error": "..."
  }
}
```

---

**User**

(20260107-213819)

(20260107-213825) Давай переименуем:
`/api/uma/meta/list` → `/api/uma/meta/entity_list`
`/api/uma/meta/detail` → `/api/uma/meta/entity_details`

(20260107-214110)
> 7. Логирование
> logging_config.py:
> structlog с текстовым рендерингом

(1) `structlog` – Ok, но ОЧЕНЬ ВАЖНО: его настройка должна быть такой, чтобы использование обычного logging приводило к использованию формата логгирования, который будет настроен для `structlog`.

(2) Обращаю внимание, что и Uvicorn и FastAPI используют логгирование.
Нужно обеспечить, чтобы формат лога был такой, как он настроен для приложения.
Посмотри рекомендованные решения на этот счёт.

(20260107-214456)
> В debug_mode — более подробные логи

Подробность логов должна регулироваться только уровнем логгирования в `.env`.
При прочих равных все сообщения, выдаваемые в лог должны максимально точно описывать случившуюся проблему и/или состояние, если это информационное сообщение.

(20260107-214712)
> 10. Инициализация UMA
> dependencies.py:

Несмотря на то, что у нас demo-приложение, для обеспечения гибкости разработки, думаю, нам следует использовать библиотеку внедрения зависимостей.
Что является лучшим выбором в этой связи в 2026?

(20260107-214402) Пожалуйста, обнови свои предложения по реализации соответственно обозначенному выше.

---

**Cursor**

Изучаю лучшие практики для логирования и DI, затем обновлю план.


Изучаю актуальные практики для DI и интеграции structlog с Uvicorn/FastAPI:


## Обновлённый план реализации FastAPI-приложения для демонстрации UMA

### 1. Структура проекта

```
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # Точка входа FastAPI приложения
│   ├── config.py               # Конфигурация (загрузка из .env)
│   ├── logging_config.py       # Настройка логирования (structlog + stdlib)
│   ├── dependencies.py         # DI контейнер и провайдеры
│   ├── exceptions.py           # Обработка исключений и унифицированный формат ошибок
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # Роутер для всех UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic модели для запросов
│       └── responses.py        # Pydantic модели для ответов (включая формат ошибок)
├── .env                        # Локальные настройки (не в git)
├── .env.example                # Пример настроек
├── pyproject.toml              # Зависимости и конфигурация проекта
├── README.md                   # Документация по запуску
└── .gitignore                  # Игнорируемые файлы
```

### 2. Конфигурация (.env)

**.env.example:**
```env
# Database connection string
# PostgreSQL example: postgresql+asyncpg://user:password@localhost:5432/dbname
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/uma_demo

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Debug mode: если true, в ответах ошибок будут детальные traceback и внутренние детали
DEBUG_MODE=false
```

**config.py:**
- `DATABASE_URL` (обязательно)
- `LOG_LEVEL` (по умолчанию `INFO`)
- `DEBUG_MODE` (по умолчанию `false`, тип `bool`)

### 3. Логирование (structlog + стандартный logging)

**logging_config.py:**

**Ключевые требования:**
1. `structlog` настроен так, что обычный `logging` использует тот же формат
2. Uvicorn и FastAPI логи выводятся в том же формате
3. Формат: `ts log_level: log_message` (ISO дата/время, локальное время)
4. Подробность только через `LOG_LEVEL` в `.env`
5. Сообщения должны точно описывать проблему/состояние

**Реализация:**

```python
import logging
import sys
import structlog
from structlog.stdlib import LoggerFactory

def configure_logging(log_level: str) -> None:
    """
    Configure structlog to work with standard logging.
    All logging (including uvicorn and fastapi) will use the same format.
    """
    # Convert string level to logging constant
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    
    # Configure standard logging first
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=numeric_level,
    )
    
    # Configure structlog to use standard logging
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,  # Merge context variables
            structlog.processors.add_log_level,       # Add log level
            structlog.processors.TimeStamper(fmt="iso", utc=False),  # ISO timestamp, local time
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # Configure formatter for standard logging handlers
    formatter = structlog.stdlib.ProcessorFormatter(
        processor=structlog.dev.ConsoleRenderer(),  # Text renderer
        foreign_pre_chain=[
            structlog.stdlib.add_log_level,
            structlog.stdlib.add_logger_name,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
        ],
    )
    
    # Apply formatter to root logger and uvicorn/fastapi loggers
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    
    root_logger = logging.getLogger()
    root_logger.handlers = [handler]
    root_logger.setLevel(numeric_level)
    
    # Configure uvicorn and fastapi loggers
    for logger_name in ["uvicorn", "uvicorn.access", "uvicorn.error", "fastapi"]:
        logger = logging.getLogger(logger_name)
        logger.handlers = [handler]
        logger.setLevel(numeric_level)
        logger.propagate = False
```

**Использование:**
- В коде: `logger = structlog.get_logger()` для структурированного логирования
- Стандартный `logging.getLogger(__name__)` также будет использовать тот же формат через `structlog.stdlib`

**Примеры логов:**
```
2026-01-07T21:45:12.123456 INFO: UMA endpoint called endpoint=/api/uma/select entity_name=users user_id=1
2026-01-07T21:45:13.234567 ERROR: UMA operation failed endpoint=/api/uma/read entity_name=users id=123 error_type=UMANotFoundError error_message=Entity or record not found: users
```

### 4. Dependency Injection

**dependencies.py:**

**Рекомендация:** использовать `dependency-injector` (популярная, стабильная, хорошо интегрируется с FastAPI) или встроенную систему FastAPI `Depends` для простоты.

**Вариант 1: dependency-injector (рекомендуется для гибкости):**
```python
from dependency_injector import containers, providers
from dependency_injector.wiring import Provide, inject
from fastapi import Depends

class Container(containers.DeclarativeContainer):
    """DI Container for application dependencies."""
    
    # Configuration
    config = providers.Configuration()
    
    # Database
    engine = providers.Singleton(
        create_async_engine,
        config.database_url,
    )
    
    metadata = providers.Singleton(MetaData)
    
    # UMA initialization
    uma_registry = providers.Singleton(
        initialize_uma,
        engine=engine,
        metadata=metadata,
    )
    
    # User context (stub for now)
    user_context = providers.Factory(
        lambda: {"user_id": 1, "role": "admin"}
    )
```

**Вариант 2: FastAPI Depends (проще для demo):**
- Использовать встроенную систему FastAPI
- Создать функции-зависимости для UMA компонентов
- Проще в настройке, но менее гибко для масштабирования

**Рекомендация:** для demo использовать `dependency-injector`, так как это даст гибкость для будущего расширения, при этом не усложняя текущую реализацию.

### 5. Унифицированный формат ответов

**models/responses.py:**

**Успешный ответ (200 OK):**
```python
# Данные endpoint-а напрямую в корне ответа
```

**Формат ошибки:**
```python
class ErrorResponse(BaseModel):
    """Унифицированный формат ошибки."""
    id: str  # Тип исключения
    message: str  # Текст для пользователя
    details: dict[str, Any]  # Структурированные детали
```

**exceptions.py:**
- `handle_uma_exception(exception, debug_mode: bool) -> ErrorResponse`
- Маппинг исключений на HTTP статусы
- В `debug_mode=true` добавлять в `details`:
  - Полный traceback
  - Внутренние атрибуты исключений
  - Контекст выполнения

### 6. API Endpoints (все POST)

**routers/uma.py:**

Все endpoints под префиксом `/api/uma`, все методы — POST:

1. **POST `/api/uma/select`**
   - Тело: `{"jsql": {...}, "params": {...}}`
   - Успешный ответ (200): `{"meta": [...], "data": [...]}`

2. **POST `/api/uma/read`**
   - Тело: `{"entity_name": "...", "id": ...}`
   - Успешный ответ (200): `{...}` (данные записи)

3. **POST `/api/uma/save`**
   - Тело: `{"entity_name": "...", "data": {...}}`
   - Успешный ответ (200): `{"id": ...}`

4. **POST `/api/uma/delete`**
   - Тело: `{"entity_name": "...", "id": ...}`
   - Успешный ответ (200): `{"deleted": true}`

5. **POST `/api/uma/meta/entity_list`** (переименовано)
   - Тело: `{}` (пустое или опциональные параметры)
   - Успешный ответ (200): `{"entities": ["entity1", "entity2", ...]}`

6. **POST `/api/uma/meta/entity_details`** (переименовано)
   - Тело: `{"entity_name": "..."}`
   - Успешный ответ (200): метаданные сущности

### 7. Инициализация UMA

**dependencies.py:**
- Lifespan функция для FastAPI
- При старте:
  - Создание async engine из `DATABASE_URL`
  - Рефлексия метаданных: `await engine.run_sync(metadata.reflect)`
  - Вызов `initialize_uma(engine, metadata)`
  - Логирование успешной инициализации с контекстом
- При завершении:
  - `await engine.dispose()`
  - Логирование закрытия

### 8. Зависимости

**pyproject.toml:**
```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",  # PostgreSQL async driver
    "dependency-injector>=4.41.0",  # DI library
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]
```

### 9. Особенности реализации

**Логирование:**
- Все сообщения должны точно описывать проблему/состояние
- Контекст: endpoint, entity_name, user_id, operation и т.д.
- Подробность только через `LOG_LEVEL`, не через `DEBUG_MODE`
- `DEBUG_MODE` влияет только на детали в ответах ошибок, не на логи

**Обработка ошибок:**
- Унифицированный формат через `ErrorResponse`
- `DEBUG_MODE` влияет на детали в `details` поля ошибки
- Логи всегда содержат максимум информации (в соответствии с `LOG_LEVEL`)

**DI:**
- Использовать `dependency-injector` для гибкости
- Инициализация через lifespan events
- Зависимости доступны через FastAPI `Depends`

### 10. Порядок реализации

1. Структура каталогов
2. `pyproject.toml` с зависимостями (включая `dependency-injector`)
3. `config.py` и `.env.example`
4. `logging_config.py` (structlog + stdlib интеграция)
5. `exceptions.py` с `handle_uma_exception()`
6. `dependencies.py` (DI container, инициализация UMA)
7. Pydantic модели (requests и responses, включая `ErrorResponse`)
8. Endpoints в `routers/uma.py` (все POST, переименованные пути)
9. `main.py` с exception handlers и lifespan
10. README с инструкциями

### 11. Резюме изменений

1. Переименованы endpoints:
   - `/api/uma/meta/list` → `/api/uma/meta/entity_list`
   - `/api/uma/meta/detail` → `/api/uma/meta/entity_details`

2. Логирование:
   - `structlog` интегрирован со стандартным `logging`
   - Uvicorn и FastAPI используют тот же формат
   - Подробность только через `LOG_LEVEL`

3. DI:
   - Использование `dependency-injector` для гибкости

4. Debug mode:
   - Влияет только на детали в ответах ошибок
   - Логи всегда подробные (в соответствии с `LOG_LEVEL`)

Готов приступить к реализации после одобрения.

```plaintext
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # Точка входа FastAPI приложения
│   ├── config.py               # Конфигурация (загрузка из .env)
│   ├── logging_config.py       # Настройка логирования (structlog + stdlib)
│   ├── dependencies.py         # DI контейнер и провайдеры
│   ├── exceptions.py           # Обработка исключений и унифицированный формат ошибок
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # Роутер для всех UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic модели для запросов
│       └── responses.py        # Pydantic модели для ответов (включая формат ошибок)
├── .env                        # Локальные настройки (не в git)
├── .env.example                # Пример настроек
├── pyproject.toml              # Зависимости и конфигурация проекта
├── README.md                   # Документация по запуску
└── .gitignore                  # Игнорируемые файлы
```

```env
# Database connection string
# PostgreSQL example: postgresql+asyncpg://user:password@localhost:5432/dbname
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/uma_demo

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Debug mode: если true, в ответах ошибок будут детальные traceback и внутренние детали
DEBUG_MODE=false
```

```python
import logging
import sys
import structlog
from structlog.stdlib import LoggerFactory

def configure_logging(log_level: str) -> None:
    """
    Configure structlog to work with standard logging.
    All logging (including uvicorn and fastapi) will use the same format.
    """
    # Convert string level to logging constant
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    
    # Configure standard logging first
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=numeric_level,
    )
    
    # Configure structlog to use standard logging
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,  # Merge context variables
            structlog.processors.add_log_level,       # Add log level
            structlog.processors.TimeStamper(fmt="iso", utc=False),  # ISO timestamp, local time
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # Configure formatter for standard logging handlers
    formatter = structlog.stdlib.ProcessorFormatter(
        processor=structlog.dev.ConsoleRenderer(),  # Text renderer
        foreign_pre_chain=[
            structlog.stdlib.add_log_level,
            structlog.stdlib.add_logger_name,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
        ],
    )
    
    # Apply formatter to root logger and uvicorn/fastapi loggers
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    
    root_logger = logging.getLogger()
    root_logger.handlers = [handler]
    root_logger.setLevel(numeric_level)
    
    # Configure uvicorn and fastapi loggers
    for logger_name in ["uvicorn", "uvicorn.access", "uvicorn.error", "fastapi"]:
        logger = logging.getLogger(logger_name)
        logger.handlers = [handler]
        logger.setLevel(numeric_level)
        logger.propagate = False
```

```plaintext
2026-01-07T21:45:12.123456 INFO: UMA endpoint called endpoint=/api/uma/select entity_name=users user_id=1
2026-01-07T21:45:13.234567 ERROR: UMA operation failed endpoint=/api/uma/read entity_name=users id=123 error_type=UMANotFoundError error_message=Entity or record not found: users
```

```python
from dependency_injector import containers, providers
from dependency_injector.wiring import Provide, inject
from fastapi import Depends

class Container(containers.DeclarativeContainer):
    """DI Container for application dependencies."""
    
    # Configuration
    config = providers.Configuration()
    
    # Database
    engine = providers.Singleton(
        create_async_engine,
        config.database_url,
    )
    
    metadata = providers.Singleton(MetaData)
    
    # UMA initialization
    uma_registry = providers.Singleton(
        initialize_uma,
        engine=engine,
        metadata=metadata,
    )
    
    # User context (stub for now)
    user_context = providers.Factory(
        lambda: {"user_id": 1, "role": "admin"}
    )
```

```python
# Данные endpoint-а напрямую в корне ответа
```

```python
class ErrorResponse(BaseModel):
    """Унифицированный формат ошибки."""
    id: str  # Тип исключения
    message: str  # Текст для пользователя
    details: dict[str, Any]  # Структурированные детали
```

```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",  # PostgreSQL async driver
    "dependency-injector>=4.41.0",  # DI library
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]
```

---

**User**

(20260110-174422) Продолжение по backend

(20260110-174543) Пожалуйста, изучи текущее состояние проекта, поскольку в него внесены существенные изменения, направление которых изложено в `docs/20260109-154412-log-initialization_refactor.md`.
Обнови ConPort знаниями, полученными в результате изучения.

(20260110-174659) Пожалуйста, обнови свои предложения по реализации demo для backend, основанного на UMA в свете изученного, а также следующих соображений:

> ### (20260107-210903) Переименования
> 
>> GET /api/uma/meta/detail
>> Query params: entity_name
>> Вызов: uma_meta(entity_name, user_context)
>> Ответ: метаданные сущности (структура колонок и т.д.)
> 
> Нужно переименовать `uma_list` → `uma_entity_list` и `uma_meta` → `uma_entity_details`.
> 
> ### (20260107-213439) Тело изменённой записи в результате `uma_save`
> 
>> POST /api/uma/save
>> Тело: {"entity_name": "...", "data": {...}}
>> Вызов: uma_save(entity_name, data, user_context)
>> Успешный ответ (200): {"id": ...} (ID сохранённой записи)
>> Ошибка: ErrorResponse
> 
> `uma_save` всё-таки должен возвращать тело добавленной записи. Это нужно для форм ввода, чтобы лишний раз не перечитывать запись.

(20260110-174801) Изменения в код не вноси, сейчас нужен только план реализации.

---

**Cursor**

Изучаю текущее состояние проекта и ключевые изменения:

Изучаю дополнительные детали архитектуры:

Обновляю ConPort знаниями о рефакторинге инициализации:

Изучаю текущий экспорт API:

## Обновлённый план реализации FastAPI backend demo с учётом рефакторинга UMA

### Ключевые изменения в UMA, влияющие на backend

**1. Инициализация UMA (критично)**:
- **Старый API** (не работает): `initialize_uma(engine, metadata, metadata_provider)`
- **Новый API**: `uma_initialize(namespace_configs, default_handler)`
- Пример:
  ```python
  uma_initialize({
      'main': NamespaceConfig(
          engine=async_engine,
          metadata_provider=DefaultMetadataProvider(),
      ),
  })
  ```

**2. Ленивая загрузка метаданных**:
- Метаданные БД загружаются автоматически при первом запросе к сущности
- НЕ нужно вызывать `metadata.reflect()` перед инициализацией
- Опционально: можно вызвать `metadata_provider.preload(engine, 'main')` для предзагрузки

**3. Namespace-based архитектура**:
- Каждый namespace имеет свой engine и metadata_provider
- Для одной БД достаточно одного namespace (он станет default)
- Entity names могут включать namespace: `'db1:users'` или просто `'users'` (если есть default)

**4. API функции**:
- Текущие: `uma_list_entities`, `uma_meta`, `uma_read`, `uma_save`, `uma_delete`, `uma_select`
- Требуется добавить aliases: `uma_entity_list` → `uma_list_entities`, `uma_entity_details` → `uma_meta`
- `uma_save` должен возвращать полное тело записи, а не только ID

### Обновлённая структура проекта

```
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение с lifespan
│   ├── config.py               # Настройки из .env
│   ├── logging_config.py       # structlog + stdlib интеграция
│   ├── dependencies.py         # DI container (dependency-injector)
│   ├── exceptions.py           # Обработчики исключений UMA
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic request models
│       └── responses.py        # Pydantic response models (включая ErrorResponse)
├── .env                        # Локальные настройки
├── .env.example                # Пример
├── pyproject.toml              # Зависимости
├── README.md                   # Инструкции
└── .gitignore
```

### Конфигурация

**.env.example:**
```env
# PostgreSQL connection string (asyncpg required)
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/database_name

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Debug mode: детальные traceback в ответах ошибок (не влияет на логи)
DEBUG_MODE=false
```

**config.py:**
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str  # Обязательно
    log_level: str = "INFO"
    debug_mode: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### Dependency Injection

**dependencies.py:**

Использовать `dependency-injector` для управления зависимостями:

```python
from dependency_injector import containers, providers
from sqlalchemy.ext.asyncio import create_async_engine
from namerec.uma import uma_initialize, NamespaceConfig, DefaultMetadataProvider

class Container(containers.DeclarativeContainer):
    """Application DI container."""
    
    # Configuration
    config = providers.Configuration()
    
    # Database engine (async)
    engine = providers.Singleton(
        create_async_engine,
        config.database_url,
        echo=False,
    )
    
    # UMA metadata provider
    metadata_provider = providers.Singleton(DefaultMetadataProvider)
    
    # UMA initialization (called once at startup)
    # Note: uma_initialize returns registry
    registry = providers.Singleton(
        lambda engine, provider: uma_initialize({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=provider,
            ),
        }),
        engine=engine,
        provider=metadata_provider,
    )
    
    # User context stub (для демо)
    user_context = providers.Factory(
        lambda: {"user_id": 1, "role": "admin"}
    )
```

**Lifespan management в main.py:**
```python
from contextlib import asynccontextmanager
from fastapi import FastAPI

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifecycle."""
    # Startup: инициализация UMA
    container.registry()  # Инициализирует UMA
    
    # Опционально: предзагрузка метаданных для production
    # await container.metadata_provider().preload(
    #     container.engine(), 
    #     'main'
    # )
    
    logger.info("UMA initialized", namespace="main")
    
    yield
    
    # Shutdown: закрытие соединений
    await container.engine().dispose()
    logger.info("Database connections closed")

app = FastAPI(lifespan=lifespan)
```

### Логирование

**logging_config.py:**

Полная интеграция structlog со стандартным logging (включая uvicorn):

```python
import logging
import sys
import structlog

def configure_logging(log_level: str) -> None:
    """Configure structlog + standard logging integration."""
    
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    
    # Standard logging configuration
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=numeric_level,
    )
    
    # structlog configuration
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # Custom formatter for text output
    formatter = structlog.stdlib.ProcessorFormatter(
        processor=structlog.dev.ConsoleRenderer(),
        foreign_pre_chain=[
            structlog.stdlib.add_log_level,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
        ],
    )
    
    # Apply to all loggers (root, uvicorn, fastapi)
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    
    root_logger = logging.getLogger()
    root_logger.handlers = [handler]
    root_logger.setLevel(numeric_level)
    
    # Configure uvicorn loggers
    for logger_name in ["uvicorn", "uvicorn.access", "uvicorn.error", "fastapi"]:
        logger = logging.getLogger(logger_name)
        logger.handlers = [handler]
        logger.setLevel(numeric_level)
        logger.propagate = False
```

### API Endpoints (все POST)

**routers/uma.py:**

**Переименования**:
- `/api/uma/meta/entity_list` - соответствует `uma_list_entities`
- `/api/uma/meta/entity_details` - соответствует `uma_meta`

**Изменения в `uma_save`**:
- Должен возвращать **полное тело записи**, а не только ID
- После сохранения нужно вызвать `uma_read` чтобы получить запись

Все endpoints - POST:

1. **POST `/api/uma/select`**
   ```python
   class SelectRequest(BaseModel):
       jsql: dict[str, Any]
       params: dict[str, Any] | None = None
   
   class SelectResponse(BaseModel):
       meta: list[dict[str, Any]]
       data: list[dict[str, Any]]
   
   @router.post("/select", response_model=SelectResponse)
   async def select_endpoint(
       request: SelectRequest,
       user_context: dict = Depends(get_user_context),
   ):
       result = await uma_select(
           jsql=request.jsql,
           params=request.params,
           user_context=user_context,
       )
       return result
   ```

2. **POST `/api/uma/read`**
   ```python
   class ReadRequest(BaseModel):
       entity_name: str
       id: Any
   
   @router.post("/read")
   async def read_endpoint(
       request: ReadRequest,
       user_context: dict = Depends(get_user_context),
   ):
       return await uma_read(
           entity_name=request.entity_name,
           id_value=request.id,
           user_context=user_context,
       )
   ```

3. **POST `/api/uma/save`** (ВАЖНО: возвращает тело записи)
   ```python
   class SaveRequest(BaseModel):
       entity_name: str
       data: dict[str, Any]
   
   @router.post("/save")
   async def save_endpoint(
       request: SaveRequest,
       user_context: dict = Depends(get_user_context),
   ):
       # Save record (returns ID)
       saved_id = await uma_save(
           entity_name=request.entity_name,
           data=request.data,
           user_context=user_context,
       )
       
       # Read back the full record
       record = await uma_read(
           entity_name=request.entity_name,
           id_value=saved_id,
           user_context=user_context,
       )
       
       return record  # Возвращаем полное тело
   ```

4. **POST `/api/uma/delete`**
   ```python
   class DeleteRequest(BaseModel):
       entity_name: str
       id: Any
   
   class DeleteResponse(BaseModel):
       deleted: bool
   
   @router.post("/delete", response_model=DeleteResponse)
   async def delete_endpoint(
       request: DeleteRequest,
       user_context: dict = Depends(get_user_context),
   ):
       deleted = await uma_delete(
           entity_name=request.entity_name,
           id_value=request.id,
           user_context=user_context,
       )
       return {"deleted": deleted}
   ```

5. **POST `/api/uma/meta/entity_list`**
   ```python
   class EntityListRequest(BaseModel):
       namespace: str | None = None
   
   class EntityListResponse(BaseModel):
       entities: list[str]
   
   @router.post("/meta/entity_list", response_model=EntityListResponse)
   async def entity_list_endpoint(
       request: EntityListRequest,
       user_context: dict = Depends(get_user_context),
   ):
       entities = await uma_list_entities(
           user_context=user_context,
           namespace=request.namespace,
       )
       return {"entities": entities}
   ```

6. **POST `/api/uma/meta/entity_details`**
   ```python
   class EntityDetailsRequest(BaseModel):
       entity_name: str
   
   @router.post("/meta/entity_details")
   async def entity_details_endpoint(
       request: EntityDetailsRequest,
       user_context: dict = Depends(get_user_context),
   ):
       return await uma_meta(
           entity_name=request.entity_name,
           user_context=user_context,
       )
   ```

### Обработка ошибок

**models/responses.py:**
```python
class ErrorResponse(BaseModel):
    """Унифицированный формат ошибки."""
    id: str  # Тип исключения
    message: str  # Для пользователя
    details: dict[str, Any]  # Структурированные детали
```

**exceptions.py:**
```python
from namerec.uma import (
    UMAAccessDeniedError, UMANotFoundError, 
    UMAValidationError, JSQLSyntaxError, JSQLExecutionError
)

def handle_uma_exception(exc: Exception, debug_mode: bool) -> ErrorResponse:
    """Convert UMA exception to ErrorResponse."""
    
    error_id = exc.__class__.__name__
    message = str(exc)
    details = {}
    
    # Extract structured details from exception
    if isinstance(exc, UMAAccessDeniedError):
        details = {
            "entity_name": getattr(exc, 'entity_name', None),
            "operation": getattr(exc, 'operation', None),
        }
    elif isinstance(exc, UMANotFoundError):
        details = {
            "entity_name": getattr(exc, 'entity_name', None),
        }
    elif isinstance(exc, JSQLSyntaxError):
        details = {
            "path": getattr(exc, 'path', None),
        }
    elif isinstance(exc, JSQLExecutionError):
        details = {
            "query": getattr(exc, 'query', None),
        }
    
    # Add debug info if enabled
    if debug_mode:
        import traceback
        details["traceback"] = traceback.format_exc()
        details["exception_type"] = error_id
    
    return ErrorResponse(
        id=error_id,
        message=message,
        details=details,
    )

# Exception handlers для main.py
@app.exception_handler(UMAAccessDeniedError)
async def uma_access_denied_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=403, content=error.dict())

@app.exception_handler(UMANotFoundError)
async def uma_not_found_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=404, content=error.dict())

@app.exception_handler(JSQLSyntaxError)
async def jsql_syntax_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=400, content=error.dict())

@app.exception_handler(JSQLExecutionError)
async def jsql_execution_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=500, content=error.dict())
```

### Зависимости

**pyproject.toml:**
```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",
    "dependency-injector>=4.41.0",
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

### Порядок реализации

1. ✅ Структура каталогов `examples/backend/`
2. ✅ `pyproject.toml` с зависимостями
3. ✅ `.env.example` и `config.py`
4. ✅ `logging_config.py` (structlog + stdlib)
5. ✅ `dependencies.py` (DI container с новой инициализацией UMA)
6. ✅ `exceptions.py` (обработчики UMA исключений)
7. ✅ `models/requests.py` и `models/responses.py`
8. ✅ `routers/uma.py` (все endpoints POST, переименованные пути)
9. ✅ `main.py` (lifespan, exception handlers, роутеры)
10. ✅ `README.md` (инструкции по запуску)

### Ключевые отличия от предыдущего плана

1. **Инициализация UMA**: используется новый API с `NamespaceConfig`, без предварительной рефлексии metadata
2. **Ленивая загрузка**: metadata загружается автоматически при первом запросе
3. **Namespace**: одна БД = один namespace 'main', который становится default
4. **Переименования API**: пути соответствуют новым функциям UMA
5. **`uma_save`**: возвращает полное тело записи через последующий `uma_read`
6. **Логирование**: подробность только через `LOG_LEVEL`, `DEBUG_MODE` только для ответов ошибок

Готов к реализации после одобрения.

```python
  uma_initialize({
      'main': NamespaceConfig(
          engine=async_engine,
          metadata_provider=DefaultMetadataProvider(),
      ),
  })
```

```plaintext
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение с lifespan
│   ├── config.py               # Настройки из .env
│   ├── logging_config.py       # structlog + stdlib интеграция
│   ├── dependencies.py         # DI container (dependency-injector)
│   ├── exceptions.py           # Обработчики исключений UMA
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic request models
│       └── responses.py        # Pydantic response models (включая ErrorResponse)
├── .env                        # Локальные настройки
├── .env.example                # Пример
├── pyproject.toml              # Зависимости
├── README.md                   # Инструкции
└── .gitignore
```

```env
# PostgreSQL connection string (asyncpg required)
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/database_name

# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO

# Debug mode: детальные traceback в ответах ошибок (не влияет на логи)
DEBUG_MODE=false
```

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str  # Обязательно
    log_level: str = "INFO"
    debug_mode: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()
```

```python
from dependency_injector import containers, providers
from sqlalchemy.ext.asyncio import create_async_engine
from namerec.uma import uma_initialize, NamespaceConfig, DefaultMetadataProvider

class Container(containers.DeclarativeContainer):
    """Application DI container."""
    
    # Configuration
    config = providers.Configuration()
    
    # Database engine (async)
    engine = providers.Singleton(
        create_async_engine,
        config.database_url,
        echo=False,
    )
    
    # UMA metadata provider
    metadata_provider = providers.Singleton(DefaultMetadataProvider)
    
    # UMA initialization (called once at startup)
    # Note: uma_initialize returns registry
    registry = providers.Singleton(
        lambda engine, provider: uma_initialize({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=provider,
            ),
        }),
        engine=engine,
        provider=metadata_provider,
    )
    
    # User context stub (для демо)
    user_context = providers.Factory(
        lambda: {"user_id": 1, "role": "admin"}
    )
```

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifecycle."""
    # Startup: инициализация UMA
    container.registry()  # Инициализирует UMA
    
    # Опционально: предзагрузка метаданных для production
    # await container.metadata_provider().preload(
    #     container.engine(), 
    #     'main'
    # )
    
    logger.info("UMA initialized", namespace="main")
    
    yield
    
    # Shutdown: закрытие соединений
    await container.engine().dispose()
    logger.info("Database connections closed")

app = FastAPI(lifespan=lifespan)
```

```python
import logging
import sys
import structlog

def configure_logging(log_level: str) -> None:
    """Configure structlog + standard logging integration."""
    
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)
    
    # Standard logging configuration
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=numeric_level,
    )
    
    # structlog configuration
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # Custom formatter for text output
    formatter = structlog.stdlib.ProcessorFormatter(
        processor=structlog.dev.ConsoleRenderer(),
        foreign_pre_chain=[
            structlog.stdlib.add_log_level,
            structlog.processors.TimeStamper(fmt="iso", utc=False),
        ],
    )
    
    # Apply to all loggers (root, uvicorn, fastapi)
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)
    
    root_logger = logging.getLogger()
    root_logger.handlers = [handler]
    root_logger.setLevel(numeric_level)
    
    # Configure uvicorn loggers
    for logger_name in ["uvicorn", "uvicorn.access", "uvicorn.error", "fastapi"]:
        logger = logging.getLogger(logger_name)
        logger.handlers = [handler]
        logger.setLevel(numeric_level)
        logger.propagate = False
```

```python
   class SelectRequest(BaseModel):
       jsql: dict[str, Any]
       params: dict[str, Any] | None = None
   
   class SelectResponse(BaseModel):
       meta: list[dict[str, Any]]
       data: list[dict[str, Any]]
   
   @router.post("/select", response_model=SelectResponse)
   async def select_endpoint(
       request: SelectRequest,
       user_context: dict = Depends(get_user_context),
   ):
       result = await uma_select(
           jsql=request.jsql,
           params=request.params,
           user_context=user_context,
       )
       return result
```

```python
   class ReadRequest(BaseModel):
       entity_name: str
       id: Any
   
   @router.post("/read")
   async def read_endpoint(
       request: ReadRequest,
       user_context: dict = Depends(get_user_context),
   ):
       return await uma_read(
           entity_name=request.entity_name,
           id_value=request.id,
           user_context=user_context,
       )
```

```python
   class SaveRequest(BaseModel):
       entity_name: str
       data: dict[str, Any]
   
   @router.post("/save")
   async def save_endpoint(
       request: SaveRequest,
       user_context: dict = Depends(get_user_context),
   ):
       # Save record (returns ID)
       saved_id = await uma_save(
           entity_name=request.entity_name,
           data=request.data,
           user_context=user_context,
       )
       
       # Read back the full record
       record = await uma_read(
           entity_name=request.entity_name,
           id_value=saved_id,
           user_context=user_context,
       )
       
       return record  # Возвращаем полное тело
```

```python
   class DeleteRequest(BaseModel):
       entity_name: str
       id: Any
   
   class DeleteResponse(BaseModel):
       deleted: bool
   
   @router.post("/delete", response_model=DeleteResponse)
   async def delete_endpoint(
       request: DeleteRequest,
       user_context: dict = Depends(get_user_context),
   ):
       deleted = await uma_delete(
           entity_name=request.entity_name,
           id_value=request.id,
           user_context=user_context,
       )
       return {"deleted": deleted}
```

```python
   class EntityListRequest(BaseModel):
       namespace: str | None = None
   
   class EntityListResponse(BaseModel):
       entities: list[str]
   
   @router.post("/meta/entity_list", response_model=EntityListResponse)
   async def entity_list_endpoint(
       request: EntityListRequest,
       user_context: dict = Depends(get_user_context),
   ):
       entities = await uma_list_entities(
           user_context=user_context,
           namespace=request.namespace,
       )
       return {"entities": entities}
```

```python
   class EntityDetailsRequest(BaseModel):
       entity_name: str
   
   @router.post("/meta/entity_details")
   async def entity_details_endpoint(
       request: EntityDetailsRequest,
       user_context: dict = Depends(get_user_context),
   ):
       return await uma_meta(
           entity_name=request.entity_name,
           user_context=user_context,
       )
```

```python
class ErrorResponse(BaseModel):
    """Унифицированный формат ошибки."""
    id: str  # Тип исключения
    message: str  # Для пользователя
    details: dict[str, Any]  # Структурированные детали
```

```python
from namerec.uma import (
    UMAAccessDeniedError, UMANotFoundError, 
    UMAValidationError, JSQLSyntaxError, JSQLExecutionError
)

def handle_uma_exception(exc: Exception, debug_mode: bool) -> ErrorResponse:
    """Convert UMA exception to ErrorResponse."""
    
    error_id = exc.__class__.__name__
    message = str(exc)
    details = {}
    
    # Extract structured details from exception
    if isinstance(exc, UMAAccessDeniedError):
        details = {
            "entity_name": getattr(exc, 'entity_name', None),
            "operation": getattr(exc, 'operation', None),
        }
    elif isinstance(exc, UMANotFoundError):
        details = {
            "entity_name": getattr(exc, 'entity_name', None),
        }
    elif isinstance(exc, JSQLSyntaxError):
        details = {
            "path": getattr(exc, 'path', None),
        }
    elif isinstance(exc, JSQLExecutionError):
        details = {
            "query": getattr(exc, 'query', None),
        }
    
    # Add debug info if enabled
    if debug_mode:
        import traceback
        details["traceback"] = traceback.format_exc()
        details["exception_type"] = error_id
    
    return ErrorResponse(
        id=error_id,
        message=message,
        details=details,
    )

# Exception handlers для main.py
@app.exception_handler(UMAAccessDeniedError)
async def uma_access_denied_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=403, content=error.dict())

@app.exception_handler(UMANotFoundError)
async def uma_not_found_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=404, content=error.dict())

@app.exception_handler(JSQLSyntaxError)
async def jsql_syntax_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=400, content=error.dict())

@app.exception_handler(JSQLExecutionError)
async def jsql_execution_handler(request, exc):
    error = handle_uma_exception(exc, settings.debug_mode)
    return JSONResponse(status_code=500, content=error.dict())
```

```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",
    "dependency-injector>=4.41.0",
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

---

**User**

(20260110-175426) Уточнение:

> Требуется добавить aliases: uma_entity_list → uma_list_entities, uma_entity_details → uma_meta

Речь идёт об именно переименовании, я не об алиасе. У нас нет production, мы можем не заботиться об обратной совместимости.

(20260110-175444) В backend-приложение нужно добавить endpoint-ы для преобразований SQL <-> JSQL.
Предлагаю пути: `/api/uma/transform/sql2jsql` и `/api/uma/transform/jsql2sql`.
Предлагается сделать это POST-запросами, входящий параметр с текстом для преобразования назвать `data` – или ты предложишь лучшее название?
Кроме того, могут понадобиться параметры `dialect` и, уже не помнюб что там – посмотри пожалуйста определение соответствующих функций.
Важно, что это опциональные параметры.
Результат endpoint-ов должен содержать результат соответствующего преобразования.

(20260110-203009) Пожалуйста, создай feature-ветку `feature/20260107-203303-backend_demo`, и переключись на неё.
После этого внеси изменения в код с учётом моих замечаний выше.
Commit не выполняй до моего утверждения изменений.


---

**Cursor**

Изучаю функции конвертации SQL/JSQL и создаю feature-ветку:

Отлично, ветка создана. Теперь начинаю создавать структуру backend demo:

Создаю структуру через write файлов:

```python
"""UMA Backend Demo Application."""

```

```python
"""API routers."""

```

```python
"""Pydantic models for requests and responses."""

```

Начинаю с переименования функций UMA API:

```python
"""High-level API functions for UMA."""

from collections.abc import Mapping
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.namespace_config import get_default_namespace
from namerec.uma.core.namespace_config import get_namespace_config
from namerec.uma.core.namespace_config import set_namespace_configs
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.registry import EntityRegistry

# Global objects (initialized at startup)
_registry: EntityRegistry | None = None


def uma_initialize(
    namespace_configs: Mapping[str, NamespaceConfig],
    default_handler: type[EntityHandler] | None = None,
) -> EntityRegistry:
    """
    Initialize UMA with namespace configurations.

    Args:
        namespace_configs: Mapping {namespace: NamespaceConfig}
        default_handler: Default handler class for unregistered entities

    Returns:
        Initialized EntityRegistry

    Raises:
        ValueError: If namespace_configs is empty

    Behaviour:
    - If single namespace: it becomes default
    - If multiple namespaces: no default, explicit namespace required

    Example:
        # Single namespace (typical case)
        uma_initialize({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Multiple namespaces
        uma_initialize({
            'db1': NamespaceConfig(...),
            'db2': NamespaceConfig(...),
        })
    """
    if not namespace_configs:
        msg = 'At least one namespace configuration required'
        raise ValueError(msg)

    # Determine default namespace
    if len(namespace_configs) == 1:
        default_ns = next(iter(namespace_configs.keys()))
    else:
        default_ns = None  # Explicit namespace required

    # Store configs
    set_namespace_configs(namespace_configs, default_ns)

    # Initialize registry
    global _registry  # noqa: PLW0603
    _registry = EntityRegistry(default_handler or DefaultEntityHandler)

    return _registry


# Legacy alias for backward compatibility
initialize_uma = uma_initialize


def get_registry() -> EntityRegistry:
    """
    Get initialized registry.

    Returns:
        EntityRegistry instance

    Raises:
        RuntimeError: If UMA not initialized
    """
    if _registry is None:
        msg = 'UMA not initialized. Call initialize_uma() first.'
        raise RuntimeError(msg)
    return _registry


def _create_context(
    namespace: str | None = None,
    user_context: Any = None,
    **extra: Any,
) -> UMAContext:
    """
    Create context for operation.

    Args:
        namespace: Namespace name (None = use default)
        user_context: User context for access control
        **extra: Additional context fields

    Returns:
        UMAContext instance

    Raises:
        RuntimeError: If UMA not initialized
        ValueError: If namespace not found or default not set
    """
    # Get namespace config (resolves default if namespace is None)
    config = get_namespace_config(namespace)

    # Determine actual namespace name
    actual_namespace = namespace or get_default_namespace()
    if actual_namespace is None:
        msg = 'Cannot determine namespace'
        raise RuntimeError(msg)

    return UMAContext(
        engine=config.engine,
        metadata_provider=config.metadata_provider,
        namespace=actual_namespace,
        user_context=user_context,
        extra=extra,
    )


def _check_access(
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """
    Check access and raise exception if access denied.

    Args:
        entity_name: Entity name
        operation: Operation name
        context: Execution context

    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)

    # Check if metadata provider has can() method
    if hasattr(context.metadata_provider, 'can'):
        if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
            raise UMAAccessDeniedError(entity_name, operation.value)


# ========== API Functions ==========


async def uma_read(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """
    Read a record by id.

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        id_value: Record ID
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        Record data as dictionary

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If record not found
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.READ, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.read(entity, id_value, context)


async def uma_save(
    entity_name: str,
    data: dict,
    user_context: Any = None,
    namespace: str | None = None,
) -> Any:
    """
    Save a record (create if id=None, otherwise update).

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        data: Record data
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        ID of saved record

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If record not found (for update)
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Determine operation (create or update)
    # Check if record has ID to determine if it's create or update
    has_id = any(data.get(key) is not None for key in ['id', 'ID'])
    operation = Operation.UPDATE if has_id else Operation.CREATE

    # Check access
    _check_access(str(entity), operation, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.save(entity, data, context)


async def uma_delete(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> bool:
    """
    Delete a record by id.

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        id_value: Record ID
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        True if deleted

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If record not found
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.DELETE, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.delete(entity, id_value, context)


async def uma_meta(
    entity_name: str,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """
    Get entity metadata.

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        Metadata dictionary

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If entity not found
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.META, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.meta(entity, context)


async def uma_entity_list(
    user_context: Any = None,
    namespace: str | None = None,
) -> list[str]:
    """
    Get list of all available entities.

    Args:
        user_context: User context for access control
        namespace: Optional namespace filter (None = use default)

    Returns:
        List of entity names (with namespace prefix if not default)

    Raises:
        UMAAccessDeniedError: If access denied
        RuntimeError: If UMA not initialized
        ValueError: If namespace not found
    """
    # Create context for namespace
    context = _create_context(namespace, user_context)

    # Check access (empty entity_name means "list entities" operation)
    _check_access('', Operation.META, context)

    # Get list from MetadataProvider
    entities = await context.metadata_provider.list_entities(
        context.namespace,
        context,
    )

    # Format with namespace prefix (if not default)
    default_ns = get_default_namespace()
    if context.namespace != default_ns:
        return [f'{context.namespace}:{e}' for e in entities]

    return entities


async def uma_select(
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """
    Execute JSQL query.

    Args:
        jsql: JSQL query dictionary (must contain 'from' field)
        params: Query parameters
        user_context: User context for access control
        namespace: Optional namespace

    Returns:
        Dictionary with 'meta' and 'data' keys

    Raises:
        UMAAccessDeniedError: If access denied
        ValueError: If JSQL invalid
        RuntimeError: If UMA not initialized
        JSQLSyntaxError: If JSQL syntax is invalid
        JSQLExecutionError: If query execution fails
    """
    from namerec.uma.jsql.executor import JSQLExecutor

    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        msg = "JSQL must contain 'from' field"
        raise ValueError(msg)

    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.SELECT, context)

    # Execute JSQL query
    executor = JSQLExecutor(context)
    result = await executor.execute(jsql, params)

    return result.to_dict()

```

```python
"""High-level API functions for UMA."""

from collections.abc import Mapping
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.namespace_config import get_default_namespace
from namerec.uma.core.namespace_config import get_namespace_config
from namerec.uma.core.namespace_config import set_namespace_configs
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.registry import EntityRegistry

# Global objects (initialized at startup)
_registry: EntityRegistry | None = None


def uma_initialize(
    namespace_configs: Mapping[str, NamespaceConfig],
    default_handler: type[EntityHandler] | None = None,
) -> EntityRegistry:
    """
    Initialize UMA with namespace configurations.

    Args:
        namespace_configs: Mapping {namespace: NamespaceConfig}
        default_handler: Default handler class for unregistered entities

    Returns:
        Initialized EntityRegistry

    Raises:
        ValueError: If namespace_configs is empty

    Behaviour:
    - If single namespace: it becomes default
    - If multiple namespaces: no default, explicit namespace required

    Example:
        # Single namespace (typical case)
        uma_initialize({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Multiple namespaces
        uma_initialize({
            'db1': NamespaceConfig(...),
            'db2': NamespaceConfig(...),
        })
    """
    if not namespace_configs:
        msg = 'At least one namespace configuration required'
        raise ValueError(msg)

    # Determine default namespace
    if len(namespace_configs) == 1:
        default_ns = next(iter(namespace_configs.keys()))
    else:
        default_ns = None  # Explicit namespace required

    # Store configs
    set_namespace_configs(namespace_configs, default_ns)

    # Initialize registry
    global _registry  # noqa: PLW0603
    _registry = EntityRegistry(default_handler or DefaultEntityHandler)

    return _registry


# Legacy alias for backward compatibility
initialize_uma = uma_initialize


def get_registry() -> EntityRegistry:
    """
    Get initialized registry.

    Returns:
        EntityRegistry instance

    Raises:
        RuntimeError: If UMA not initialized
    """
    if _registry is None:
        msg = 'UMA not initialized. Call initialize_uma() first.'
        raise RuntimeError(msg)
    return _registry


def _create_context(
    namespace: str | None = None,
    user_context: Any = None,
    **extra: Any,
) -> UMAContext:
    """
    Create context for operation.

    Args:
        namespace: Namespace name (None = use default)
        user_context: User context for access control
        **extra: Additional context fields

    Returns:
        UMAContext instance

    Raises:
        RuntimeError: If UMA not initialized
        ValueError: If namespace not found or default not set
    """
    # Get namespace config (resolves default if namespace is None)
    config = get_namespace_config(namespace)

    # Determine actual namespace name
    actual_namespace = namespace or get_default_namespace()
    if actual_namespace is None:
        msg = 'Cannot determine namespace'
        raise RuntimeError(msg)

    return UMAContext(
        engine=config.engine,
        metadata_provider=config.metadata_provider,
        namespace=actual_namespace,
        user_context=user_context,
        extra=extra,
    )


def _check_access(
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """
    Check access and raise exception if access denied.

    Args:
        entity_name: Entity name
        operation: Operation name
        context: Execution context

    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)

    # Check if metadata provider has can() method
    if hasattr(context.metadata_provider, 'can'):
        if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
            raise UMAAccessDeniedError(entity_name, operation.value)


# ========== API Functions ==========


async def uma_read(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """
    Read a record by id.

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        id_value: Record ID
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        Record data as dictionary

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If record not found
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.READ, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.read(entity, id_value, context)


async def uma_save(
    entity_name: str,
    data: dict,
    user_context: Any = None,
    namespace: str | None = None,
) -> Any:
    """
    Save a record (create if id=None, otherwise update).

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        data: Record data
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        ID of saved record

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If record not found (for update)
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Determine operation (create or update)
    # Check if record has ID to determine if it's create or update
    has_id = any(data.get(key) is not None for key in ['id', 'ID'])
    operation = Operation.UPDATE if has_id else Operation.CREATE

    # Check access
    _check_access(str(entity), operation, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.save(entity, data, context)


async def uma_delete(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> bool:
    """
    Delete a record by id.

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        id_value: Record ID
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        True if deleted

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If record not found
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.DELETE, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.delete(entity, id_value, context)


async def uma_entity_details(
    entity_name: str,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """
    Get entity metadata.

    Args:
        entity_name: Entity name (can include namespace, e.g., 'virtual:users')
        user_context: User context for access control
        namespace: Optional namespace (if not in entity_name)

    Returns:
        Metadata dictionary

    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If entity not found
        RuntimeError: If UMA not initialized
    """
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.META, context)

    # Get handler and execute
    handler = await get_registry().get_handler(entity, context)
    return await handler.meta(entity, context)


async def uma_entity_list(
    user_context: Any = None,
    namespace: str | None = None,
) -> list[str]:
    """
    Get list of all available entities.

    Args:
        user_context: User context for access control
        namespace: Optional namespace filter (None = use default)

    Returns:
        List of entity names (with namespace prefix if not default)

    Raises:
        UMAAccessDeniedError: If access denied
        RuntimeError: If UMA not initialized
        ValueError: If namespace not found
    """
    # Create context for namespace
    context = _create_context(namespace, user_context)

    # Check access (empty entity_name means "list entities" operation)
    _check_access('', Operation.META, context)

    # Get list from MetadataProvider
    entities = await context.metadata_provider.list_entities(
        context.namespace,
        context,
    )

    # Format with namespace prefix (if not default)
    default_ns = get_default_namespace()
    if context.namespace != default_ns:
        return [f'{context.namespace}:{e}' for e in entities]

    return entities


async def uma_select(
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """
    Execute JSQL query.

    Args:
        jsql: JSQL query dictionary (must contain 'from' field)
        params: Query parameters
        user_context: User context for access control
        namespace: Optional namespace

    Returns:
        Dictionary with 'meta' and 'data' keys

    Raises:
        UMAAccessDeniedError: If access denied
        ValueError: If JSQL invalid
        RuntimeError: If UMA not initialized
        JSQLSyntaxError: If JSQL syntax is invalid
        JSQLExecutionError: If query execution fails
    """
    from namerec.uma.jsql.executor import JSQLExecutor

    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        msg = "JSQL must contain 'from' field"
        raise ValueError(msg)

    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = _create_context(entity.namespace, user_context)

    # Check access
    _check_access(str(entity), Operation.SELECT, context)

    # Execute JSQL query
    executor = JSQLExecutor(context)
    result = await executor.execute(jsql, params)

    return result.to_dict()

```

```python
"""
UMA - Unified Model Access

A Python package for unified database access via JSON-SQL queries.
"""

from namerec.uma.api import get_registry
from namerec.uma.api import initialize_uma
from namerec.uma.api import uma_delete
from namerec.uma.api import uma_initialize
from namerec.uma.api import uma_entity_details
from namerec.uma.api import uma_entity_list
from namerec.uma.api import uma_read
from namerec.uma.api import uma_save
from namerec.uma.api import uma_select
from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.exceptions import UMAError
from namerec.uma.core.exceptions import UMANotFoundError
from namerec.uma.core.exceptions import UMANotImplementedError
from namerec.uma.core.exceptions import UMAValidationError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import MetadataProvider
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import copy_field_meta
from namerec.uma.core.utils import form_entity_name
from namerec.uma.core.utils import is_virtual_view
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.handlers.virtual import VirtualViewHandler
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.metadata import DefaultMetadataProvider
from namerec.uma.registry import EntityRegistry
from namerec.uma.registry import get_global_registry
from namerec.uma.registry import init_global_registry

__version__ = '2.0'

__all__ = [
    # Core types
    'EntityName',
    'Operation',
    'EntityHandler',
    'MetadataProvider',
    'UMAContext',
    'NamespaceConfig',
    # Exceptions
    'UMAError',
    'UMAAccessDeniedError',
    'UMANotFoundError',
    'UMANotImplementedError',
    'UMAValidationError',
    'JSQLSyntaxError',
    'JSQLExecutionError',
    # Utils
    'parse_entity_name',
    'form_entity_name',
    'copy_field_meta',
    'is_virtual_view',
    # Handlers
    'DefaultEntityHandler',
    'VirtualViewHandler',
    # Registry
    'EntityRegistry',
    'init_global_registry',
    'get_global_registry',
    # Metadata
    'DefaultMetadataProvider',
    # API
    'uma_initialize',
    'initialize_uma',  # Legacy alias
    'get_registry',
    'uma_select',
    'uma_read',
    'uma_save',
    'uma_delete',
    'uma_meta',
    'uma_list_entities',
]

```

```python
"""
UMA - Unified Model Access

A Python package for unified database access via JSON-SQL queries.
"""

from namerec.uma.api import get_registry
from namerec.uma.api import initialize_uma
from namerec.uma.api import uma_delete
from namerec.uma.api import uma_initialize
from namerec.uma.api import uma_entity_details
from namerec.uma.api import uma_entity_list
from namerec.uma.api import uma_read
from namerec.uma.api import uma_save
from namerec.uma.api import uma_select
from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.exceptions import UMAError
from namerec.uma.core.exceptions import UMANotFoundError
from namerec.uma.core.exceptions import UMANotImplementedError
from namerec.uma.core.exceptions import UMAValidationError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import MetadataProvider
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import copy_field_meta
from namerec.uma.core.utils import form_entity_name
from namerec.uma.core.utils import is_virtual_view
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.handlers.virtual import VirtualViewHandler
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.metadata import DefaultMetadataProvider
from namerec.uma.registry import EntityRegistry
from namerec.uma.registry import get_global_registry
from namerec.uma.registry import init_global_registry

__version__ = '2.0'

__all__ = [
    # Core types
    'EntityName',
    'Operation',
    'EntityHandler',
    'MetadataProvider',
    'UMAContext',
    'NamespaceConfig',
    # Exceptions
    'UMAError',
    'UMAAccessDeniedError',
    'UMANotFoundError',
    'UMANotImplementedError',
    'UMAValidationError',
    'JSQLSyntaxError',
    'JSQLExecutionError',
    # Utils
    'parse_entity_name',
    'form_entity_name',
    'copy_field_meta',
    'is_virtual_view',
    # Handlers
    'DefaultEntityHandler',
    'VirtualViewHandler',
    # Registry
    'EntityRegistry',
    'init_global_registry',
    'get_global_registry',
    # Metadata
    'DefaultMetadataProvider',
    # API
    'uma_initialize',
    'initialize_uma',  # Legacy alias
    'get_registry',
    'uma_select',
    'uma_read',
    'uma_save',
    'uma_delete',
    'uma_entity_details',
    'uma_entity_list',
]

```

Теперь обновляю примеры и тесты, которые используют старые имена:

```python
"""
API usage example for UMA.

This example demonstrates high-level API functions:
1. initialize_uma - Initialize UMA
2. uma_list_entities - List all entities
3. uma_meta - Get entity metadata
4. uma_read - Read record
5. uma_save - Save record
6. uma_delete - Delete record
"""

import asyncio

from sqlalchemy import Column
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Numeric
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import func
from sqlalchemy import select
from sqlalchemy.ext.asyncio import create_async_engine

from namerec.uma import DefaultMetadataProvider
from namerec.uma import Operation
from namerec.uma import UMAAccessDeniedError
from namerec.uma import UMAContext
from namerec.uma import VirtualViewHandler
from namerec.uma import copy_field_meta
from namerec.uma import get_registry
from namerec.uma import initialize_uma
from namerec.uma import uma_delete
from namerec.uma import uma_entity_details
from namerec.uma import uma_entity_list
from namerec.uma import uma_read
from namerec.uma import uma_save


# ========== Custom Metadata Provider with Access Control ==========


class AccessControlMetadataProvider(DefaultMetadataProvider):
    """Metadata provider with access control."""

    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        """
        Check access based on user role.

        Args:
            entity_name: Entity name (empty for list operation)
            operation: Operation to check
            context: Execution context with user_context

        Returns:
            True if access allowed
        """
        user = context.user_context

        # Special case: list entities
        if entity_name == '' and (operation == Operation.META or operation == 'meta'):
            return user is not None  # Only authenticated users

        # Check if user authenticated
        if not user:
            return False

        user_role = getattr(user, 'role', 'guest')

        # Admin can do everything
        if user_role == 'admin':
            return True

        # Regular user: read/list/meta only
        if user_role == 'user':
            return operation in (Operation.READ, Operation.LIST, Operation.META, 'read', 'list', 'meta')

        # Guest: no access
        return False


# ========== Define Schema ==========

metadata = MetaData()

users_table = Table(
    'users',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(100), nullable=False),
    Column('email', String(100), nullable=False),
)

orders_table = Table(
    'orders',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('user_id', Integer, ForeignKey('users.id'), nullable=False),
    Column('total', Numeric(10, 2), nullable=False),
)


# ========== Virtual View ==========


class UserSummaryView(VirtualViewHandler):
    """Virtual view: user orders summary."""

    description = 'Summary of user orders'

    @classmethod
    async def select(cls, entity_name, params, context):  # noqa: ANN001, ANN201
        """Build SELECT for user summary."""
        users = context.metadata.tables['users']
        orders = context.metadata.tables['orders']

        query = (
            select(
                users.c.id.label('user_id'),
                users.c.name,
                func.count(orders.c.id).label('order_count'),
                func.coalesce(func.sum(orders.c.total), 0).label('total_spent'),
            )
            .select_from(users.outerjoin(orders, users.c.id == orders.c.user_id))
            .group_by(users.c.id, users.c.name)
        )

        # Apply filters from params
        if 'user_id' in params:
            query = query.where(users.c.id == params['user_id'])

        return query

    @classmethod
    async def meta(cls, entity_name, context):  # noqa: ANN001, ANN201
        """Return metadata for virtual view."""
        columns_metadata = [
            await copy_field_meta('users', 'id', context, {'name': 'user_id'}),
            await copy_field_meta('users', 'name', context),
            {'name': 'order_count', 'type': 'integer', 'description': 'Number of orders'},
            {'name': 'total_spent', 'type': 'numeric', 'description': 'Total order amount'},
        ]

        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': columns_metadata,
        }


# ========== User Context Classes ==========


class User:
    """User for access control."""

    def __init__(self, user_id: int, role: str) -> None:
        """Initialize user."""
        self.id = user_id
        self.role = role


# ========== Main ==========


async def main() -> None:
    """Run API example."""
    # Create async engine
    engine = create_async_engine('sqlite+aiosqlite:///:memory:', echo=False)

    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)

    # ========== Initialize UMA ==========
    print('\n=== Initializing UMA ===')

    metadata_provider = AccessControlMetadataProvider()
    registry = initialize_uma(
        engine=engine,
        metadata=metadata,
        metadata_provider=metadata_provider,
    )

    # Register virtual view
    registry.register('user_summary', UserSummaryView)

    print('✓ UMA initialized')
    print('✓ Virtual view registered')

    # ========== Example 1: List entities as admin ==========
    print('\n=== Example 1: List entities (admin) ===')

    admin_user = User(user_id=1, role='admin')

    try:
        entities = await uma_list_entities(user_context=admin_user)
        print(f'✓ Available entities: {entities}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 2: Get metadata ==========
    print('\n=== Example 2: Get metadata (admin) ===')

    try:
        user_meta = await uma_meta('users', user_context=admin_user)
        print(f"✓ Users table columns: {[col['name'] for col in user_meta['columns']]}")
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 3: Create records ==========
    print('\n=== Example 3: Create records (admin) ===')

    try:
        # Create user
        user_id = await uma_save(
            'users',
            {'name': 'John Doe', 'email': 'john@example.com'},
            user_context=admin_user,
        )
        print(f'✓ Created user with id={user_id}')

        # Create another user
        user_id2 = await uma_save(
            'users',
            {'name': 'Jane Smith', 'email': 'jane@example.com'},
            user_context=admin_user,
        )
        print(f'✓ Created user with id={user_id2}')

        # Create order
        order_id = await uma_save(
            'orders',
            {'user_id': user_id, 'total': 100.50},
            user_context=admin_user,
        )
        print(f'✓ Created order with id={order_id}')

    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 4: Read record ==========
    print('\n=== Example 4: Read record (admin) ===')

    try:
        user_data = await uma_read('users', user_id, user_context=admin_user)
        print(f'✓ User data: {user_data}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 5: Update record ==========
    print('\n=== Example 5: Update record (admin) ===')

    try:
        await uma_save(
            'users',
            {'id': user_id, 'name': 'John Smith', 'email': 'john.smith@example.com'},
            user_context=admin_user,
        )
        print('✓ User updated')

        # Verify update
        updated_user = await uma_read('users', user_id, user_context=admin_user)
        print(f"✓ Updated name: {updated_user['name']}")
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 6: Regular user - read allowed ==========
    print('\n=== Example 6: Regular user - read allowed ===')

    regular_user = User(user_id=2, role='user')

    try:
        user_data = await uma_read('users', user_id, user_context=regular_user)
        print(f'✓ User can read: {user_data["name"]}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 7: Regular user - write denied ==========
    print('\n=== Example 7: Regular user - write denied ===')

    try:
        await uma_save(
            'users',
            {'id': user_id, 'name': 'Hacker', 'email': 'hacker@example.com'},
            user_context=regular_user,
        )
        print('✗ User should not be able to write!')
    except UMAAccessDeniedError:
        print('✓ Access correctly denied for write operation')

    # ========== Example 8: Regular user - delete denied ==========
    print('\n=== Example 8: Regular user - delete denied ===')

    try:
        await uma_delete('users', user_id, user_context=regular_user)
        print('✗ User should not be able to delete!')
    except UMAAccessDeniedError:
        print('✓ Access correctly denied for delete operation')

    # ========== Example 9: Guest - all denied ==========
    print('\n=== Example 9: Guest - all denied ===')

    guest_user = User(user_id=0, role='guest')

    try:
        await uma_read('users', user_id, user_context=guest_user)
        print('✗ Guest should not have access!')
    except UMAAccessDeniedError:
        print('✓ Access correctly denied for guest')

    # ========== Example 10: Delete record (admin) ==========
    print('\n=== Example 10: Delete record (admin) ===')

    try:
        deleted = await uma_delete('users', user_id2, user_context=admin_user)
        print(f'✓ User deleted: {deleted}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Cleanup ==========
    await engine.dispose()
    print('\n=== Example completed ===')


if __name__ == '__main__':
    asyncio.run(main())

```

```python
"""
API usage example for UMA.

This example demonstrates high-level API functions:
1. initialize_uma - Initialize UMA
2. uma_list_entities - List all entities
3. uma_meta - Get entity metadata
4. uma_read - Read record
5. uma_save - Save record
6. uma_delete - Delete record
"""

import asyncio

from sqlalchemy import Column
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import Numeric
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import func
from sqlalchemy import select
from sqlalchemy.ext.asyncio import create_async_engine

from namerec.uma import DefaultMetadataProvider
from namerec.uma import Operation
from namerec.uma import UMAAccessDeniedError
from namerec.uma import UMAContext
from namerec.uma import VirtualViewHandler
from namerec.uma import copy_field_meta
from namerec.uma import get_registry
from namerec.uma import initialize_uma
from namerec.uma import uma_delete
from namerec.uma import uma_entity_details
from namerec.uma import uma_entity_list
from namerec.uma import uma_read
from namerec.uma import uma_save


# ========== Custom Metadata Provider with Access Control ==========


class AccessControlMetadataProvider(DefaultMetadataProvider):
    """Metadata provider with access control."""

    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        """
        Check access based on user role.

        Args:
            entity_name: Entity name (empty for list operation)
            operation: Operation to check
            context: Execution context with user_context

        Returns:
            True if access allowed
        """
        user = context.user_context

        # Special case: list entities
        if entity_name == '' and (operation == Operation.META or operation == 'meta'):
            return user is not None  # Only authenticated users

        # Check if user authenticated
        if not user:
            return False

        user_role = getattr(user, 'role', 'guest')

        # Admin can do everything
        if user_role == 'admin':
            return True

        # Regular user: read/list/meta only
        if user_role == 'user':
            return operation in (Operation.READ, Operation.LIST, Operation.META, 'read', 'list', 'meta')

        # Guest: no access
        return False


# ========== Define Schema ==========

metadata = MetaData()

users_table = Table(
    'users',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(100), nullable=False),
    Column('email', String(100), nullable=False),
)

orders_table = Table(
    'orders',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('user_id', Integer, ForeignKey('users.id'), nullable=False),
    Column('total', Numeric(10, 2), nullable=False),
)


# ========== Virtual View ==========


class UserSummaryView(VirtualViewHandler):
    """Virtual view: user orders summary."""

    description = 'Summary of user orders'

    @classmethod
    async def select(cls, entity_name, params, context):  # noqa: ANN001, ANN201
        """Build SELECT for user summary."""
        users = context.metadata.tables['users']
        orders = context.metadata.tables['orders']

        query = (
            select(
                users.c.id.label('user_id'),
                users.c.name,
                func.count(orders.c.id).label('order_count'),
                func.coalesce(func.sum(orders.c.total), 0).label('total_spent'),
            )
            .select_from(users.outerjoin(orders, users.c.id == orders.c.user_id))
            .group_by(users.c.id, users.c.name)
        )

        # Apply filters from params
        if 'user_id' in params:
            query = query.where(users.c.id == params['user_id'])

        return query

    @classmethod
    async def meta(cls, entity_name, context):  # noqa: ANN001, ANN201
        """Return metadata for virtual view."""
        columns_metadata = [
            await copy_field_meta('users', 'id', context, {'name': 'user_id'}),
            await copy_field_meta('users', 'name', context),
            {'name': 'order_count', 'type': 'integer', 'description': 'Number of orders'},
            {'name': 'total_spent', 'type': 'numeric', 'description': 'Total order amount'},
        ]

        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': columns_metadata,
        }


# ========== User Context Classes ==========


class User:
    """User for access control."""

    def __init__(self, user_id: int, role: str) -> None:
        """Initialize user."""
        self.id = user_id
        self.role = role


# ========== Main ==========


async def main() -> None:
    """Run API example."""
    # Create async engine
    engine = create_async_engine('sqlite+aiosqlite:///:memory:', echo=False)

    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)

    # ========== Initialize UMA ==========
    print('\n=== Initializing UMA ===')

    metadata_provider = AccessControlMetadataProvider()
    registry = initialize_uma(
        engine=engine,
        metadata=metadata,
        metadata_provider=metadata_provider,
    )

    # Register virtual view
    registry.register('user_summary', UserSummaryView)

    print('✓ UMA initialized')
    print('✓ Virtual view registered')

    # ========== Example 1: List entities as admin ==========
    print('\n=== Example 1: List entities (admin) ===')

    admin_user = User(user_id=1, role='admin')

    try:
        entities = await uma_entity_list(user_context=admin_user)
        print(f'✓ Available entities: {entities}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 2: Get metadata ==========
    print('\n=== Example 2: Get metadata (admin) ===')

    try:
        user_meta = await uma_entity_details('users', user_context=admin_user)
        print(f"✓ Users table columns: {[col['name'] for col in user_meta['columns']]}")
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 3: Create records ==========
    print('\n=== Example 3: Create records (admin) ===')

    try:
        # Create user
        user_id = await uma_save(
            'users',
            {'name': 'John Doe', 'email': 'john@example.com'},
            user_context=admin_user,
        )
        print(f'✓ Created user with id={user_id}')

        # Create another user
        user_id2 = await uma_save(
            'users',
            {'name': 'Jane Smith', 'email': 'jane@example.com'},
            user_context=admin_user,
        )
        print(f'✓ Created user with id={user_id2}')

        # Create order
        order_id = await uma_save(
            'orders',
            {'user_id': user_id, 'total': 100.50},
            user_context=admin_user,
        )
        print(f'✓ Created order with id={order_id}')

    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 4: Read record ==========
    print('\n=== Example 4: Read record (admin) ===')

    try:
        user_data = await uma_read('users', user_id, user_context=admin_user)
        print(f'✓ User data: {user_data}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 5: Update record ==========
    print('\n=== Example 5: Update record (admin) ===')

    try:
        await uma_save(
            'users',
            {'id': user_id, 'name': 'John Smith', 'email': 'john.smith@example.com'},
            user_context=admin_user,
        )
        print('✓ User updated')

        # Verify update
        updated_user = await uma_read('users', user_id, user_context=admin_user)
        print(f"✓ Updated name: {updated_user['name']}")
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 6: Regular user - read allowed ==========
    print('\n=== Example 6: Regular user - read allowed ===')

    regular_user = User(user_id=2, role='user')

    try:
        user_data = await uma_read('users', user_id, user_context=regular_user)
        print(f'✓ User can read: {user_data["name"]}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Example 7: Regular user - write denied ==========
    print('\n=== Example 7: Regular user - write denied ===')

    try:
        await uma_save(
            'users',
            {'id': user_id, 'name': 'Hacker', 'email': 'hacker@example.com'},
            user_context=regular_user,
        )
        print('✗ User should not be able to write!')
    except UMAAccessDeniedError:
        print('✓ Access correctly denied for write operation')

    # ========== Example 8: Regular user - delete denied ==========
    print('\n=== Example 8: Regular user - delete denied ===')

    try:
        await uma_delete('users', user_id, user_context=regular_user)
        print('✗ User should not be able to delete!')
    except UMAAccessDeniedError:
        print('✓ Access correctly denied for delete operation')

    # ========== Example 9: Guest - all denied ==========
    print('\n=== Example 9: Guest - all denied ===')

    guest_user = User(user_id=0, role='guest')

    try:
        await uma_read('users', user_id, user_context=guest_user)
        print('✗ Guest should not have access!')
    except UMAAccessDeniedError:
        print('✓ Access correctly denied for guest')

    # ========== Example 10: Delete record (admin) ==========
    print('\n=== Example 10: Delete record (admin) ===')

    try:
        deleted = await uma_delete('users', user_id2, user_context=admin_user)
        print(f'✓ User deleted: {deleted}')
    except UMAAccessDeniedError as e:
        print(f'✗ Access denied: {e}')

    # ========== Cleanup ==========
    await engine.dispose()
    print('\n=== Example completed ===')


if __name__ == '__main__':
    asyncio.run(main())

```

```python
from namerec.uma import uma_delete
from namerec.uma import uma_entity_details
from namerec.uma import uma_entity_list
from namerec.uma import uma_read
from namerec.uma import uma_save
from namerec.uma import uma_select
```

```python
"""Tests for UMA API functions."""

import pytest

from namerec.uma import DefaultMetadataProvider
from namerec.uma import NamespaceConfig
from namerec.uma import UMAAccessDeniedError
from namerec.uma import UMAContext
from namerec.uma import UMANotFoundError
from namerec.uma import uma_delete
from namerec.uma import uma_entity_details
from namerec.uma import uma_entity_list
from namerec.uma import uma_initialize
from namerec.uma import uma_read
from namerec.uma import uma_save


async def _initialize_test_uma(engine, metadata):  # noqa: ANN001, ANN202
    """Helper to initialize UMA for tests."""
    # Create tables first
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)
    
    # Initialize UMA
    metadata_provider = DefaultMetadataProvider()
    uma_initialize({
        'test': NamespaceConfig(
            engine=engine,
            metadata_provider=metadata_provider,
        ),
    })
    
    # Preload metadata
    await metadata_provider.preload(engine, namespace='test')


@pytest.mark.asyncio
async def test_initialize_uma(engine, metadata) -> None:  # noqa: ANN001
    """Test UMA initialization."""
    await _initialize_test_uma(engine, metadata)


@pytest.mark.asyncio
async def test_uma_list_entities(engine, metadata) -> None:  # noqa: ANN001
    """Test listing entities."""
    await _initialize_test_uma(engine, metadata)

    entities = await uma_list_entities()
    assert 'users' in entities


@pytest.mark.asyncio
async def test_uma_meta(engine, metadata) -> None:  # noqa: ANN001
    """Test getting entity metadata."""
    await _initialize_test_uma(engine, metadata)

    meta = await uma_meta('users')
    assert meta['name'] == 'test:users'
    assert len(meta['columns']) == 3


@pytest.mark.asyncio
async def test_uma_save_and_read(engine, metadata) -> None:  # noqa: ANN001
    """Test creating and reading a record."""
    await _initialize_test_uma(engine, metadata)

    # Create
    user_id = await uma_save('users', {'name': 'Test User', 'email': 'test@example.com'})
    assert user_id is not None

    # Read
    user = await uma_read('users', user_id)
    assert user['name'] == 'Test User'
    assert user['email'] == 'test@example.com'


@pytest.mark.asyncio
async def test_uma_update(engine, metadata) -> None:  # noqa: ANN001
    """Test updating a record."""
    await _initialize_test_uma(engine, metadata)

    # Create
    user_id = await uma_save('users', {'name': 'Test User', 'email': 'test@example.com'})

    # Update
    await uma_save('users', {'id': user_id, 'name': 'Updated User', 'email': 'updated@example.com'})

    # Verify
    user = await uma_read('users', user_id)
    assert user['name'] == 'Updated User'


@pytest.mark.asyncio
async def test_uma_delete(engine, metadata) -> None:  # noqa: ANN001
    """Test deleting a record."""
    await _initialize_test_uma(engine, metadata)

    # Create
    user_id = await uma_save('users', {'name': 'Test User', 'email': 'test@example.com'})

    # Delete
    deleted = await uma_delete('users', user_id)
    assert deleted is True

    # Verify deletion
    with pytest.raises(UMANotFoundError):
        await uma_read('users', user_id)


@pytest.mark.asyncio
async def test_uma_not_initialized() -> None:
    """Test API functions raise error when UMA not initialized."""
    # Reset by importing fresh module would be needed, but for now just test with initialized
    # In real scenario, this would require module reloading
    pass

```

```python
"""Tests for UMA API functions."""

import pytest

from namerec.uma import DefaultMetadataProvider
from namerec.uma import NamespaceConfig
from namerec.uma import UMAAccessDeniedError
from namerec.uma import UMAContext
from namerec.uma import UMANotFoundError
from namerec.uma import uma_delete
from namerec.uma import uma_entity_details
from namerec.uma import uma_entity_list
from namerec.uma import uma_initialize
from namerec.uma import uma_read
from namerec.uma import uma_save


async def _initialize_test_uma(engine, metadata):  # noqa: ANN001, ANN202
    """Helper to initialize UMA for tests."""
    # Create tables first
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)
    
    # Initialize UMA
    metadata_provider = DefaultMetadataProvider()
    uma_initialize({
        'test': NamespaceConfig(
            engine=engine,
            metadata_provider=metadata_provider,
        ),
    })
    
    # Preload metadata
    await metadata_provider.preload(engine, namespace='test')


@pytest.mark.asyncio
async def test_initialize_uma(engine, metadata) -> None:  # noqa: ANN001
    """Test UMA initialization."""
    await _initialize_test_uma(engine, metadata)


@pytest.mark.asyncio
async def test_uma_entity_list(engine, metadata) -> None:  # noqa: ANN001
    """Test listing entities."""
    await _initialize_test_uma(engine, metadata)

    entities = await uma_entity_list()
    assert 'users' in entities


@pytest.mark.asyncio
async def test_uma_entity_details(engine, metadata) -> None:  # noqa: ANN001
    """Test getting entity metadata."""
    await _initialize_test_uma(engine, metadata)

    meta = await uma_entity_details('users')
    assert meta['name'] == 'test:users'
    assert len(meta['columns']) == 3


@pytest.mark.asyncio
async def test_uma_save_and_read(engine, metadata) -> None:  # noqa: ANN001
    """Test creating and reading a record."""
    await _initialize_test_uma(engine, metadata)

    # Create
    user_id = await uma_save('users', {'name': 'Test User', 'email': 'test@example.com'})
    assert user_id is not None

    # Read
    user = await uma_read('users', user_id)
    assert user['name'] == 'Test User'
    assert user['email'] == 'test@example.com'


@pytest.mark.asyncio
async def test_uma_update(engine, metadata) -> None:  # noqa: ANN001
    """Test updating a record."""
    await _initialize_test_uma(engine, metadata)

    # Create
    user_id = await uma_save('users', {'name': 'Test User', 'email': 'test@example.com'})

    # Update
    await uma_save('users', {'id': user_id, 'name': 'Updated User', 'email': 'updated@example.com'})

    # Verify
    user = await uma_read('users', user_id)
    assert user['name'] == 'Updated User'


@pytest.mark.asyncio
async def test_uma_delete(engine, metadata) -> None:  # noqa: ANN001
    """Test deleting a record."""
    await _initialize_test_uma(engine, metadata)

    # Create
    user_id = await uma_save('users', {'name': 'Test User', 'email': 'test@example.com'})

    # Delete
    deleted = await uma_delete('users', user_id)
    assert deleted is True

    # Verify deletion
    with pytest.raises(UMANotFoundError):
        await uma_read('users', user_id)


@pytest.mark.asyncio
async def test_uma_not_initialized() -> None:
    """Test API functions raise error when UMA not initialized."""
    # Reset by importing fresh module would be needed, but for now just test with initialized
    # In real scenario, this would require module reloading
    pass

```

Теперь создаю файлы backend приложения. Начинаю с pyproject.toml:

```toml
[project]
name = "uma-backend-demo"
version = "0.1.0"
description = "FastAPI backend demo for UMA (Unified Model Access)"
requires-python = ">=3.11"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn[standard]>=0.24.0",
    "pydantic-settings>=2.0.0",
    "structlog>=23.2.0",
    "asyncpg>=0.29.0",
    "dependency-injector>=4.41.0",
    "namerec-uma @ git+https://github.com/aka-NameRec/uma2.git",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

```

```ignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
*.egg-info/
dist/
build/

# Virtual environments
.venv/
venv/
ENV/
env/

# Environment variables
.env

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

```

Создаю .env.example через другой путь и config.py:

```python
"""Application configuration."""

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    database_url: str  # Required
    log_level: str = 'INFO'
    debug_mode: bool = False

    class Config:
        """Pydantic settings configuration."""

        env_file = '.env'
        case_sensitive = False


settings = Settings()

```

Создаю logging_config.py:

```python
"""Logging configuration with structlog and standard logging integration."""

import logging
import sys

import structlog


def configure_logging(log_level: str) -> None:
    """
    Configure structlog with standard logging integration.

    This ensures that:
    1. structlog is used for structured logging
    2. Standard logging (used by uvicorn, fastapi) uses the same format
    3. All logs are output to stdout with consistent formatting

    Args:
        log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
    """
    # Convert string level to logging constant
    numeric_level = getattr(logging, log_level.upper(), logging.INFO)

    # Configure standard logging first
    logging.basicConfig(
        format='%(message)s',
        stream=sys.stdout,
        level=numeric_level,
    )

    # Configure structlog
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,  # Merge context variables
            structlog.processors.add_log_level,  # Add log level
            structlog.processors.TimeStamper(fmt='iso', utc=False),  # ISO timestamp, local time
            structlog.stdlib.ProcessorFormatter.wrap_for_formatter,
        ],
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

    # Custom formatter for text output (ts log_level: message format)
    formatter = structlog.stdlib.ProcessorFormatter(
        processor=structlog.dev.ConsoleRenderer(),  # Text renderer
        foreign_pre_chain=[
            structlog.stdlib.add_log_level,
            structlog.processors.TimeStamper(fmt='iso', utc=False),
        ],
    )

    # Apply formatter to all loggers
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(formatter)

    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.handlers = [handler]
    root_logger.setLevel(numeric_level)

    # Configure uvicorn and fastapi loggers to use the same format
    for logger_name in ['uvicorn', 'uvicorn.access', 'uvicorn.error', 'fastapi']:
        logger = logging.getLogger(logger_name)
        logger.handlers = [handler]
        logger.setLevel(numeric_level)
        logger.propagate = False

```

Создаю exceptions.py и models:

```python
"""Exception handlers for UMA errors."""

import traceback
from typing import Any

from namerec.uma import JSQLExecutionError
from namerec.uma import JSQLSyntaxError
from namerec.uma import UMAAccessDeniedError
from namerec.uma import UMAError
from namerec.uma import UMANotFoundError
from namerec.uma import UMAValidationError

from src.models.responses import ErrorResponse


def handle_uma_exception(exc: Exception, debug_mode: bool) -> tuple[ErrorResponse, int]:
    """
    Convert UMA exception to ErrorResponse with HTTP status code.

    Args:
        exc: Exception to handle
        debug_mode: If True, include detailed traceback in response

    Returns:
        Tuple of (ErrorResponse, HTTP status code)
    """
    error_id = exc.__class__.__name__
    message = str(exc)
    details: dict[str, Any] = {}

    # Determine HTTP status code based on exception type
    if isinstance(exc, UMAAccessDeniedError):
        status_code = 403
        details = {
            'entity_name': getattr(exc, 'entity_name', None),
            'operation': getattr(exc, 'operation', None),
        }
    elif isinstance(exc, UMANotFoundError):
        status_code = 404
        details = {
            'entity_name': getattr(exc, 'entity_name', None),
        }
    elif isinstance(exc, (JSQLSyntaxError, UMAValidationError)):
        status_code = 400
        if isinstance(exc, JSQLSyntaxError):
            details = {
                'path': getattr(exc, 'path', None),
            }
        elif isinstance(exc, UMAValidationError):
            details = {
                'field_name': getattr(exc, 'field_name', None),
                'entity_name': getattr(exc, 'entity_name', None),
            }
    elif isinstance(exc, (JSQLExecutionError, UMAError)):
        status_code = 500
        if isinstance(exc, JSQLExecutionError):
            details = {
                'query': getattr(exc, 'query', None),
            }
    else:
        # Unknown exception
        status_code = 500
        details = {
            'exception_type': error_id,
        }

    # Add debug information if enabled
    if debug_mode:
        details['traceback'] = traceback.format_exc()
        details['debug_mode'] = True

    error_response = ErrorResponse(
        id=error_id,
        message=message,
        details=details,
    )

    return error_response, status_code

```

```python
"""Response models for API endpoints."""

from typing import Any

from pydantic import BaseModel


class ErrorResponse(BaseModel):
    """Unified error response format."""

    id: str  # Exception type (e.g., "UMAAccessDeniedError")
    message: str  # User-friendly error message
    details: dict[str, Any]  # Structured details for frontend processing


class EntityListResponse(BaseModel):
    """Response for entity list endpoint."""

    entities: list[str]


class DeleteResponse(BaseModel):
    """Response for delete endpoint."""

    deleted: bool


class SelectResponse(BaseModel):
    """Response for select endpoint."""

    meta: list[dict[str, Any]]
    data: list[dict[str, Any]]

```

Создаю requests.py:

```python
"""Request models for API endpoints."""

from typing import Any

from pydantic import BaseModel


class SelectRequest(BaseModel):
    """Request for JSQL select endpoint."""

    jsql: dict[str, Any]
    params: dict[str, Any] | None = None


class ReadRequest(BaseModel):
    """Request for read endpoint."""

    entity_name: str
    id: Any  # Can be int, str, UUID, etc.


class SaveRequest(BaseModel):
    """Request for save endpoint."""

    entity_name: str
    data: dict[str, Any]


class DeleteRequest(BaseModel):
    """Request for delete endpoint."""

    entity_name: str
    id: Any  # Can be int, str, UUID, etc.


class EntityListRequest(BaseModel):
    """Request for entity list endpoint."""

    namespace: str | None = None


class EntityDetailsRequest(BaseModel):
    """Request for entity details endpoint."""

    entity_name: str


class SQL2JSQLRequest(BaseModel):
    """Request for SQL to JSQL transformation."""

    data: str  # SQL query string
    dialect: str = 'generic'  # SQL dialect (generic, postgresql, mysql, sqlite, etc.)


class JSQL2SQLRequest(BaseModel):
    """Request for JSQL to SQL transformation."""

    data: dict[str, Any]  # JSQL query dictionary
    dialect: str = 'generic'  # SQL dialect (generic, postgresql, mysql, sqlite, etc.)

```

Создаю dependencies.py с DI container:

```python
"""Dependency injection container and providers."""

from dependency_injector import containers
from dependency_injector import providers
from sqlalchemy.ext.asyncio import create_async_engine

from namerec.uma import DefaultMetadataProvider
from namerec.uma import NamespaceConfig
from namerec.uma import uma_initialize


class Container(containers.DeclarativeContainer):
    """Application DI container."""

    # Configuration
    config = providers.Configuration()

    # Database engine (async)
    engine = providers.Singleton(
        create_async_engine,
        config.database_url,
        echo=False,
    )

    # UMA metadata provider
    metadata_provider = providers.Singleton(DefaultMetadataProvider)

    # UMA registry (initialized once at startup)
    registry = providers.Singleton(
        lambda engine, provider: uma_initialize(
            {
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=provider,
                ),
            }
        ),
        engine=engine,
        provider=metadata_provider,
    )

    # User context stub (for demo purposes)
    user_context = providers.Factory(lambda: {'user_id': 1, 'role': 'admin'})


# Global container instance
container = Container()


def get_user_context() -> dict:
    """
    FastAPI dependency to get user context.

    Returns:
        User context dictionary (stub for demo)
    """
    return container.user_context()

```

Создаю routers/uma.py с всеми endpoints:

```python
"""UMA API endpoints."""

import structlog
from fastapi import APIRouter
from fastapi import Depends

from namerec.uma import uma_delete
from namerec.uma import uma_entity_details
from namerec.uma import uma_entity_list
from namerec.uma import uma_read
from namerec.uma import uma_save
from namerec.uma import uma_select
from namerec.uma.jsql.converter import jsql_to_sql
from namerec.uma.jsql.converter import sql_to_jsql
from src.dependencies import get_user_context
from src.models.requests import DeleteRequest
from src.models.requests import EntityDetailsRequest
from src.models.requests import EntityListRequest
from src.models.requests import JSQL2SQLRequest
from src.models.requests import ReadRequest
from src.models.requests import SaveRequest
from src.models.requests import SelectRequest
from src.models.requests import SQL2JSQLRequest
from src.models.responses import DeleteResponse
from src.models.responses import EntityListResponse
from src.models.responses import SelectResponse

logger = structlog.get_logger()

router = APIRouter(prefix='/api/uma', tags=['UMA'])


@router.post('/select', response_model=SelectResponse)
async def select_endpoint(
    request: SelectRequest,
    user_context: dict = Depends(get_user_context),
) -> dict:
    """
    Execute JSQL query.

    Args:
        request: JSQL query with optional parameters
        user_context: User context for access control

    Returns:
        Query result with metadata and data
    """
    logger.info(
        'JSQL select request',
        entity=request.jsql.get('from'),
        has_params=request.params is not None,
    )

    result = await uma_select(
        jsql=request.jsql,
        params=request.params,
        user_context=user_context,
    )

    logger.info('JSQL select completed', row_count=len(result.get('data', [])))
    return result


@router.post('/read')
async def read_endpoint(
    request: ReadRequest,
    user_context: dict = Depends(get_user_context),
) -> dict:
    """
    Read a single record by ID.

    Args:
        request: Entity name and record ID
        user_context: User context for access control

    Returns:
        Record data as dictionary
    """
    logger.info('Read request', entity_name=request.entity_name, id=request.id)

    result = await uma_read(
        entity_name=request.entity_name,
        id_value=request.id,
        user_context=user_context,
    )

    logger.info('Read completed', entity_name=request.entity_name)
    return result


@router.post('/save')
async def save_endpoint(
    request: SaveRequest,
    user_context: dict = Depends(get_user_context),
) -> dict:
    """
    Save a record (create or update).

    Returns the full record body after save.

    Args:
        request: Entity name and record data
        user_context: User context for access control

    Returns:
        Full record data after save
    """
    has_id = any(request.data.get(key) is not None for key in ['id', 'ID'])
    operation = 'update' if has_id else 'create'

    logger.info(
        'Save request',
        entity_name=request.entity_name,
        operation=operation,
    )

    # Save record (returns ID)
    saved_id = await uma_save(
        entity_name=request.entity_name,
        data=request.data,
        user_context=user_context,
    )

    # Read back the full record
    record = await uma_read(
        entity_name=request.entity_name,
        id_value=saved_id,
        user_context=user_context,
    )

    logger.info('Save completed', entity_name=request.entity_name, id=saved_id)
    return record


@router.post('/delete', response_model=DeleteResponse)
async def delete_endpoint(
    request: DeleteRequest,
    user_context: dict = Depends(get_user_context),
) -> dict:
    """
    Delete a record by ID.

    Args:
        request: Entity name and record ID
        user_context: User context for access control

    Returns:
        Deletion status
    """
    logger.info('Delete request', entity_name=request.entity_name, id=request.id)

    deleted = await uma_delete(
        entity_name=request.entity_name,
        id_value=request.id,
        user_context=user_context,
    )

    logger.info('Delete completed', entity_name=request.entity_name, deleted=deleted)
    return {'deleted': deleted}


@router.post('/meta/entity_list', response_model=EntityListResponse)
async def entity_list_endpoint(
    request: EntityListRequest,
    user_context: dict = Depends(get_user_context),
) -> dict:
    """
    Get list of available entities.

    Args:
        request: Optional namespace filter
        user_context: User context for access control

    Returns:
        List of entity names
    """
    logger.info('Entity list request', namespace=request.namespace)

    entities = await uma_entity_list(
        user_context=user_context,
        namespace=request.namespace,
    )

    logger.info('Entity list completed', count=len(entities))
    return {'entities': entities}


@router.post('/meta/entity_details')
async def entity_details_endpoint(
    request: EntityDetailsRequest,
    user_context: dict = Depends(get_user_context),
) -> dict:
    """
    Get entity metadata (structure).

    Args:
        request: Entity name
        user_context: User context for access control

    Returns:
        Entity metadata dictionary
    """
    logger.info('Entity details request', entity_name=request.entity_name)

    details = await uma_entity_details(
        entity_name=request.entity_name,
        user_context=user_context,
    )

    logger.info('Entity details completed', entity_name=request.entity_name)
    return details


@router.post('/transform/sql2jsql')
async def sql2jsql_endpoint(request: SQL2JSQLRequest) -> dict:
    """
    Transform SQL query to JSQL format.

    Args:
        request: SQL query string and optional dialect

    Returns:
        JSQL query dictionary
    """
    logger.info('SQL to JSQL transformation', dialect=request.dialect)

    jsql = sql_to_jsql(sql=request.data, dialect=request.dialect)

    logger.info('SQL to JSQL completed')
    return jsql


@router.post('/transform/jsql2sql')
async def jsql2sql_endpoint(request: JSQL2SQLRequest) -> dict:
    """
    Transform JSQL query to SQL string.

    Args:
        request: JSQL query dictionary and optional dialect

    Returns:
        SQL query string
    """
    logger.info('JSQL to SQL transformation', dialect=request.dialect)

    sql = jsql_to_sql(jsql=request.data, dialect=request.dialect)

    logger.info('JSQL to SQL completed')
    return {'sql': sql}

```

Создаю main.py с lifespan и exception handlers:

```python
"""FastAPI application entry point."""

from contextlib import asynccontextmanager

import structlog
from fastapi import FastAPI
from fastapi import Request
from fastapi.responses import JSONResponse

from namerec.uma import JSQLExecutionError
from namerec.uma import JSQLSyntaxError
from namerec.uma import UMAAccessDeniedError
from namerec.uma import UMAError
from namerec.uma import UMANotFoundError
from namerec.uma import UMAValidationError
from src.config import settings
from src.dependencies import container
from src.exceptions import handle_uma_exception
from src.logging_config import configure_logging
from src.routers import uma

# Configure logging
configure_logging(settings.log_level)
logger = structlog.get_logger()


@asynccontextmanager
async def lifespan(app: FastAPI):  # noqa: ANN201, ARG001
    """
    Manage application lifecycle.

    Handles:
    - UMA initialization at startup
    - Database connection cleanup at shutdown
    """
    # Startup
    logger.info('Starting UMA backend demo', debug_mode=settings.debug_mode)

    # Configure DI container
    container.config.database_url.from_value(settings.database_url)

    # Initialize UMA (triggers registry creation)
    container.registry()

    # Optionally preload metadata for production
    # await container.metadata_provider().preload(
    #     container.engine(),
    #     'main'
    # )

    logger.info('UMA initialized successfully', namespace='main')

    yield

    # Shutdown
    logger.info('Shutting down UMA backend demo')

    # Dispose database engine
    await container.engine().dispose()

    logger.info('Database connections closed')


# Create FastAPI application
app = FastAPI(
    title='UMA Backend Demo',
    description='FastAPI backend demonstrating UMA (Unified Model Access) capabilities',
    version='0.1.0',
    lifespan=lifespan,
)

# Include routers
app.include_router(uma.router)


# Exception handlers
@app.exception_handler(UMAAccessDeniedError)
async def uma_access_denied_handler(request: Request, exc: UMAAccessDeniedError):  # noqa: ARG001, ANN201
    """Handle UMA access denied errors."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.warning(
        'Access denied',
        entity_name=getattr(exc, 'entity_name', None),
        operation=getattr(exc, 'operation', None),
    )
    return JSONResponse(status_code=status_code, content=error.model_dump())


@app.exception_handler(UMANotFoundError)
async def uma_not_found_handler(request: Request, exc: UMANotFoundError):  # noqa: ARG001, ANN201
    """Handle UMA not found errors."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.warning(
        'Entity or record not found',
        entity_name=getattr(exc, 'entity_name', None),
    )
    return JSONResponse(status_code=status_code, content=error.model_dump())


@app.exception_handler(JSQLSyntaxError)
async def jsql_syntax_handler(request: Request, exc: JSQLSyntaxError):  # noqa: ARG001, ANN201
    """Handle JSQL syntax errors."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.error(
        'JSQL syntax error',
        path=getattr(exc, 'path', None),
        message=str(exc),
    )
    return JSONResponse(status_code=status_code, content=error.model_dump())


@app.exception_handler(JSQLExecutionError)
async def jsql_execution_handler(request: Request, exc: JSQLExecutionError):  # noqa: ARG001, ANN201
    """Handle JSQL execution errors."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.error(
        'JSQL execution error',
        message=str(exc),
    )
    return JSONResponse(status_code=status_code, content=error.model_dump())


@app.exception_handler(UMAValidationError)
async def uma_validation_handler(request: Request, exc: UMAValidationError):  # noqa: ARG001, ANN201
    """Handle UMA validation errors."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.error(
        'Validation error',
        field_name=getattr(exc, 'field_name', None),
        message=str(exc),
    )
    return JSONResponse(status_code=status_code, content=error.model_dump())


@app.exception_handler(UMAError)
async def uma_error_handler(request: Request, exc: UMAError):  # noqa: ARG001, ANN201
    """Handle generic UMA errors."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.error('UMA error', message=str(exc))
    return JSONResponse(status_code=status_code, content=error.model_dump())


@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception):  # noqa: ARG001, ANN201
    """Handle unexpected exceptions."""
    error, status_code = handle_uma_exception(exc, settings.debug_mode)
    logger.exception('Unexpected error', exc_info=exc)
    return JSONResponse(status_code=status_code, content=error.model_dump())


# Health check endpoint
@app.get('/health')
async def health_check() -> dict:
    """Health check endpoint."""
    return {'status': 'ok', 'service': 'uma-backend-demo'}


if __name__ == '__main__':
    import uvicorn

    uvicorn.run(
        'main:app',
        host='0.0.0.0',
        port=8000,
        reload=True,
        log_config=None,  # Use our custom logging configuration
    )

```

Создаю README.md:

```markdown
# UMA Backend Demo

FastAPI backend application demonstrating UMA (Unified Model Access) capabilities for processing JSQL queries.

## Features

- **JSQL Query Execution**: Execute JSON-formatted SQL queries
- **CRUD Operations**: Read, save, delete records with access control
- **Entity Metadata**: List entities and get detailed structure information
- **SQL ↔ JSQL Transformation**: Convert between SQL and JSQL formats
- **Structured Logging**: Production-ready logging with structlog
- **Error Handling**: Unified error response format with debug mode
- **Async-First**: Full async/await support for high performance

## Requirements

- Python 3.11+
- PostgreSQL database (with asyncpg driver)
- UMA package (installed from GitHub)

## Installation

1. **Clone the repository** (if not already done):
   ```bash
   git clone https://github.com/aka-NameRec/uma2.git
   cd uma2/examples/backend
   ```

2. **Create virtual environment**:
   ```bash
   python -m venv .venv
   source .venv/bin/activate  # On Windows: .venv\Scripts\activate
   ```

3. **Install dependencies**:
   ```bash
   pip install -e .
   ```

4. **Configure environment**:
   ```bash
   cp env.example .env
   # Edit .env with your database credentials
   ```

## Configuration

Edit `.env` file:

```env
# PostgreSQL connection string
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/database_name

# Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
LOG_LEVEL=INFO

# Debug mode (true/false) - adds detailed traceback to error responses
DEBUG_MODE=false
```

## Running the Application

### Development Mode

```bash
cd src
uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

Or using Python directly:

```bash
cd src
python main.py
```

### Production Mode

```bash
cd src
uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
```

## API Endpoints

All endpoints use POST method for consistency.

### JSQL Query Execution

**POST** `/api/uma/select`

Execute JSQL query:

```json
{
  "jsql": {
    "from": "users",
    "select": [{"field": "id"}, {"field": "name"}],
    "where": {"field": "active", "op": "=", "value": true},
    "limit": 10
  },
  "params": {}
}
```

### CRUD Operations

**POST** `/api/uma/read`

Read a record by ID:

```json
{
  "entity_name": "users",
  "id": 123
}
```

**POST** `/api/uma/save`

Save (create or update) a record:

```json
{
  "entity_name": "users",
  "data": {
    "name": "John Doe",
    "email": "john@example.com"
  }
}
```

Returns the full record body after save.

**POST** `/api/uma/delete`

Delete a record:

```json
{
  "entity_name": "users",
  "id": 123
}
```

### Entity Metadata

**POST** `/api/uma/meta/entity_list`

List available entities:

```json
{
  "namespace": null
}
```

**POST** `/api/uma/meta/entity_details`

Get entity structure:

```json
{
  "entity_name": "users"
}
```

### SQL ↔ JSQL Transformation

**POST** `/api/uma/transform/sql2jsql`

Convert SQL to JSQL:

```json
{
  "data": "SELECT id, name FROM users WHERE active = true LIMIT 10",
  "dialect": "postgresql"
}
```

**POST** `/api/uma/transform/jsql2sql`

Convert JSQL to SQL:

```json
{
  "data": {
    "from": "users",
    "select": [{"field": "id"}, {"field": "name"}],
    "where": {"field": "active", "op": "=", "value": true},
    "limit": 10
  },
  "dialect": "postgresql"
}
```

## Error Handling

All errors return a unified format:

```json
{
  "id": "UMAAccessDeniedError",
  "message": "Access denied for read on users",
  "details": {
    "entity_name": "users",
    "operation": "read"
  }
}
```

In `DEBUG_MODE=true`, errors include full traceback in `details.traceback`.

## Logging

Logs use ISO timestamp format with structured context:

```
2026-01-10T17:45:12.123456 INFO: UMA initialized successfully namespace=main
2026-01-10T17:45:13.234567 ERROR: JSQL syntax error path=where.conditions[0].op message=Invalid operator
```

Log verbosity is controlled by `LOG_LEVEL` environment variable.

## Health Check

**GET** `/health`

Returns application status:

```json
{
  "status": "ok",
  "service": "uma-backend-demo"
}
```

## Interactive API Documentation

Once running, visit:

- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Architecture

- **FastAPI**: Modern async web framework
- **UMA**: Unified Model Access for database operations
- **structlog**: Structured logging with standard logging integration
- **dependency-injector**: Dependency injection container
- **Pydantic**: Request/response validation
- **asyncpg**: Async PostgreSQL driver

## License

Public Domain - free for any use without restrictions.

```

Отлично! Все задачи выполнены. Теперь проверяю статус изменений:

Проверяю линтер на созданных файлах:

Отлично! Создаю сводку выполненных изменений:

## Резюме выполненных изменений

### 1. Переименование API функций UMA

✅ **Выполнено:**
- `uma_list_entities` → `uma_entity_list`
- `uma_meta` → `uma_entity_details`

**Изменённые файлы:**
- `src/namerec/uma/api.py` - переименованы функции
- `src/namerec/uma/__init__.py` - обновлены экспорты
- `examples/api_usage.py` - обновлены импорты и вызовы
- `tests/test_api.py` - обновлены импорты, вызовы и имена тестов

### 2. Создан FastAPI backend demo

✅ **Структура проекта:**
```
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение с lifespan
│   ├── config.py               # Настройки из .env
│   ├── logging_config.py       # structlog + stdlib интеграция
│   ├── dependencies.py         # DI container
│   ├── exceptions.py           # Обработчики UMA исключений
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic request models
│       └── responses.py        # Pydantic response models
├── env.example                 # Пример конфигурации
├── pyproject.toml              # Зависимости
├── README.md                   # Документация
└── .gitignore
```

### 3. Реализованные endpoints (все POST)

✅ **CRUD операции:**
- `/api/uma/select` - выполнение JSQL запросов
- `/api/uma/read` - чтение записи по ID
- `/api/uma/save` - сохранение записи (возвращает полное тело)
- `/api/uma/delete` - удаление записи

✅ **Метаданные:**
- `/api/uma/meta/entity_list` - список сущностей
- `/api/uma/meta/entity_details` - структура сущности

✅ **Трансформации SQL ↔ JSQL:**
- `/api/uma/transform/sql2jsql` - SQL → JSQL
- `/api/uma/transform/jsql2sql` - JSQL → SQL

### 4. Ключевые особенности реализации

✅ **Инициализация UMA:**
- Использует новый API с `NamespaceConfig`
- Ленивая загрузка метаданных
- Один namespace 'main' для демо

✅ **Логирование:**
- structlog с интеграцией стандартного logging
- Uvicorn и FastAPI используют тот же формат
- Формат: `ts log_level: message` (ISO timestamp)
- Подробность через `LOG_LEVEL` в .env

✅ **Обработка ошибок:**
- Унифицированный формат `ErrorResponse`
- `DEBUG_MODE` для детальных traceback в ответах
- Маппинг UMA исключений на HTTP статусы

✅ **Dependency Injection:**
- `dependency-injector` для управления зависимостями
- Lifespan management для инициализации/закрытия

✅ **uma_save возвращает полное тело:**
- После сохранения вызывается `uma_read`
- Возвращается полная запись для форм ввода

### 5. Конфигурация

✅ **env.example:**
```env
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/uma_demo
LOG_LEVEL=INFO
DEBUG_MODE=false
```

✅ **Зависимости (pyproject.toml):**
- fastapi>=0.104.0
- uvicorn[standard]>=0.24.0
- pydantic-settings>=2.0.0
- structlog>=23.2.0
- asyncpg>=0.29.0
- dependency-injector>=4.41.0
- namerec-uma @ git+https://github.com/aka-NameRec/uma2.git

### 6. Статус

✅ **Все задачи выполнены:**
- Переименования API функций
- Создана полная структура backend
- Все endpoints реализованы
- Логирование настроено
- Обработка ошибок реализована
- Документация создана
- Линтер не выявил ошибок

✅ **Готово к коммиту:**
- Ветка: `feature/20260107-203303-backend_demo`
- Изменения не закоммичены (ожидается утверждение)

Все изменения соответствуют требованиям и готовы к review.

```plaintext
examples/backend/
├── src/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение с lifespan
│   ├── config.py               # Настройки из .env
│   ├── logging_config.py       # structlog + stdlib интеграция
│   ├── dependencies.py         # DI container
│   ├── exceptions.py           # Обработчики UMA исключений
│   ├── routers/
│   │   ├── __init__.py
│   │   └── uma.py              # UMA endpoints
│   └── models/
│       ├── __init__.py
│       ├── requests.py         # Pydantic request models
│       └── responses.py        # Pydantic response models
├── env.example                 # Пример конфигурации
├── pyproject.toml              # Зависимости
├── README.md                   # Документация
└── .gitignore
```

```env
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/uma_demo
LOG_LEVEL=INFO
DEBUG_MODE=false
```
