# Лог работы: Тестирование и исправление backend (2026-01-15)

## Цель работы

Тестирование backend с JSQL запросами, исправление проблем с кэшированием и безопасностью параметризованных запросов.

## Основные задачи

1. Тестирование backend с запросами к таблице `plainter_case`
2. Исправление проблем с кэшированием запросов
3. Исправление проблем безопасности с параметризованными запросами
4. Восстановление защиты от SQL-инъекций через параметризованные запросы

## Проблемы и решения

### Проблема 1: Ошибка `InvalidRequestError: A value is required for bind parameter`

**Симптомы:**
- Запросы через FastAPI endpoint падали с ошибкой `A value is required for bind parameter 'param_1'`
- SQL содержал `CAST($1 AS TIMESTAMP)`, что указывало на использование параметров вместо литералов
- Прямые вызовы `uma.select()` работали корректно

**Причина:**
- Кэширование запросов компилировало SQL без `literal_binds=True`
- Кэшированный SQL содержал параметры (`$1`, `$2`), но при выполнении передавался пустой `params={}`
- Это вызывало ошибку отсутствия значений для параметров

**Решение:**
- Отключено кэширование для диагностики проблемы
- Восстановлено кэширование с правильной логикой:
  - SQL компилируется БЕЗ `literal_binds=True` для получения плейсхолдеров
  - SQL с плейсхолдерами кэшируется
  - При выполнении кэшированного SQL передаются актуальные значения параметров

**Файлы:**
- `src/namerec/uma/jsql/executor.py`: Исправлена логика кэширования и выполнения кэшированных запросов
- `src/namerec/uma/jsql/cache/keys.py`: Обновлена логика генерации ключей кэша (параметры не включаются в ключ)

### Проблема 2: Потеря защиты от SQL-инъекций

**Симптомы:**
- Использование `literal_binds=True` для всех значений (включая параметры)
- Значения параметров встраивались в SQL строку вместо использования параметризованных запросов
- Это снижало защиту от SQL-инъекций

**Причина:**
- Параметры JSQL обрабатывались через `literal()` вместо `bindparam()`
- Все запросы компилировались с `literal_binds=True`, встраивая значения в SQL

**Решение:**
- Параметры JSQL (`{"param": "name"}`) теперь используют `bindparam()` для параметризованных запросов
- Запросы выполняются через `conn.execute(sql_query, params)` с передачей параметров отдельно
- `literal_binds=True` больше не используется для параметров
- Литералы JSQL (`{"value": "..."}`) используют `literal()`, который безопасно экранирует значения

**Файлы:**
- `src/namerec/uma/jsql/parser.py`: Изменена обработка параметров JSQL - используется `bindparam()` вместо `literal()`
- `src/namerec/uma/jsql/executor.py`: Изменена логика выполнения запросов - используются параметризованные запросы

### Проблема 3: Неправильное понимание кэширования

**Симптомы:**
- Изначально считалось, что запросы с параметрами не могут кэшироваться
- Ключ кэша включал значения параметров, что создавало разные ключи для одного и того же SQL

**Причина:**
- Неправильное понимание концепции кэширования SQL с параметрами

**Решение:**
- Ключ кэша зависит только от структуры JSQL и user_context, НЕ от значений параметров
- SQL с плейсхолдерами кэшируется один раз
- Один и тот же SQL выполняется с разными значениями параметров
- Маппинг параметров сохраняется для правильной передачи значений при выполнении

**Файлы:**
- `src/namerec/uma/jsql/cache/keys.py`: Убраны параметры из ключа кэша
- `src/namerec/uma/jsql/executor.py`: Исправлена логика кэширования и выполнения кэшированных запросов

## Изменения в коде

### `src/namerec/uma/jsql/parser.py`

**Изменения:**
- Параметры JSQL теперь используют `bindparam()` вместо `literal()`
- `bindparam(param_name, value=None)` создает параметризованные запросы
- Значения параметров передаются при выполнении, а не встраиваются в SQL

**Строки:**
- 756-766: Изменена обработка параметров JSQL

### `src/namerec/uma/jsql/executor.py`

**Изменения:**
- Выполнение запросов использует параметризованные запросы (`conn.execute(sql_query, params)`)
- Кэширование SQL с плейсхолдерами для запросов с параметрами
- Правильная передача параметров при выполнении кэшированного SQL
- Маппинг параметров для корректной передачи значений

**Строки:**
- 60-95: Исправлена логика проверки кэша и выполнения кэшированных запросов
- 123-160: Исправлена логика кэширования SQL с параметрами
- 152-170: Изменена логика выполнения запросов - используются параметризованные запросы
- 198-220: Исправлена логика выполнения кэшированных запросов

### `src/namerec/uma/jsql/cache/keys.py`

**Изменения:**
- Параметры НЕ включаются в ключ кэша
- Ключ зависит только от структуры JSQL и user_context
- Это позволяет кэшировать SQL с плейсхолдерами и использовать его с разными значениями параметров

**Строки:**
- 10-51: Обновлена функция `make_cache_key()` - параметры не включаются в ключ

### `examples/backend/src/dependencies.py`

**Изменения:**
- Кэширование включено по умолчанию
- Комментарии обновлены для отражения правильной логики кэширования

## Тестирование

### Тест 1: Запросы с параметрами

**Результат:** ✓ Успешно
- Параметры JSQL корректно обрабатываются через `bindparam()`
- Запросы выполняются через параметризованные запросы
- Защита от SQL-инъекций восстановлена

### Тест 2: Кэширование SQL с параметрами

**Результат:** ✓ Успешно
- SQL с плейсхолдерами кэшируется один раз
- Один и тот же SQL выполняется с разными значениями параметров
- Кэш работает корректно (второй запрос быстрее первого)

### Тест 3: Запросы без параметров (литералы)

**Результат:** ✓ Успешно
- Литералы JSQL обрабатываются через `literal()`
- SQLAlchemy безопасно экранирует значения
- Запросы выполняются корректно

## Выводы

1. **Безопасность восстановлена:**
   - Параметры JSQL используют параметризованные запросы через `bindparam()`
   - Защита от SQL-инъекций работает корректно
   - Значения параметров передаются отдельно, не встраиваются в SQL

2. **Кэширование работает правильно:**
   - SQL с плейсхолдерами кэшируется
   - Один SQL используется с разными значениями параметров
   - Ключ кэша зависит только от структуры JSQL, не от значений параметров

3. **Производительность улучшена:**
   - Кэширование ускоряет повторные запросы
   - Параметризованные запросы эффективны для БД

## Следующие шаги

1. Рассмотреть улучшение маппинга параметров для сохранения оригинальных имен JSQL параметров
2. Добавить тесты для проверки безопасности параметризованных запросов
3. Документировать использование параметров в JSQL запросах

## Дата работы

2026-01-15
