# UMA API Summary

## Overview

The UMA API provides a high-level interface for working with database entities through the `UMA` class. All API methods support access control, user context, and namespace isolation.

## Initialization

### `UMA.create()`

Initialize UMA at application startup.

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig
from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine('sqlite+aiosqlite:///test.db')
metadata_provider = DefaultMetadataProvider()

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})
```

**Returns**: `UMA` instance

**Required**: Call once before using other API methods.

**Multiple Namespaces**: You can configure multiple namespaces:

```python
uma = UMA.create({
    'db1': NamespaceConfig(engine=engine1, metadata_provider=provider1),
    'db2': NamespaceConfig(engine=engine2, metadata_provider=provider2),
})
```

## Core API Methods

### `uma.read()`

Read a single record by ID.

```python
user = await uma.read(
    entity_name='users',        # Entity name
    id_value=123,              # Record ID
    user_context=current_user, # Optional: for access control
    namespace=None,            # Optional: entity namespace
)
```

**Returns**: `dict` with record data

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found

### `uma.save()`

Create or update a record.

```python
# Create (no id)
user_id = await uma.save(
    entity_name='users',
    data={'name': 'John', 'email': 'john@example.com'},
    user_context=current_user,
)

# Update (with id)
await uma.save(
    entity_name='users',
    data={'id': 123, 'name': 'John Smith'},
    user_context=current_user,
)
```

**Returns**: ID of saved record

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found (for update)

### `uma.delete()`

Delete a record by ID.

```python
deleted = await uma.delete(
    entity_name='users',
    id_value=123,
    user_context=current_user,
)
```

**Returns**: `bool` - True if deleted

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found

### `uma.entity_details()`

Get entity metadata (columns, types, descriptions).

```python
metadata = await uma.entity_details(
    entity_name='users',
    user_context=current_user,
)

# Access metadata
print(metadata['name'])         # Entity name
print(metadata['description'])  # Description
for col in metadata['columns']:
    print(col['name'], col['type'])
```

**Returns**: `dict` with metadata

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Entity not found

### `uma.entity_list()`

List all available entities.

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace=None,  # Optional: filter by namespace
)

print(entities)  # ['users', 'orders', 'virtual:user_summary', ...]
```

**Returns**: `list[str]` - Entity names

**Raises**: 
- `UMAAccessDeniedError` - Access denied

### `uma.select()` âœ…

Execute JSQL (JSON-SQL) query.

```python
# Simple SELECT with WHERE
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name', 'email'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    user_context=current_user,
)

# With parameters
result = await uma.select(
    jsql={
        'from': 'orders',
        'select': ['id', 'amount'],
        'where': {
            'op': '>',
            'left': {'field': 'amount'},
            'right': {'param': 'min_amount'}
        }
    },
    params={'min_amount': 100},
    user_context=current_user,
)

# With debug mode
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'debug': True  # Include generated SQL in result
    },
    user_context=current_user,
)
# result['debug'] contains formatted SQL
```

**Returns**: Dictionary with `meta` and `data` keys:
- `meta`: List of column metadata (name, type, nullable, qualified_name, etc.)
- `data`: List of rows (each row is a list of values)
- `debug`: Optional formatted SQL string (if `debug: true` in JSQL)

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `JSQLSyntaxError` - Invalid JSQL syntax
- `JSQLExecutionError` - Query execution failed

**Documentation**: See [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md) for complete syntax and examples.

**Supported Features**:
- SELECT with fields and aliases
- WHERE with all operators (=, !=, <, >, <=, >=, AND, OR, NOT, IN, LIKE, EXISTS, IS NULL)
- JOINs (INNER, LEFT, RIGHT, FULL)
- Aggregations (COUNT, SUM, AVG, MIN, MAX)
- GROUP BY and HAVING
- ORDER BY (including by aliases)
- LIMIT and OFFSET
- CTEs (Common Table Expressions)
- Subqueries
- Window functions (ROW_NUMBER, RANK, etc.)
- Parameterized queries

## Access Control

### Implementing Custom Access Control

Create a custom `MetadataProvider` with `can()` method:

```python
from namerec.uma import DefaultMetadataProvider, OP_LIST, OP_META, OP_READ, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    async def can(
        self,
        entity_name: str,
        operation: str,
        context: UMAContext,
    ) -> bool:
        """Check access based on user role."""
        user_context = context.user_context
        if not user_context:
            return False
        
        # Admin can do everything
        if user_context.role == 'admin':
            return True
        
        # Regular user: read-only
        if user_context.role == 'user':
            return operation in (OP_READ, OP_META, OP_LIST)
        
        # Default: deny
        return False

# Use in initialization
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=MyMetadataProvider(),
    ),
})
```

### Operations

Available operations for access control:

- `OP_READ` - Read/query data (includes JSQL SELECT)
- `OP_CREATE` - Create new record
- `OP_UPDATE` - Update existing record
- `OP_DELETE` - Delete record
- `OP_META` - Get metadata
- `OP_LIST` - List entities

## User Context

Pass user information for access control:

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

current_user = User(user_id=123, role='user')

# Use in API calls
user_data = await uma.read('users', 456, user_context=current_user)
```

The `user_context` can be any object - it's passed to `can()` method in `MetadataProvider`.

## Namespaces

Use namespaces to organize entities:

```python
# In entity name
await uma.read('virtual:user_summary', 1)

# As parameter
await uma.read('user_summary', 1, namespace='virtual')

# List by namespace
entities = await uma.entity_list(namespace='virtual')
```

## Error Handling

```python
from namerec.uma import (
    UMAAccessDeniedError,
    UMANotFoundError,
    UMAError,
)

try:
    user = await uma.read('users', 123, user_context=current_user)
except UMAAccessDeniedError as e:
    print(f"Access denied: {e}")
except UMANotFoundError as e:
    print(f"Not found: {e}")
except UMAError as e:
    print(f"UMA error: {e}")
```

## Virtual Views

Register virtual views for computed data:

```python
from namerec.uma import VirtualViewHandler
from sqlalchemy import select, func

class UserStatsView(VirtualViewHandler):
    description = "User statistics"
    
    @classmethod
    async def select(cls, entity_name, params, context):
        users = context.metadata.tables['users']
        return select(
            users.c.id,
            func.count().label('record_count')
        ).group_by(users.c.id)
    
    @classmethod
    async def meta(cls, entity_name, context, registry):
        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': [
                {'name': 'id', 'type': 'integer'},
                {'name': 'record_count', 'type': 'integer'},
            ]
        }

# Register
uma.registry.register('user_stats', UserStatsView)

# Use like regular entity
stats = await uma.entity_details('user_stats')
```

## Cache Management

UMA supports query caching for JSQL queries:

```python
from namerec.uma.jsql.cache import MemoryCacheBackend

# Enable cache
cache_backend = MemoryCacheBackend(max_size=1000)
uma = UMA.create(
    {
        'main': NamespaceConfig(
            engine=engine,
            metadata_provider=metadata_provider,
        ),
    },
    cache_backend=cache_backend,
)

# Cache operations
uma.enable_cache()   # Enable caching
uma.disable_cache()  # Disable caching
uma.clear_cache()    # Clear all cached queries
stats = uma.cache_stats()  # Get cache statistics
```

## Best Practices

1. **Initialize Once**: Call `UMA.create()` at application startup
2. **Use Access Control**: Always implement `can()` method for security
3. **Pass User Context**: Include `user_context` in all API calls
4. **Handle Errors**: Catch and handle UMA exceptions properly
5. **Use Namespaces**: Organize entities with namespaces for clarity
6. **Virtual Views**: Use for computed/aggregated data
7. **Async/Await**: All API methods are async - use `await`

## Complete Example

```python
import asyncio
from sqlalchemy import Column, Integer, String, MetaData, Table
from sqlalchemy.ext.asyncio import create_async_engine
from namerec.uma import (
    UMA,
    DefaultMetadataProvider,
    NamespaceConfig,
    UMAAccessDeniedError,
)

async def main():
    # Setup
    engine = create_async_engine('sqlite+aiosqlite:///test.db')
    metadata = MetaData()
    Table('users', metadata,
          Column('id', Integer, primary_key=True),
          Column('name', String(100)))
    
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)
    
    # Initialize UMA
    uma = UMA.create({
        'main': NamespaceConfig(
            engine=engine,
            metadata_provider=DefaultMetadataProvider(),
        ),
    })
    
    # Use API
    entities = await uma.entity_list()
    print(f"Entities: {entities}")
    
    user_id = await uma.save('users', {'name': 'John'})
    print(f"Created: {user_id}")
    
    user = await uma.read('users', user_id)
    print(f"User: {user}")
    
    await uma.delete('users', user_id)
    print("Deleted")
    
    await engine.dispose()

if __name__ == '__main__':
    asyncio.run(main())
```

## See Also

- [QUICKSTART.md](20260104-195802-doc-QUICKSTART.md) - Quick start guide
- [examples/api_usage.py](../examples/api_usage.py) - Complete example with access control
- [PROJECT_STRUCTURE.md](20260104-195714-doc-PROJECT_STRUCTURE.md) - Architecture details
