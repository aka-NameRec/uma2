# UMA API Summary

## Overview

The UMA API layer provides high-level functions for working with database entities through a unified interface. All API functions support access control, user context, and namespace isolation.

## Initialization

### `initialize_uma()`

Initialize UMA at application startup.

```python
from namerec.uma import initialize_uma

registry = initialize_uma(
    engine=engine,                      # SQLAlchemy Engine
    metadata=metadata,                  # SQLAlchemy MetaData (reflected)
    metadata_provider=None,             # Optional: custom MetadataProvider
    default_handler=None,               # Optional: custom default handler
)
```

**Returns**: `EntityRegistry` instance

**Required**: Call once before using other API functions.

## Core API Functions

### `uma_read()`

Read a single record by ID.

```python
from namerec.uma import uma_read

user = await uma_read(
    entity_name='users',        # Entity name
    id_value=123,              # Record ID
    user_context=current_user, # Optional: for access control
    namespace=None,            # Optional: entity namespace
)
```

**Returns**: `dict` with record data

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found

### `uma_save()`

Create or update a record.

```python
from namerec.uma import uma_save

# Create (no id)
user_id = await uma_save(
    entity_name='users',
    data={'name': 'John', 'email': 'john@example.com'},
    user_context=current_user,
)

# Update (with id)
await uma_save(
    entity_name='users',
    data={'id': 123, 'name': 'John Smith'},
    user_context=current_user,
)
```

**Returns**: ID of saved record

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found (for update)

### `uma_delete()`

Delete a record by ID.

```python
from namerec.uma import uma_delete

deleted = await uma_delete(
    entity_name='users',
    id_value=123,
    user_context=current_user,
)
```

**Returns**: `bool` - True if deleted

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found

### `uma_meta()`

Get entity metadata (columns, types, descriptions).

```python
from namerec.uma import uma_meta

metadata = await uma_meta(
    entity_name='users',
    user_context=current_user,
)

# Access metadata
print(metadata['name'])         # Entity name
print(metadata['description'])  # Description
for col in metadata['columns']:
    print(col['name'], col['type'])
```

**Returns**: `dict` with metadata

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Entity not found

### `uma_list_entities()`

List all available entities.

```python
from namerec.uma import uma_list_entities

entities = await uma_list_entities(
    user_context=current_user,
    namespace=None,  # Optional: filter by namespace
)

print(entities)  # ['users', 'orders', 'virtual:user_summary', ...]
```

**Returns**: `list[str]` - Entity names

**Raises**: 
- `UMAAccessDeniedError` - Access denied

### `uma_select()` ⚠️

Execute JSQL query (placeholder implementation).

```python
from namerec.uma import uma_select

# Note: Full JSQL parser not yet implemented
result = await uma_select(
    jsql={'from': 'users', 'select': ['*']},
    params={},
    user_context=current_user,
)
```

**Status**: Placeholder - raises `NotImplementedError`

**Future**: Will support full JSQL syntax for complex queries.

## Access Control

### Implementing Custom Access Control

Create a custom `MetadataProvider` with `can()` method:

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        """Check access based on user role."""
        user = context.user_context
        
        # No user = no access
        if not user:
            return False
        
        # Admin can do everything
        if user.role == 'admin':
            return True
        
        # Regular user: read-only
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        # Default: deny
        return False

# Use in initialization
registry = initialize_uma(
    engine=engine,
    metadata=metadata,
    metadata_provider=MyMetadataProvider(),
)
```

### Operations

Available operations for access control:

- `Operation.SELECT` - JSQL query execution
- `Operation.READ` - Read single record
- `Operation.CREATE` - Create new record
- `Operation.UPDATE` - Update existing record
- `Operation.DELETE` - Delete record
- `Operation.META` - Get metadata
- `Operation.LIST` - List entities

## User Context

Pass user information for access control:

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

current_user = User(user_id=123, role='user')

# Use in API calls
user_data = await uma_read('users', 456, user_context=current_user)
```

The `user_context` can be any object - it's passed to `can()` method in `MetadataProvider`.

## Namespaces

Use namespaces to organize entities:

```python
# In entity name
await uma_read('virtual:user_summary', 1)

# As parameter
await uma_read('user_summary', 1, namespace='virtual')

# List by namespace
entities = await uma_list_entities(namespace='virtual')
```

## Error Handling

```python
from namerec.uma import (
    UMAAccessDeniedError,
    UMANotFoundError,
    UMAError,
)

try:
    user = await uma_read('users', 123, user_context=current_user)
except UMAAccessDeniedError as e:
    print(f"Access denied: {e}")
except UMANotFoundError as e:
    print(f"Not found: {e}")
except UMAError as e:
    print(f"UMA error: {e}")
```

## Virtual Views

Register virtual views for computed data:

```python
from namerec.uma import VirtualViewHandler, get_registry
from sqlalchemy import select, func

class UserStatsView(VirtualViewHandler):
    description = "User statistics"
    
    @classmethod
    async def select(cls, entity_name, params, context):
        users = context.metadata.tables['users']
        return select(
            users.c.id,
            func.count().label('record_count')
        ).group_by(users.c.id)
    
    @classmethod
    async def meta(cls, entity_name, context):
        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': [
                {'name': 'id', 'type': 'integer'},
                {'name': 'record_count', 'type': 'integer'},
            ]
        }

# Register
registry = get_registry()
registry.register('user_stats', UserStatsView)

# Use like regular entity
stats = await uma_meta('user_stats')
```

## Best Practices

1. **Initialize Once**: Call `initialize_uma()` at application startup
2. **Use Access Control**: Always implement `can()` method for security
3. **Pass User Context**: Include `user_context` in all API calls
4. **Handle Errors**: Catch and handle UMA exceptions properly
5. **Use Namespaces**: Organize entities with namespaces for clarity
6. **Virtual Views**: Use for computed/aggregated data
7. **Async/Await**: All API functions are async - use `await`

## Complete Example

```python
import asyncio
from sqlalchemy import Column, Integer, String, MetaData, Table
from sqlalchemy.ext.asyncio import create_async_engine
from namerec.uma import (
    initialize_uma,
    uma_read,
    uma_save,
    uma_delete,
    uma_list_entities,
    UMAAccessDeniedError,
)

async def main():
    # Setup
    engine = create_async_engine('sqlite+aiosqlite:///test.db')
    metadata = MetaData()
    Table('users', metadata,
          Column('id', Integer, primary_key=True),
          Column('name', String(100)))
    
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)
    
    # Initialize UMA
    initialize_uma(engine=engine, metadata=metadata)
    
    # Use API
    entities = await uma_list_entities()
    print(f"Entities: {entities}")
    
    user_id = await uma_save('users', {'name': 'John'})
    print(f"Created: {user_id}")
    
    user = await uma_read('users', user_id)
    print(f"User: {user}")
    
    await uma_delete('users', user_id)
    print("Deleted")
    
    await engine.dispose()

if __name__ == '__main__':
    asyncio.run(main())
```

## See Also

- [QUICKSTART.md](QUICKSTART.md) - Quick start guide
- [examples/api_usage.py](examples/api_usage.py) - Complete example with access control
- [PROJECT_STRUCTURE.md](PROJECT_STRUCTURE.md) - Architecture details
