# Code review —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–∏
_Exported on 15.01.2026 at 8:38:29 GMT+3 from Cursor (2.3.35)_

---

**User**

–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–ø–æ–ª–Ω–∏ code review –∏–∑–º–µ–Ω–µ–Ω–∏–π, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –≤ —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–µ.
–û–±—Ä–∞—Ç–∏ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ª—É—á—à–∏–º –ø—Ä–∞–∫—Ç–∏–∫–∞–º, —Å–æ–±–ª—é–¥–µ–Ω–∏–µ –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ DRY –∏ SOLID, –∞ —Ç–∞–∫–∂–µ –Ω–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Ä–µ—à–µ–Ω–∏–π (–æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –º–∞–ª—è—Ä–∞, –∏–∑–±—ã—Ç–æ—á–Ω–æ–π –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏ –ø—Ä–æ—á–∏—Ö —É–∂–∞—Å–æ–≤).

---

**Cursor**

–Ø –≤—ã–ø–æ–ª–Ω—é code review –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–µ. –ù–∞—á–Ω—É —Å –∞–Ω–∞–ª–∏–∑–∞ —Ç–æ–≥–æ, –∫–∞–∫–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—ã–ª–∏ —Å–¥–µ–ª–∞–Ω—ã.

–¢–µ–ø–µ—Ä—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏–∑–º–µ–Ω–µ–Ω–∏–π –∏ –≤—ã–ø–æ–ª–Ω—é –¥–µ—Ç–∞–ª—å–Ω—ã–π code review.

–¢–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω—é –ø–æ–ª–Ω—ã–π code review –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –≤–µ—Ç–∫–µ.

# Code Review –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –≤–µ—Ç–∫–µ feature/20260114-102145-refactoring

## –û–±–∑–æ—Ä –∏–∑–º–µ–Ω–µ–Ω–∏–π

–í–µ—Ç–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç 9 –∫–æ–º–º–∏—Ç–æ–≤ —Å –º–∞—Å—à—Ç–∞–±–Ω—ã–º —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–æ–º:
1. –°–æ–∑–¥–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∫—ç—à–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ Protocol
2. –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤
3. –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ DefaultMetadataProvider –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
4. –°–æ–∑–¥–∞–Ω–∏–µ AliasManager –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–ª–∏–∞—Å–∞–º–∏
5. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ –∫–æ–ª–æ–Ω–æ–∫ –≤ parser.py (O(1) index)
6. –ú–æ–¥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è converter.py
7. –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è (–∞–Ω—Ç–∏-–ø–∞—Ç—Ç–µ—Ä–Ω–∞)
8. –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ DRY –Ω–∞—Ä—É—à–µ–Ω–∏–π –≤ API —Å–ª–æ–µ

–í—Å–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–æ 43 —Ñ–∞–π–ª–∞, +11,655 / -1,932 —Å—Ç—Ä–æ–∫.

---

## üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–ë–õ–ï–ú–´

### 1. **Dead Code –∏ Broken Access Control** –≤ `src/namerec/uma/application.py`

**–õ–æ–∫–∞—Ü–∏—è**: –°—Ç—Ä–æ–∫–∏ 460-478 –∏ 552-555

–ú–µ—Ç–æ–¥ `_check_access()` –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ—Ä–∞–±–æ—á–∏–π:

```460:479:src/namerec/uma/application.py
def _check_access(
    self,
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """
    Check access and raise exception if access denied.

    Args:
        entity_name: Entity name
        operation: Operation name
        context: Execution context

    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)
```

**–ü—Ä–æ–±–ª–µ–º–∞**: –ú–µ—Ç–æ–¥ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç `operation` –≤ enum, –Ω–æ –∑–∞—Ç–µ–º –ù–ò–ß–ï–ì–û –Ω–µ –¥–µ–ª–∞–µ—Ç! –ö–æ–¥ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.

**–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ**: –ü–æ—Å–ª–µ –º–µ—Ç–æ–¥–∞ `cache_stats()` (—Å—Ç—Ä–æ–∫–∞ 550) –µ—Å—Ç—å –º–µ—Ä—Ç–≤—ã–π –∫–æ–¥:

```552:556:src/namerec/uma/application.py
        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):
                raise UMAAccessDeniedError(entity_name, operation.value)
```

–≠—Ç–æ—Ç –∫–æ–¥ –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º (–ø–æ—Å–ª–µ return statement) –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ `context`, `entity_name`, `operation`, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.

**–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –°–∏—Å—Ç–µ–º–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–æ—Å—Ç—É–ø–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ—Ä–∞–±–æ—á–∞—è. –õ—é–±–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –ª—é–±—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏.

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –ª–æ–≥–∏–∫—É –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –≤ `_check_access()` –∏ —É–¥–∞–ª–∏—Ç—å –º–µ—Ä—Ç–≤—ã–π –∫–æ–¥.

---

### 2. **Algorithmic Painter Problem** –≤ `src/namerec/uma/jsql/cache/memory.py`

**–õ–æ–∫–∞—Ü–∏—è**: –°—Ç—Ä–æ–∫–∏ 33-38

```31:41:src/namerec/uma/jsql/cache/memory.py
def get(self, key: str) -> CachedQuery | None:
    """Get query from cache with LRU update."""
    if key in self._cache:
        # Move to end (most recently used)
        self._order.remove(key)  # ‚Üê O(n) –æ–ø–µ—Ä–∞—Ü–∏—è!
        self._order.append(key)
        self._hits += 1
        return self._cache[key]
```

**–ü—Ä–æ–±–ª–µ–º–∞**: `list.remove(key)` –∏–º–µ–µ—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç—å O(n). –ö–∞–∂–¥—ã–π cache hit —Ç—Ä–µ–±—É–µ—Ç –ª–∏–Ω–µ–π–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –≤ —Å–ø–∏—Å–∫–µ.

–ü—Ä–∏ –∫—ç—à–µ –∏–∑ 128 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏ –≤—ã—Å–æ–∫–æ–º hit rate —ç—Ç–æ –¥–∞–µ—Ç:
- –ö—ç—à hit: O(n) –≤–º–µ—Å—Ç–æ –æ–∂–∏–¥–∞–µ–º–æ–≥–æ O(1)
- –í —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ (—ç–ª–µ–º–µ–Ω—Ç –≤ –Ω–∞—á–∞–ª–µ —Å–ø–∏—Å–∫–∞): O(128)
- –í —Å—Ä–µ–¥–Ω–µ–º: O(64)

**–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è**: –ü—Ä–∏ –≤—ã—Å–æ–∫–æ–π –Ω–∞–≥—Ä—É–∑–∫–µ (1000+ req/s) –∫—ç—à –≤–º–µ—Å—Ç–æ —É—Å–∫–æ—Ä–µ–Ω–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —É–∑–∫–∏–º –º–µ—Å—Ç–æ–º.

**–†–µ—à–µ–Ω–∏–µ**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `collections.OrderedDict` –∏–ª–∏ doubly-linked list + dict:

```python
from collections import OrderedDict
@dataclass
class MemoryCacheBackend:
    def __init__(self, max_size: int = 128):
        self._cache: OrderedDict[str, CachedQuery] = OrderedDict()
        self._max_size = max_size
        self._hits = 0
        self._misses = 0
    
    def get(self, key: str) -> CachedQuery | None:
        if key in self._cache:
            self._cache.move_to_end(key)  # O(1)
            self._hits += 1
            return self._cache[key]
        self._misses += 1
        return None
```

---

### 3. **–ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤ Redis cache stats** –≤ `src/namerec/uma/jsql/cache/redis.py`

**–õ–æ–∫–∞—Ü–∏—è**: –°—Ç—Ä–æ–∫–∏ 93-117

```93:117:src/namerec/uma/jsql/cache/redis.py
def stats(self) -> dict[str, Any]:
    """Get cache statistics from Redis."""
    hits = int(self._redis.get(self._hits_key) or 0)
    misses = int(self._redis.get(self._misses_key) or 0)
    total = hits + misses

    # Count cached queries (expensive for large caches)
    pattern = f'{self._prefix}*'
    size = 0
    cursor = 0
    while True:
        cursor, keys = self._redis.scan(cursor, match=pattern, count=100)
        size += len([k for k in keys if not k.endswith(':stats:hits') and not k.endswith(':stats:misses')])
        if cursor == 0:
            break
```

**–ü—Ä–æ–±–ª–µ–º–∞**: –ú–µ—Ç–æ–¥ `stats()` –≤—ã–ø–æ–ª–Ω—è–µ—Ç `SCAN` –≤—Å–µ–π –±–∞–∑—ã –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤. –≠—Ç–æ:
- –û—á–µ–Ω—å –¥–æ—Ä–æ–≥–æ—Å—Ç–æ—è—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –¥–ª—è –±–æ–ª—å—à–∏—Ö –∫—ç—à–µ–π
- –ë–ª–æ–∫–∏—Ä—É–µ—Ç Redis –Ω–∞ –≤—Ä–µ–º—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
- –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø—Ä–∏ —á–∞—Å—Ç—ã—Ö –≤—ã–∑–æ–≤–∞—Ö

**–†–µ—à–µ–Ω–∏–µ**: 
- –ù–µ —Å—á–∏—Ç–∞—Ç—å size, –≤–µ—Ä–Ω—É—Ç—å None –∏–ª–∏ 0
- –ò–ª–∏ —Ö—Ä–∞–Ω–∏—Ç—å —Å—á–µ—Ç—á–∏–∫ —Ä–∞–∑–º–µ—Ä–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –∫–ª—é—á–µ
- –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Redis `EVAL` Lua script

---

## ‚ö†Ô∏è –í–ê–ñ–ù–´–ï –ü–†–û–ë–õ–ï–ú–´

### 4. **–ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ application.py**

**–õ–æ–∫–∞—Ü–∏—è**: –ú–µ—Ç–æ–¥—ã `read`, `save`, `delete`, `entity_details`, `select`

–í—Å–µ –º–µ—Ç–æ–¥—ã –¥—É–±–ª–∏—Ä—É—é—Ç –ª–æ–≥–∏–∫—É —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞. –•–æ—Ç—è —Å–æ–∑–¥–∞–Ω –º–µ—Ç–æ–¥ `_prepare_operation()`, –º–µ—Ç–æ–¥ `select()` –≤—Å—ë —Ä–∞–≤–Ω–æ –¥—É–±–ª–∏—Ä—É–µ—Ç —ç—Ç—É –ª–æ–≥–∏–∫—É:

```299:349:src/namerec/uma/application.py
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        msg = "JSQL must contain 'from' field"
        raise ValueError(msg)

    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = self._create_context(entity.namespace, user_context)  # ‚Üê –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ

    # Check access
    self._check_access(str(entity), Operation.SELECT, context)  # ‚Üê –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
```

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –í—ã–Ω–µ—Å—Ç–∏ –æ–±—â—É—é –ª–æ–≥–∏–∫—É –≤ `_prepare_query_operation()` –∏–ª–∏ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `_prepare_operation()`.

---

### 5. **–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤**

–í –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞—Ö –∫–ª–∞—Å—Å–æ–≤ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:

```10:24:src/namerec/uma/jsql/cache/memory.py
@dataclass
class MemoryCacheBackend:
    """
    In-memory LRU cache backend (single process).
    """
    max_size: int = 128
```

–ü—Ä–æ–±–ª–µ–º–∞: –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å `max_size=0` –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –î–æ–±–∞–≤–∏—Ç—å `__post_init__()` –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏:

```python
def __post_init__(self):
    if self.max_size <= 0:
        raise ValueError("max_size must be positive")
```

---

### 6. **Race Conditions –≤ MemoryCacheBackend**

–í –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ (FastAPI/uvicorn) –∫—ç—à –Ω–µ –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–µ–Ω:

```31:41:src/namerec/uma/jsql/cache/memory.py
def get(self, key: str) -> CachedQuery | None:
    if key in self._cache:
        self._order.remove(key)  # ‚Üê Race condition!
        self._order.append(key)
```

–ü—Ä–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –¥–æ—Å—Ç—É–ø–µ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤ –≤–æ–∑–º–æ–∂–Ω—ã:
- ConcurrentModificationError
- –ü–æ—Ç–µ—Ä—è –¥–∞–Ω–Ω—ã—Ö
- –ù–µ–≤–µ—Ä–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ LRU

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `threading.RLock` –∏–ª–∏ `asyncio.Lock` –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞.

---

## ‚úÖ –•–û–†–û–®–ò–ï –†–ï–®–ï–ù–ò–Ø

### 7. **Protocol-based Cache Architecture**

–û—Ç–ª–∏—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ! –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `Protocol` –¥–ª—è `CacheBackend`:

```11:59:src/namerec/uma/jsql/cache/protocol.py
@runtime_checkable
class CacheBackend(Protocol):
    """
    Protocol for cache backends.

    Allows structural subtyping - any class implementing these methods
    can be used as a cache backend without explicit inheritance.
    """
```

**–ü–ª—é—Å—ã**:
- –îuck typing —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ç–∏–ø–æ–≤
- –õ–µ–≥–∫–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å custom backends
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ `isinstance()` –±–ª–∞–≥–æ–¥–∞—Ä—è `@runtime_checkable`

---

### 8. **O(1) Column Lookup Optimization**

–û—Ç–ª–∏—á–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤ `AliasManager`:

```9:210:src/namerec/uma/jsql/alias_manager.py
@dataclass
class AliasManager:
    """
    Manages table aliases and column index for JSQL/SQL conversion.

    Provides O(1) column lookup through indexing and consistent
    alias management across parser and converter modules.
    """
```

–ò–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ –≤ `_column_index` –¥–∞–µ—Ç O(1) lookup –≤–º–µ—Å—Ç–æ O(n) –ø–æ–∏—Å–∫–∞ –ø–æ –≤—Å–µ–º —Ç–∞–±–ª–∏—Ü–∞–º.

**–ü–ª—é—Å—ã**:
- –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ —Å JOIN
- –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–µ–≥–æ—Å—è –∫–æ–¥–∞ –≤ parser.py

---

### 9. **–ú–æ–¥—É–ª—è—Ä–∏–∑–∞—Ü–∏—è converter.py**

–û—Ç–ª–∏—á–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –º–æ–¥—É–ª–∏:
- `conditions.py` - WHERE, HAVING
- `expressions.py` - –≤—ã—Ä–∞–∂–µ–Ω–∏—è
- `joins.py` - JOIN
- `jsql_to_sql.py` - –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è JSQL ‚Üí SQL
- `sql_to_jsql.py` - –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è SQL ‚Üí JSQL
- `operators.py` - –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã

**–ü–ª—é—Å—ã**:
- SRP (Single Responsibility Principle)
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å
- –õ–µ–≥—á–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å

---

### 10. **–£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è**

–ó–∞–º–µ–Ω–∞ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –Ω–∞ –∫–ª–∞—Å—Å `UMA`:

```22:73:src/namerec/uma/application.py
@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.
    """
    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)
```

**–ü–ª—é—Å—ã**:
- Dependency Injection –≤–º–µ—Å—Ç–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
- –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø—Ä–æ—â–µ (–º–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ UMA –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤)
- Thread-safety

---

### 11. **Composition Pattern –≤ DefaultMetadataProvider**

–û—Ç–ª–∏—á–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏:

```18:291:src/namerec/uma/metadata/provider.py
class DefaultMetadataProvider:
    """
    Default metadata provider with lazy loading (composition pattern).

    This class is now a thin facade over specialized components:
    - MetadataCache: Manages caching of reflected schema
    - DatabaseReflector: Handles database reflection
    """
```

**–ü–ª—é—Å—ã**:
- SRP —Å–æ–±–ª—é–¥–µ–Ω
- –õ–µ–≥–∫–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å (–¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã)
- –õ–µ–≥–∫–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å (–º–æ–∫–∏ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤)

---

## üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê

| –ö–∞—Ç–µ–≥–æ—Ä–∏—è | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ | –°–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å |
|-----------|------------|-------------|
| –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã | 3 | üî¥ –í—ã—Å–æ–∫–∞—è |
| –í–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã | 3 | üü° –°—Ä–µ–¥–Ω—è—è |
| –•–æ—Ä–æ—à–∏–µ —Ä–µ—à–µ–Ω–∏—è | 5 | üü¢ –û—Ç–ª–∏—á–Ω–æ |

---

## üìã –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –ü–†–ò–û–†–ò–¢–ï–¢–ê–ú

### –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å:
1. **–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å access control** –≤ `application.py` - –ø—Ä–æ–±–ª–µ–º–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
2. **–ò—Å–ø—Ä–∞–≤–∏—Ç—å MemoryCacheBackend LRU** - –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
3. **–£–¥–∞–ª–∏—Ç—å dead code** –≤ `application.py`

### –í –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è:
4. –î–æ–±–∞–≤–∏—Ç—å thread-safety –¥–ª—è MemoryCacheBackend
5. –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å `stats()` –≤ RedisCacheBackend
6. –£—Å—Ç—Ä–∞–Ω–∏—Ç—å DRY –≤ `select()` –º–µ—Ç–æ–¥–µ

### –î–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–µ–ª–∏–∑–∞:
7. –î–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
8. –£–ª—É—á—à–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ
9. –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

---

## üéØ –ò–¢–û–ì–û–í–ê–Ø –û–¶–ï–ù–ö–ê

**–û–±—â–∞—è –æ—Ü–µ–Ω–∫–∞**: 7.5/10

**–°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã**:
- –û—Ç–ª–∏—á–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (Protocol, Composition)
- –•–æ—Ä–æ—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏ SOLID
- –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (O(1) column lookup)
- –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è

**–°–ª–∞–±—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã**:
- –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ access control
- –ü—Ä–æ–±–ª–µ–º—ã —Å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é LRU –∫—ç—à–∞
- –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –º–µ—Å—Ç–∞—Ö
- –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ thread-safety

**–í–µ—Ä–¥–∏–∫—Ç**: –ö–æ–¥ –≤ —Ü–µ–ª–æ–º –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å –æ—Ç–ª–∏—á–Ω—ã–º–∏ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–º–∏ —Ä–µ—à–µ–Ω–∏—è–º–∏, –Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –ø–µ—Ä–µ–¥ –º–µ—Ä–∂–µ–º –≤ main.

```python
def _check_access(
    self,
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """
    Check access and raise exception if access denied.

    Args:
        entity_name: Entity name
        operation: Operation name
        context: Execution context

    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)
```

```python
        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):
                raise UMAAccessDeniedError(entity_name, operation.value)
```

```python
def get(self, key: str) -> CachedQuery | None:
    """Get query from cache with LRU update."""
    if key in self._cache:
        # Move to end (most recently used)
        self._order.remove(key)  # ‚Üê O(n) –æ–ø–µ—Ä–∞—Ü–∏—è!
        self._order.append(key)
        self._hits += 1
        return self._cache[key]
```

```python
from collections import OrderedDict
@dataclass
class MemoryCacheBackend:
    def __init__(self, max_size: int = 128):
        self._cache: OrderedDict[str, CachedQuery] = OrderedDict()
        self._max_size = max_size
        self._hits = 0
        self._misses = 0
    
    def get(self, key: str) -> CachedQuery | None:
        if key in self._cache:
            self._cache.move_to_end(key)  # O(1)
            self._hits += 1
            return self._cache[key]
        self._misses += 1
        return None
```

```python
def stats(self) -> dict[str, Any]:
    """Get cache statistics from Redis."""
    hits = int(self._redis.get(self._hits_key) or 0)
    misses = int(self._redis.get(self._misses_key) or 0)
    total = hits + misses

    # Count cached queries (expensive for large caches)
    pattern = f'{self._prefix}*'
    size = 0
    cursor = 0
    while True:
        cursor, keys = self._redis.scan(cursor, match=pattern, count=100)
        size += len([k for k in keys if not k.endswith(':stats:hits') and not k.endswith(':stats:misses')])
        if cursor == 0:
            break
```

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        msg = "JSQL must contain 'from' field"
        raise ValueError(msg)

    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)

    # Create context for namespace
    context = self._create_context(entity.namespace, user_context)  # ‚Üê –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ

    # Check access
    self._check_access(str(entity), Operation.SELECT, context)  # ‚Üê –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
```

```python
@dataclass
class MemoryCacheBackend:
    """
    In-memory LRU cache backend (single process).
    """
    max_size: int = 128
```

```python
def __post_init__(self):
    if self.max_size <= 0:
        raise ValueError("max_size must be positive")
```

```python
def get(self, key: str) -> CachedQuery | None:
    if key in self._cache:
        self._order.remove(key)  # ‚Üê Race condition!
        self._order.append(key)
```

```python
@runtime_checkable
class CacheBackend(Protocol):
    """
    Protocol for cache backends.

    Allows structural subtyping - any class implementing these methods
    can be used as a cache backend without explicit inheritance.
    """
```

```python
@dataclass
class AliasManager:
    """
    Manages table aliases and column index for JSQL/SQL conversion.

    Provides O(1) column lookup through indexing and consistent
    alias management across parser and converter modules.
    """
```

```python
@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.
    """
    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)
```

```python
class DefaultMetadataProvider:
    """
    Default metadata provider with lazy loading (composition pattern).

    This class is now a thin facade over specialized components:
    - MetadataCache: Manages caching of reflected schema
    - DatabaseReflector: Handles database reflection
    """
```

---

**User**

(20260115-030356)
> –ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è: –°–∏—Å—Ç–µ–º–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è –¥–æ—Å—Ç—É–ø–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ—Ä–∞–±–æ—á–∞—è. –õ—é–±–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –ª—é–±—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏.
> –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –ª–æ–≥–∏–∫—É –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –≤ _check_access() –∏ —É–¥–∞–ª–∏—Ç—å –º–µ—Ä—Ç–≤—ã–π –∫–æ–¥.

–ñ–µ—Å—Ç—å –∫–∞–∫–∞—è... –ò—Å–ø—Ä–∞–≤—å –∫–æ–Ω–µ—á–Ω–æ —Ç–∞–∫, –∫–∞–∫ —Ç—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ—à—å.

(20260115-030744)
> 2. Algorithmic Painter Problem –≤ src/namerec/uma/jsql/cache/memory.py
> ... ... ...
> –†–µ—à–µ–Ω–∏–µ: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å collections.OrderedDict –∏–ª–∏ doubly-linked list + dict:

–í—ã–≥–ª—è–¥–∏—Ç –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ. –î–∞–≤–∞–π –ø–æ–ø—Ä–æ–±—É–µ–º —Å–¥–µ–ª–∞—Ç—å —Ç–∞–∫, –∫–∞–∫ —Ç—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ—à—å, –Ω–æ –ø—Ä–æ—à—É —Ç–µ–±—è —Ç—â–∞—Ç–µ–ª—å–Ω–æ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥.

(20260115-031218)
> 3. –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤ Redis cache stats –≤ src/namerec/uma/jsql/cache/redis.py

–î–∞, —Ñ–æ—Ä–º–∞–ª—å–Ω–æ —Ç—ã –ø—Ä–∞–≤. –ù–µ –ø—Ä–∏–¥–µ—Ä—ë—à—å—Å—è.
–ù–æ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–∏–≥–¥–µ –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è, –∞ –≤—ã–∑—ã–≤–∞—Ç—å –µ—ë –±—É–¥—É—Ç –∏–∑ backend, –¥–∞ –∏ —Ç–æ–ª—å–∫–æ –≤ –æ—Ç–ª–∞–¥–æ—á–Ω—ã—Ö —Ü–µ–ª—è—Ö, –ª–∏–±–æ –≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö, –Ω–æ —Ä–µ–¥–∫–æ.
–ü–æ–¥—Å–∫–∞–∂–∏: —Ç—ã –≤–∏–¥–∏—à—å —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π —Å–ø–æ—Å–æ–±, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª–∏—Ç –≤—ã—á–∏—Å–ª–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤?
–ï—Å–ª–∏ —Ç–∞–∫–æ–π —Å–ø–æ—Å–æ–± –Ω–µ –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è, –¥—É–º–∞—é, –Ω–∞—Å —Å–µ–π—á–∞—Å —É—Å—Ç—Ä–æ–∏—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥–µ—Ç —É–∫–∞–∑–∞–Ω–æ, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –æ–±—â–µ–º —Å–ª—É—á–∞–µ –¥–æ–ª–≥–æ, –±–ª–æ–∫–∏—Ä—É–µ—Ç –ë–î, –∏ –µ—ë —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –≤ –æ—Ç–ª–∞–¥–æ—á–Ω—ã—Ö —Ü–µ–ª—è—Ö.

(20260115-032621)
> 4. –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ application.py
> –õ–æ–∫–∞—Ü–∏—è: –ú–µ—Ç–æ–¥—ã read, save, delete, entity_details, select
> –í—Å–µ –º–µ—Ç–æ–¥—ã –¥—É–±–ª–∏—Ä—É—é—Ç –ª–æ–≥–∏–∫—É —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞. –•–æ—Ç—è —Å–æ–∑–¥–∞–Ω –º–µ—Ç–æ–¥ _prepare_operation(), –º–µ—Ç–æ–¥ select() –≤—Å—ë —Ä–∞–≤–Ω–æ –¥—É–±–ª–∏—Ä—É–µ—Ç —ç—Ç—É –ª–æ–≥–∏–∫—É:

–°–º–æ—Ç—Ä–∏, –≤ —Å–ª—É—á–∞–µ `select` —Å–∏—Ç—É–∞—Ü–∏—è —Ç–æ–Ω—å—à–µ, –∏ —Å–ª–æ–∂–Ω–µ–µ.
–î–µ–ª–æ –≤ —Ç–æ–º, —á—Ç–æ –≤ —Å–ª—É—á–∞–µ `select` –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ø–æ–ª–Ω–æ–º–æ—á–∏—è –Ω–µ —Ç–æ–ª—å–∫–æ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–π —Å—É—â–Ω–æ—Å—Ç–∏, –∫–æ—Ç–æ—Ä–∞—è —É–∫–∞–∑–∞–Ω–∞ –≤–æ FROM (–∫—Å—Ç–∞—Ç–∏, —ç—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è —Å–µ–π—á–∞—Å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ, –ø–æ—Å–∫–æ–ª—å–∫—É —Ç–∞–º –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ –∏–º—è —Ç–∞–±–ª–∏—Ü—ã, –∞ CTE ‚Äì –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ –∏–º—è –æ—Å–Ω–æ–≤–Ω–æ–π —Å—É—â–Ω–æ—Å—Ç–∏ —Å–ª–µ–¥—É–µ—Ç –≤—ã—á–∏—Å–ª–∏—Ç—å –∏–∑ CTE), –Ω–æ –≤–æ–æ–±—â–µ –≤—Å–µ—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π, –∫–æ–ª–æ–Ω–∫–∏ –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –ø–æ–ø–∞–¥–∞—é—Ç –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø—Ä–æ—Å–∞. 
–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–µ–¥–ª–æ–∂–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ.

(20260115-033011)
> 5. –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
> –í –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞—Ö –∫–ª–∞—Å—Å–æ–≤ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:

–ü—Ä–∏–Ω–∏–º–∞–µ—Ç—Å—è. –ù—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å.

(20260115-033051)
> 6. Race Conditions –≤ MemoryCacheBackend
> –í –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ (FastAPI/uvicorn) –∫—ç—à –Ω–µ –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–µ–Ω:
> ... ... ...
> –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å threading.RLock –∏–ª–∏ asyncio.Lock –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞.

–î–∞, —ç—Ç–æ —Ç–æ–∂–µ –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å.

(20260115-033247) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ, –¥–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º –≤—Å–µ –ø—Ä–æ–±–ª–µ–º—ã. –ù–∞—á–Ω—É —Å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö.

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Extract entity_name from JSQL
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)

        # Parse entity name to extract namespace
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), Operation.SELECT, context)

        # Execute JSQL query with caching
        executor = JSQLExecutor(
            context,
            cache_backend=self.cache_backend,
            cache_enabled=self.cache_enabled,
        )
        result = await executor.execute(jsql, params)

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""In-memory LRU cache backend."""

import threading
from collections import OrderedDict
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.jsql.cache.keys import CachedQuery


@dataclass
class MemoryCacheBackend:
    """
    In-memory LRU cache backend (single process).

    Suitable for:
    - Development and testing
    - Single-process deployments
    - When Redis is not available

    Not suitable for:
    - Multi-process deployments (uvicorn workers)
    - Distributed systems (k8s pods)

    Thread-safe: Yes (uses RLock for concurrent access)
    """

    max_size: int = 128
    _cache: OrderedDict[str, CachedQuery] = field(default_factory=OrderedDict, init=False)
    _hits: int = field(default=0, init=False)
    _misses: int = field(default=0, init=False)
    _lock: threading.RLock = field(default_factory=threading.RLock, init=False)

    def __post_init__(self) -> None:
        """Validate initialization parameters."""
        if self.max_size <= 0:
            msg = 'max_size must be positive integer'
            raise ValueError(msg)

    def get(self, key: str) -> CachedQuery | None:
        """Get query from cache with LRU update (O(1))."""
        with self._lock:
            if key in self._cache:
                # Move to end (most recently used) - O(1) with OrderedDict
                self._cache.move_to_end(key)
                self._hits += 1
                return self._cache[key]

            self._misses += 1
            return None

    def set(self, key: str, query: CachedQuery, ttl: int | None = None) -> None:
        """Store query in cache with LRU eviction (O(1))."""
        # TTL parameter is ignored for in-memory cache (kept for API compatibility)
        del ttl

        with self._lock:
            # Evict oldest if cache full and key is new
            if key not in self._cache and len(self._cache) >= self.max_size:
                self._cache.popitem(last=False)  # Remove first (least recently used) - O(1)

            # Update or add (moves to end automatically if exists)
            self._cache[key] = query

    def clear(self) -> None:
        """Clear all cache."""
        with self._lock:
            self._cache.clear()
            self._hits = 0
            self._misses = 0

    def stats(self) -> dict[str, Any]:
        """Get cache statistics."""
        with self._lock:
            total = self._hits + self._misses
            return {
                'backend': 'memory',
                'size': len(self._cache),
                'max_size': self.max_size,
                'hits': self._hits,
                'misses': self._misses,
                'hit_rate': self._hits / total if total > 0 else 0.0,
            }

```

```python
"""Redis cache backend for distributed deployments."""

from typing import Any

from namerec.uma.jsql.cache.keys import CachedQuery


class RedisCacheBackend:
    """
    Redis cache backend (multi-process, multi-container).

    Suitable for:
    - Production deployments
    - Multi-process servers (uvicorn workers)
    - Distributed systems (k8s pods)
    - When query cache needs to be shared across instances

    Requires:
    - redis package (install with: pip install redis)
    - Running Redis instance
    """

    def __init__(
        self,
        redis_url: str = 'redis://localhost:6379/0',
        prefix: str = 'uma:jsql:',
        default_ttl: int = 3600,
    ) -> None:
        """
        Initialize Redis cache.

        Args:
            redis_url: Redis connection URL
            prefix: Key prefix for namespacing
            default_ttl: Default TTL in seconds (1 hour)

        Raises:
            ImportError: If redis package not installed
        """
        try:
            import redis
        except ImportError as e:
            msg = 'redis package required for RedisCacheBackend. Install with: pip install redis'
            raise ImportError(msg) from e

        self._redis = redis.from_url(redis_url, decode_responses=True)
        self._prefix = prefix
        self._default_ttl = default_ttl

        # Stats keys (separate from cached queries)
        self._hits_key = f'{prefix}stats:hits'
        self._misses_key = f'{prefix}stats:misses'

    def get(self, key: str) -> CachedQuery | None:
        """Get query from Redis."""
        import json

        full_key = f'{self._prefix}{key}'
        data = self._redis.get(full_key)

        if data:
            self._redis.incr(self._hits_key)
            return CachedQuery.from_dict(json.loads(data))

        self._redis.incr(self._misses_key)
        return None

    def set(self, key: str, query: CachedQuery, ttl: int | None = None) -> None:
        """Store query in Redis with TTL."""
        import json

        full_key = f'{self._prefix}{key}'
        ttl = ttl or self._default_ttl

        self._redis.setex(
            full_key,
            ttl,
            json.dumps(query.to_dict()),
        )

    def clear(self) -> None:
        """Clear all UMA cache keys."""
        pattern = f'{self._prefix}*'
        # Use cursor-based scan for safe deletion
        cursor = 0
        while True:
            cursor, keys = self._redis.scan(cursor, match=pattern, count=100)
            if keys:
                self._redis.delete(*keys)
            if cursor == 0:
                break

    def stats(self) -> dict[str, Any]:
        """
        Get cache statistics from Redis.

        WARNING: This method performs a full SCAN operation to count cached queries,
        which can be expensive and block the Redis server for large caches.
        Use only for debugging or monitoring purposes, NOT in production hot paths.

        For production monitoring, consider:
        - Using Redis INFO command for approximate statistics
        - Implementing a dedicated size counter key (updated on set/delete)
        - Using Redis monitoring tools (RedisInsight, prometheus-redis-exporter)
        """
        hits = int(self._redis.get(self._hits_key) or 0)
        misses = int(self._redis.get(self._misses_key) or 0)
        total = hits + misses

        # Count cached queries (expensive for large caches)
        # WARNING: Full SCAN - slow for large databases, use sparingly!
        pattern = f'{self._prefix}*'
        size = 0
        cursor = 0
        while True:
            cursor, keys = self._redis.scan(cursor, match=pattern, count=100)
            size += len([k for k in keys if not k.endswith(':stats:hits') and not k.endswith(':stats:misses')])
            if cursor == 0:
                break

        return {
            'backend': 'redis',
            'size': size,
            'hits': hits,
            'misses': misses,
            'hit_rate': hits / total if total > 0 else 0.0,
            'redis_url': self._redis.connection_pool.connection_kwargs.get('host', 'unknown'),
        }

```

–¢–µ–ø–µ—Ä—å —Å–∞–º–æ–µ —Å–ª–æ–∂–Ω–æ–µ - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –≤ `select()`. –ú–Ω–µ –Ω—É–∂–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É JSQL –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤—Å–µ—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π:

–¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–º –º–µ—Ç–æ–¥ –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤—Å–µ—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–∑ JSQL –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞:

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Extract entity_name from JSQL
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)

        # Parse entity name to extract namespace
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Extract all entities from JSQL (including CTEs, joins)
        entities_to_check = self._extract_entities_from_jsql(jsql)

        # Check access for all entities
        for entity_name_to_check in entities_to_check:
            self._check_access(entity_name_to_check, Operation.SELECT, context)

        # Execute JSQL query with caching
        executor = JSQLExecutor(
            context,
            cache_backend=self.cache_backend,
            cache_enabled=self.cache_enabled,
        )
        result = await executor.execute(jsql, params)

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Extract entity_name from JSQL
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)

        # Parse entity name to extract namespace
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Extract all entities from JSQL (including CTEs, joins)
        entities_to_check = self._extract_entities_from_jsql(jsql)

        # Check access for all entities
        for entity_name_to_check in entities_to_check:
            self._check_access(entity_name_to_check, Operation.SELECT, context)

        # Execute JSQL query with caching
        executor = JSQLExecutor(
            context,
            cache_backend=self.cache_backend,
            cache_enabled=self.cache_enabled,
        )
        result = await executor.execute(jsql, params)

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _extract_entities_from_jsql(self, jsql: dict[str, Any]) -> set[str]:
        """
        Extract all entity names from JSQL query for access control.

        Recursively extracts entities from:
        - FROM clause
        - WITH clause (CTEs)
        - JOIN clauses
        - Subqueries

        Args:
            jsql: JSQL query dictionary

        Returns:
            Set of entity names (qualified with namespace if present)

        Note:
            This is a conservative extraction - it may include entities that
            are not directly queried (e.g., in expressions), but this is
            safer for access control.
        """
        entities: set[str] = set()

        # Extract FROM entity
        if from_entity := jsql.get('from'):
            if isinstance(from_entity, str):
                entities.add(from_entity)
            elif isinstance(from_entity, dict):
                # Handle subquery in FROM
                entities.update(self._extract_entities_from_jsql(from_entity))

        # Extract CTEs (WITH clause)
        if with_clauses := jsql.get('with'):
            for cte_name, cte_def in with_clauses.items():
                # CTE definition may reference other entities
                if isinstance(cte_def, dict):
                    entities.update(self._extract_entities_from_jsql(cte_def))

        # Extract JOINs
        if joins := jsql.get('joins'):
            for join in joins:
                if isinstance(join, dict):
                    # Extract join table
                    if join_table := join.get('table'):
                        if isinstance(join_table, str):
                            entities.add(join_table)
                        elif isinstance(join_table, dict):
                            # Subquery in join
                            entities.update(self._extract_entities_from_jsql(join_table))

                    # Extract entities from ON clause
                    if on_clause := join.get('on'):
                        if isinstance(on_clause, dict):
                            entities.update(self._extract_entities_from_expression(on_clause))

        # Extract entities from WHERE, HAVING, GROUP_BY, ORDER_BY
        for clause in ['where', 'having', 'group_by', 'order_by']:
            if clause_data := jsql.get(clause):
                if isinstance(clause_data, dict):
                    entities.update(self._extract_entities_from_expression(clause_data))
                elif isinstance(clause_data, list):
                    for item in clause_data:
                        if isinstance(item, dict):
                            entities.update(self._extract_entities_from_expression(item))

        # Extract entities from SELECT clause
        if select_clause := jsql.get('select'):
            if isinstance(select_clause, list):
                for select_item in select_clause:
                    if isinstance(select_item, dict):
                        entities.update(self._extract_entities_from_expression(select_item))

        return entities

    def _extract_entities_from_expression(self, expr: dict[str, Any]) -> set[str]:
        """
        Extract entity names from JSQL expression.

        Recursively processes:
        - Field references
        - Function calls
        - Operators
        - Subqueries

        Args:
            expr: JSQL expression dictionary

        Returns:
            Set of entity names
        """
        entities: set[str] = set()

        # Field reference
        if field := expr.get('field'):
            if isinstance(field, str):
                # Extract entity from qualified field (table.column)
                if '.' in field:
                    entity_part = field.split('.', 1)[0]
                    # Skip if it's a function or special value
                    if not entity_part.isupper():
                        entities.add(entity_part)
            elif isinstance(field, dict):
                entities.update(self._extract_entities_from_expression(field))

        # Function call
        if 'func' in expr:
            if args := expr.get('args'):
                if isinstance(args, list):
                    for arg in args:
                        if isinstance(arg, dict):
                            entities.update(self._extract_entities_from_expression(arg))
                elif isinstance(args, dict):
                    entities.update(self._extract_entities_from_expression(args))

        # Binary operator
        if 'left' in expr and 'right' in expr:
            if isinstance(expr['left'], dict):
                entities.update(self._extract_entities_from_expression(expr['left']))
            if isinstance(expr['right'], dict):
                entities.update(self._extract_entities_from_expression(expr['right']))

        # Subquery
        if 'subquery' in expr:
            if isinstance(expr['subquery'], dict):
                entities.update(self._extract_entities_from_jsql(expr['subquery']))

        # Expression
        if 'expr' in expr:
            if isinstance(expr['expr'], dict):
                entities.update(self._extract_entities_from_expression(expr['expr']))

        return entities

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–±–æ—Ç–∞—é—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ:

–ï—Å—Ç—å –æ—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ CTE. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–µ—Å—Ç–∞:

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Extract entity_name from JSQL
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)

        # Parse entity name to extract namespace
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Extract all entities from JSQL (including CTEs, joins)
        entities_to_check = self._extract_entities_from_jsql(jsql)

        # Check access for all entities
        for entity_name_to_check in entities_to_check:
            self._check_access(entity_name_to_check, Operation.SELECT, context)

        # Execute JSQL query with caching
        executor = JSQLExecutor(
            context,
            cache_backend=self.cache_backend,
            cache_enabled=self.cache_enabled,
        )
        result = await executor.execute(jsql, params)

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _extract_entities_from_jsql(self, jsql: dict[str, Any]) -> set[str]:
        """
        Extract all entity names from JSQL query for access control.

        Recursively extracts entities from:
        - FROM clause
        - WITH clause (CTEs)
        - JOIN clauses
        - Subqueries

        Args:
            jsql: JSQL query dictionary

        Returns:
            Set of entity names (qualified with namespace if present)

        Note:
            This is a conservative extraction - it may include entities that
            are not directly queried (e.g., in expressions), but this is
            safer for access control.
        """
        entities: set[str] = set()

        # Extract FROM entity
        if from_entity := jsql.get('from'):
            if isinstance(from_entity, str):
                entities.add(from_entity)
            elif isinstance(from_entity, dict):
                # Handle subquery in FROM
                entities.update(self._extract_entities_from_jsql(from_entity))

        # Extract CTEs (WITH clause)
        # CTE can be either list of dicts [{'name': 'cte1', 'query': {...}}]
        # or dict of named CTEs {'cte1': {...}}
        if with_clauses := jsql.get('with'):
            if isinstance(with_clauses, list):
                for cte in with_clauses:
                    if isinstance(cte, dict):
                        # Extract from CTE definition
                        if cte_query := cte.get('query'):
                            if isinstance(cte_query, dict):
                                entities.update(self._extract_entities_from_jsql(cte_query))
                        # Add CTE name as an entity to check
                        if cte_name := cte.get('name'):
                            entities.add(cte_name)
            elif isinstance(with_clauses, dict):
                for cte_def in with_clauses.values():
                    if isinstance(cte_def, dict):
                        entities.update(self._extract_entities_from_jsql(cte_def))

        # Extract JOINs
        if joins := jsql.get('joins'):
            for join in joins:
                if isinstance(join, dict):
                    # Extract join table
                    if join_table := join.get('table'):
                        if isinstance(join_table, str):
                            entities.add(join_table)
                        elif isinstance(join_table, dict):
                            # Subquery in join
                            entities.update(self._extract_entities_from_jsql(join_table))

                    # Extract entities from ON clause
                    if on_clause := join.get('on'):
                        if isinstance(on_clause, dict):
                            entities.update(self._extract_entities_from_expression(on_clause))

        # Extract entities from WHERE, HAVING, GROUP_BY, ORDER_BY
        for clause in ['where', 'having', 'group_by', 'order_by']:
            if clause_data := jsql.get(clause):
                if isinstance(clause_data, dict):
                    entities.update(self._extract_entities_from_expression(clause_data))
                elif isinstance(clause_data, list):
                    for item in clause_data:
                        if isinstance(item, dict):
                            entities.update(self._extract_entities_from_expression(item))

        # Extract entities from SELECT clause
        if select_clause := jsql.get('select'):
            if isinstance(select_clause, list):
                for select_item in select_clause:
                    if isinstance(select_item, dict):
                        entities.update(self._extract_entities_from_expression(select_item))

        return entities

    def _extract_entities_from_expression(self, expr: dict[str, Any]) -> set[str]:
        """
        Extract entity names from JSQL expression.

        Recursively processes:
        - Field references
        - Function calls
        - Operators
        - Subqueries

        Args:
            expr: JSQL expression dictionary

        Returns:
            Set of entity names
        """
        entities: set[str] = set()

        # Field reference
        if field := expr.get('field'):
            if isinstance(field, str):
                # Extract entity from qualified field (table.column)
                if '.' in field:
                    entity_part = field.split('.', 1)[0]
                    # Skip if it's a function or special value
                    if not entity_part.isupper():
                        entities.add(entity_part)
            elif isinstance(field, dict):
                entities.update(self._extract_entities_from_expression(field))

        # Function call
        if 'func' in expr:
            if args := expr.get('args'):
                if isinstance(args, list):
                    for arg in args:
                        if isinstance(arg, dict):
                            entities.update(self._extract_entities_from_expression(arg))
                elif isinstance(args, dict):
                    entities.update(self._extract_entities_from_expression(args))

        # Binary operator
        if 'left' in expr and 'right' in expr:
            if isinstance(expr['left'], dict):
                entities.update(self._extract_entities_from_expression(expr['left']))
            if isinstance(expr['right'], dict):
                entities.update(self._extract_entities_from_expression(expr['right']))

        # Subquery
        if 'subquery' in expr:
            if isinstance(expr['subquery'], dict):
                entities.update(self._extract_entities_from_jsql(expr['subquery']))

        # Expression
        if 'expr' in expr:
            if isinstance(expr['expr'], dict):
                entities.update(self._extract_entities_from_expression(expr['expr']))

        return entities

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Extract entity_name from JSQL
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)

        # Parse entity name to extract namespace
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Extract all entities from JSQL (including CTEs, joins)
        entities_to_check = self._extract_entities_from_jsql(jsql)

        # Check access for all entities
        for entity_name_to_check in entities_to_check:
            self._check_access(entity_name_to_check, Operation.SELECT, context)

        # Execute JSQL query with caching
        executor = JSQLExecutor(
            context,
            cache_backend=self.cache_backend,
            cache_enabled=self.cache_enabled,
        )
        result = await executor.execute(jsql, params)

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _extract_entities_from_jsql(self, jsql: dict[str, Any]) -> set[str]:
        """
        Extract all entity names from JSQL query for access control.

        Recursively extracts entities from:
        - FROM clause
        - WITH clause (CTEs)
        - JOIN clauses
        - Subqueries

        Args:
            jsql: JSQL query dictionary

        Returns:
            Set of entity names (qualified with namespace if present)

        Note:
            This is a conservative extraction - it may include entities that
            are not directly queried (e.g., in expressions), but this is
            safer for access control.
        """
        entities: set[str] = set()

        # Extract FROM entity
        if from_entity := jsql.get('from'):
            if isinstance(from_entity, str):
                entities.add(from_entity)
            elif isinstance(from_entity, dict):
                # Handle subquery in FROM
                entities.update(self._extract_entities_from_jsql(from_entity))

        # Extract CTEs (WITH clause)
        # CTE can be either list of dicts [{'name': 'cte1', 'query': {...}}]
        # or dict of named CTEs {'cte1': {...}}
        # Note: CTEs themselves don't need access control (they're query definitions),
        # but we need to check access to entities used in CTE definitions
        if with_clauses := jsql.get('with'):
            if isinstance(with_clauses, list):
                for cte in with_clauses:
                    if isinstance(cte, dict):
                        # Extract from CTE definition
                        if cte_query := cte.get('query'):
                            if isinstance(cte_query, dict):
                                entities.update(self._extract_entities_from_jsql(cte_query))
            elif isinstance(with_clauses, dict):
                for cte_def in with_clauses.values():
                    if isinstance(cte_def, dict):
                        entities.update(self._extract_entities_from_jsql(cte_def))

        # Extract JOINs
        if joins := jsql.get('joins'):
            for join in joins:
                if isinstance(join, dict):
                    # Extract join table
                    if join_table := join.get('table'):
                        if isinstance(join_table, str):
                            entities.add(join_table)
                        elif isinstance(join_table, dict):
                            # Subquery in join
                            entities.update(self._extract_entities_from_jsql(join_table))

                    # Extract entities from ON clause
                    if on_clause := join.get('on'):
                        if isinstance(on_clause, dict):
                            entities.update(self._extract_entities_from_expression(on_clause))

        # Extract entities from WHERE, HAVING, GROUP_BY, ORDER_BY
        for clause in ['where', 'having', 'group_by', 'order_by']:
            if clause_data := jsql.get(clause):
                if isinstance(clause_data, dict):
                    entities.update(self._extract_entities_from_expression(clause_data))
                elif isinstance(clause_data, list):
                    for item in clause_data:
                        if isinstance(item, dict):
                            entities.update(self._extract_entities_from_expression(item))

        # Extract entities from SELECT clause
        if select_clause := jsql.get('select'):
            if isinstance(select_clause, list):
                for select_item in select_clause:
                    if isinstance(select_item, dict):
                        entities.update(self._extract_entities_from_expression(select_item))

        return entities

    def _extract_entities_from_expression(self, expr: dict[str, Any]) -> set[str]:
        """
        Extract entity names from JSQL expression.

        Recursively processes:
        - Field references
        - Function calls
        - Operators
        - Subqueries

        Args:
            expr: JSQL expression dictionary

        Returns:
            Set of entity names
        """
        entities: set[str] = set()

        # Field reference
        if field := expr.get('field'):
            if isinstance(field, str):
                # Extract entity from qualified field (table.column)
                if '.' in field:
                    entity_part = field.split('.', 1)[0]
                    # Skip if it's a function or special value
                    if not entity_part.isupper():
                        entities.add(entity_part)
            elif isinstance(field, dict):
                entities.update(self._extract_entities_from_expression(field))

        # Function call
        if 'func' in expr:
            if args := expr.get('args'):
                if isinstance(args, list):
                    for arg in args:
                        if isinstance(arg, dict):
                            entities.update(self._extract_entities_from_expression(arg))
                elif isinstance(args, dict):
                    entities.update(self._extract_entities_from_expression(args))

        # Binary operator
        if 'left' in expr and 'right' in expr:
            if isinstance(expr['left'], dict):
                entities.update(self._extract_entities_from_expression(expr['left']))
            if isinstance(expr['right'], dict):
                entities.update(self._extract_entities_from_expression(expr['right']))

        # Subquery
        if 'subquery' in expr:
            if isinstance(expr['subquery'], dict):
                entities.update(self._extract_entities_from_jsql(expr['subquery']))

        # Expression
        if 'expr' in expr:
            if isinstance(expr['expr'], dict):
                entities.update(self._extract_entities_from_expression(expr['expr']))

        return entities

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

–û—Ç–ª–∏—á–Ω–æ! –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç –∏ –Ω–µ—Ç linting –æ—à–∏–±–æ–∫. –î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–º –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º:

–û—Ç–ª–∏—á–Ω–æ! –í—Å–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω—ã –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã. –ü–æ–¥–≤–µ–¥—É –∏—Ç–æ–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π:

## ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

### 1. **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞: Broken Access Control** –≤ `application.py`

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ**: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –≤ –º–µ—Ç–æ–¥–µ `_check_access()` (—Å—Ç—Ä–æ–∫–∏ 460-479)

```460:479:src/namerec/uma/application.py
def _check_access(
    self,
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """..."""
    if isinstance(operation, str):
        operation = Operation(operation)

    # Check if metadata provider has can() method
    if hasattr(context.metadata_provider, 'can'):
        if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
            raise UMAAccessDeniedError(entity_name, operation.value)
```

–£–¥–∞–ª–µ–Ω –º–µ—Ä—Ç–≤—ã–π –∫–æ–¥ (—Å—Ç—Ä–æ–∫–∏ 552-555 –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ).

---

### 2. **Algorithmic Painter Problem** –≤ `memory.py`

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ**: –ó–∞–º–µ–Ω–µ–Ω list + remove() –Ω–∞ `OrderedDict` —Å –º–µ—Ç–æ–¥–∞–º–∏ `move_to_end()` –∏ `popitem(last=False)`:

```10:76:src/namerec/uma/jsql/cache/memory.py
@dataclass
class MemoryCacheBackend:
    """
    In-memory LRU cache backend (single process).
    ...
    Thread-safe: Yes (uses RLock for concurrent access)
    """

    max_size: int = 128
    _cache: OrderedDict[str, CachedQuery] = field(default_factory=OrderedDict, init=False)
    _hits: int = field(default=0, init=False)
    _misses: int = field(default=0, init=False)
    _lock: threading.RLock = field(default_factory=threading.RLock, init=False)

    def get(self, key: str) -> CachedQuery | None:
        """Get query from cache with LRU update (O(1))."""
        with self._lock:
            if key in self._cache:
                self._cache.move_to_end(key)  # O(1)
                self._hits += 1
                return self._cache[key]
            self._misses += 1
            return None

    def set(self, key: str, query: CachedQuery, ttl: int | None = None) -> None:
        """Store query in cache with LRU eviction (O(1))."""
        with self._lock:
            if key not in self._cache and len(self._cache) >= self.max_size:
                self._cache.popitem(last=False)  # O(1)
            self._cache[key] = query
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç**: O(1) –≤–º–µ—Å—Ç–æ O(n), thread-safe —á–µ—Ä–µ–∑ `RLock`.

---

### 3. **–ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å Redis stats()** –≤ `redis.py`

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ**: –î–æ–±–∞–≤–ª–µ–Ω –ø–æ–¥—Ä–æ–±–Ω—ã–π WARNING –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:

```93:119:src/namerec/uma/jsql/cache/redis.py
def stats(self) -> dict[str, Any]:
    """
    Get cache statistics from Redis.

    WARNING: This method performs a full SCAN operation to count cached queries,
    which can be expensive and block the Redis server for large caches.
    Use only for debugging or monitoring purposes, NOT in production hot paths.

    For production monitoring, consider:
    - Using Redis INFO command for approximate statistics
    - Implementing a dedicated size counter key (updated on set/delete)
    - Using Redis monitoring tools (RedisInsight, prometheus-redis-exporter)
    """
```

---

### 4. **–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –≤ select()** 

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ**: –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `_extract_entities_from_jsql()` –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≤—Å–µ—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π:

```464:509:src/namerec/uma/application.py
def _extract_entities_from_jsql(self, jsql: dict[str, Any]) -> set[str]:
    """
    Extract all entity names from JSQL query for access control.

    Recursively extracts entities from:
    - FROM clause
    - WITH clause (CTEs)
    - JOIN clauses
    - Subqueries
    ...
    """
```

–ú–µ—Ç–æ–¥ –∏–∑–≤–ª–µ–∫–∞–µ—Ç –≤—Å–µ —Å—É—â–Ω–æ—Å—Ç–∏ –∏–∑:
- FROM (–≤–∫–ª—é—á–∞—è –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã)
- WITH clause (CTEs - –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç–æ–ª—å–∫–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å—ã –≤–Ω—É—Ç—Ä–∏ CTE)
- JOIN clauses (—Ç–∞–±–ª–∏—Ü—ã + ON clauses)
- WHERE, HAVING, GROUP_BY, ORDER_BY, SELECT clauses

–ú–µ—Ç–æ–¥ `select()` —Ç–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Å—É—â–Ω–æ—Å—Ç—è–º:

```329:340:src/namerec/uma/application.py
# Extract all entities from JSQL (including CTEs, joins)
entities_to_check = self._extract_entities_from_jsql(jsql)

# Check access for all entities
for entity_name_to_check in entities_to_check:
    self._check_access(entity_name_to_check, Operation.SELECT, context)
```

---

### 5. **–í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤** –≤ `memory.py` –∏ `redis.py`

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ**: –î–æ–±–∞–≤–ª–µ–Ω `__post_init__()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ `max_size`:

```29:35:src/namerec/uma/jsql/cache/memory.py
def __post_init__(self) -> None:
    """Validate initialization parameters."""
    if self.max_size <= 0:
        msg = 'max_size must be positive integer'
        raise ValueError(msg)
```

---

### 6. **Thread-safety** –≤ `MemoryCacheBackend`

**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ**: –î–æ–±–∞–≤–ª–µ–Ω `threading.RLock` –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç race conditions:

```17:38:src/namerec/uma/jsql/cache/memory.py
_lock: threading.RLock = field(default_factory=threading.RLock, init=False)

def get(self, key: str) -> CachedQuery | None:
    """Get query from cache with LRU update (O(1))."""
    with self._lock:
        # ... –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø ...
```

–í—Å–µ –º–µ—Ç–æ–¥—ã (`get`, `set`, `clear`, `stats`) –∑–∞—â–∏—â–µ–Ω—ã –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π.

---

## üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

```
============================== 72 passed in 0.69s ==============================
```

‚úÖ –í—Å–µ 72 —Ç–µ—Å—Ç–∞ –ø—Ä–æ—Ö–æ–¥—è—Ç  
‚úÖ –ù–µ—Ç linting –æ—à–∏–±–æ–∫

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞

–í—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏ –≤–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –∏–∑ code review –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã:

| –ü—Ä–æ–±–ª–µ–º–∞ | –°—Ç–∞—Ç—É—Å | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|-----------|---------|-----------|
| Broken access control | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –í—ã—Å–æ–∫–∞—è |
| Algorithmic Painter (O(n) LRU) | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –í—ã—Å–æ–∫–∞—è |
| –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π Redis stats | ‚úÖ –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ | –°—Ä–µ–¥–Ω—è—è |
| –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –≤ select() | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –í—ã—Å–æ–∫–∞—è |
| –ù–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –ù–∏–∑–∫–∞—è |
| Race conditions | ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ | –°—Ä–µ–¥–Ω—è—è |

**–ö–æ–¥ –≥–æ—Ç–æ–≤ –∫ –º–µ—Ä–∂—É –≤ main.**

```python
def _check_access(
    self,
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """..."""
    if isinstance(operation, str):
        operation = Operation(operation)

    # Check if metadata provider has can() method
    if hasattr(context.metadata_provider, 'can'):
        if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
            raise UMAAccessDeniedError(entity_name, operation.value)
```

```python
@dataclass
class MemoryCacheBackend:
    """
    In-memory LRU cache backend (single process).
    ...
    Thread-safe: Yes (uses RLock for concurrent access)
    """

    max_size: int = 128
    _cache: OrderedDict[str, CachedQuery] = field(default_factory=OrderedDict, init=False)
    _hits: int = field(default=0, init=False)
    _misses: int = field(default=0, init=False)
    _lock: threading.RLock = field(default_factory=threading.RLock, init=False)

    def get(self, key: str) -> CachedQuery | None:
        """Get query from cache with LRU update (O(1))."""
        with self._lock:
            if key in self._cache:
                self._cache.move_to_end(key)  # O(1)
                self._hits += 1
                return self._cache[key]
            self._misses += 1
            return None

    def set(self, key: str, query: CachedQuery, ttl: int | None = None) -> None:
        """Store query in cache with LRU eviction (O(1))."""
        with self._lock:
            if key not in self._cache and len(self._cache) >= self.max_size:
                self._cache.popitem(last=False)  # O(1)
            self._cache[key] = query
```

```python
def stats(self) -> dict[str, Any]:
    """
    Get cache statistics from Redis.

    WARNING: This method performs a full SCAN operation to count cached queries,
    which can be expensive and block the Redis server for large caches.
    Use only for debugging or monitoring purposes, NOT in production hot paths.

    For production monitoring, consider:
    - Using Redis INFO command for approximate statistics
    - Implementing a dedicated size counter key (updated on set/delete)
    - Using Redis monitoring tools (RedisInsight, prometheus-redis-exporter)
    """
```

```python
def _extract_entities_from_jsql(self, jsql: dict[str, Any]) -> set[str]:
    """
    Extract all entity names from JSQL query for access control.

    Recursively extracts entities from:
    - FROM clause
    - WITH clause (CTEs)
    - JOIN clauses
    - Subqueries
    ...
    """
```

```python
# Extract all entities from JSQL (including CTEs, joins)
entities_to_check = self._extract_entities_from_jsql(jsql)

# Check access for all entities
for entity_name_to_check in entities_to_check:
    self._check_access(entity_name_to_check, Operation.SELECT, context)
```

```python
def __post_init__(self) -> None:
    """Validate initialization parameters."""
    if self.max_size <= 0:
        msg = 'max_size must be positive integer'
        raise ValueError(msg)
```

```python
_lock: threading.RLock = field(default_factory=threading.RLock, init=False)

def get(self, key: str) -> CachedQuery | None:
    """Get query from cache with LRU update (O(1))."""
    with self._lock:
        # ... –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø ...
```

```plaintext
============================== 72 passed in 0.69s ==============================
```

---

**User**

–ü–æ—Å–ª–µ –≤–Ω–µ—Å–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ –¥–µ–ª–∞–π commit –¥–æ –º–æ–µ–≥–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è!

---

**Cursor**

–ü–æ–Ω—è–ª, —è –Ω–µ –±—É–¥—É –¥–µ–ª–∞—Ç—å commit –¥–æ –≤–∞—à–µ–≥–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.

–í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–Ω–µ—Å–µ–Ω—ã:

1. ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω `_check_access()` –≤ `application.py` - –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
2. ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω `MemoryCacheBackend` - O(1) LRU —á–µ—Ä–µ–∑ `OrderedDict` + thread-safe —á–µ—Ä–µ–∑ `RLock`
3. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω WARNING –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –≤ `RedisCacheBackend.stats()`
4. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `_extract_entities_from_jsql()` –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –≤ `select()`
5. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—è `max_size` –≤ `__post_init__()`
6. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω `threading.RLock` –¥–ª—è thread-safety –≤ `MemoryCacheBackend`

–í—Å–µ 72 —Ç–µ—Å—Ç–∞ –ø—Ä–æ—Ö–æ–¥—è—Ç, linting –æ—à–∏–±–æ–∫ –Ω–µ—Ç.

–ì–æ—Ç–æ–≤—ã –∫ –ø—Ä–æ–≤–µ—Ä–∫–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π. –î–∞–π—Ç–µ –∑–Ω–∞—Ç—å, –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç–µ –≥–æ—Ç–æ–≤—ã –∏ —è –ª–∏–±–æ –ø—Ä–æ–¥–æ–ª–∂—É —Ä–∞–±–æ—Ç—É –Ω–∞–¥ –æ—Å—Ç–∞–≤—à–∏–º–∏—Å—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏, –ª–∏–±–æ –≤—ã–ø–æ–ª–Ω—é –¥—Ä—É–≥–∏–µ –∑–∞–¥–∞—á–∏.

---

**User**

–ö–∞–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —É –Ω–∞—Å –µ—â—ë –æ—Å—Ç–∞–ª–∏—Å—å –∫ –æ–±—Ä–∞–±–æ—Ç–∫–µ?

---

**Cursor**

–ü–æ –º–æ–µ–º—É –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–º—É code review, –≤—Å–µ **–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ** –∏ **–≤–∞–∂–Ω—ã–µ** –ø—Ä–æ–±–ª–µ–º—ã —É–∂–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã:

## ‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ:

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ:**
1. ‚úÖ Broken Access Control - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω
2. ‚úÖ Algorithmic Painter (O(n) LRU) - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω
3. ‚úÖ –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π Redis stats - –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω

**–í–∞–∂–Ω—ã–µ:**
4. ‚úÖ DRY –≤ select() - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω (–¥–æ–±–∞–≤–ª–µ–Ω `_extract_entities_from_jsql`)
5. ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ - –¥–æ–±–∞–≤–ª–µ–Ω–∞ (`__post_init__`)
6. ‚úÖ Race conditions - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω (`threading.RLock`)

---

## üîÑ –û—Å—Ç–∞–ª–æ—Å—å (–∏–∑ —Ä–∞–∑–¥–µ–ª–∞ "–î–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–µ–ª–∏–∑–∞"):

### 7. **–¢–µ—Å—Ç–æ–≤–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ**
–ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤:
- Thread-safety —Ç–µ—Å—Ç—ã –¥–ª—è `MemoryCacheBackend`
- –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –∫—ç—à—É
- –¢–µ—Å—Ç—ã –¥–ª—è `_extract_entities_from_jsql()` (—Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã JSQL)

### 8. **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏**
–î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏:
- Cache hit/miss ratio –≤ logging
- –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
- –†–∞–∑–º–µ—Ä –∫—ç—à–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏

---

## üéØ –ú–æ—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è

**–°–µ–π—á–∞—Å –º–æ–∂–Ω–æ –º–µ—Ä–∂–∏—Ç—å** - –≤—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã, —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç.

–û—Å—Ç–∞–ª—å–Ω—ã–µ –ø—É–Ω–∫—Ç—ã (7 –∏ 8) –º–æ–∂–Ω–æ –æ—Ç–ª–æ–∂–∏—Ç—å –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ç–∞—Å–∫–∏, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—Ç —Ä–µ–ª–∏–∑.

–•–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã —è –¥–æ–±–∞–≤–∏–ª —Ç–µ—Å—Ç—ã –¥–ª—è thread-safety –∏ `_extract_entities_from_jsql()`, –∏–ª–∏ –∑–∞–∫—Ä–æ–µ–º —ç—Ç–æ—Ç code review?

---

**User**

–£ –º–µ–Ω—è –µ—Å—Ç—å —Ä—è–¥ –∑–∞–º–µ—á–∞–Ω–∏–π, –Ω–æ —Å–µ–π—á–∞—Å –ª—É—á—à–µ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ.
–ü–æ–¥–≥–æ—Ç–æ–≤—å –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ commit-–∞ –Ω–∞ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.

---

**Cursor**

–í–æ—Ç commit message –Ω–∞ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ:

```
fix: address critical issues from code review (20260115-033247)

Critical fixes:
- Restore broken access control in application.py (_check_access was non-functional)
- Optimize MemoryCacheBackend LRU from O(n) to O(1) using OrderedDict
- Add thread-safety to MemoryCacheBackend with threading.RLock
- Implement comprehensive entity extraction for access control in select()
  Extracts entities from FROM, WITH (CTEs), JOINs, subqueries
- Add parameter validation in MemoryCacheBackend (__post_init__)
- Document performance warning in RedisCacheBackend.stats()

Removed dead code after cache_stats() method

Statistics: +213 insertions, -41 deletions
Tests: all 72 tests passing
```

**–í–∞—Ä–∏–∞–Ω—Ç—ã –≤—ã–±–æ—Ä–∞:**

1. **–û–¥–Ω–∏–º –∫–æ–º–º–∏—Ç–æ–º** (–∫–∞–∫ –≤—ã—à–µ) - –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–º–µ—Å—Ç–µ
2. **–†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ 2-3 –∫–æ–º–º–∏—Ç–∞**:
   - `fix: restore broken access control in application.py`
   - `perf: optimize MemoryCacheBackend LRU to O(1) and add thread-safety`
   - `docs: add performance warning to RedisCacheBackend.stats()`

–ö–∞–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ?

```plaintext
fix: address critical issues from code review (20260115-033247)

Critical fixes:
- Restore broken access control in application.py (_check_access was non-functional)
- Optimize MemoryCacheBackend LRU from O(n) to O(1) using OrderedDict
- Add thread-safety to MemoryCacheBackend with threading.RLock
- Implement comprehensive entity extraction for access control in select()
  Extracts entities from FROM, WITH (CTEs), JOINs, subqueries
- Add parameter validation in MemoryCacheBackend (__post_init__)
- Document performance warning in RedisCacheBackend.stats()

Removed dead code after cache_stats() method

Statistics: +213 insertions, -41 deletions
Tests: all 72 tests passing
```

---

**User**

–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ñ–æ—Ä–º–ª–µ–Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ –ø—Ä–∞–≤–∏–ª–∞–º.

---

**Cursor**

–í–æ—Ç commit message —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–æ–º –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏:

```
fix(core): address critical issues from code review

Critical fixes:
- Restore broken access control in application.py (_check_access was non-functional)
- Optimize MemoryCacheBackend LRU from O(n) to O(1) using OrderedDict
- Add thread-safety to MemoryCacheBackend with threading.RLock
- Implement comprehensive entity extraction for access control in select()
  Extracts entities from FROM, WITH (CTEs), JOINs, subqueries
- Add parameter validation in MemoryCacheBackend (__post_init__)
- Document performance warning in RedisCacheBackend.stats()

Removed dead code after cache_stats() method

Statistics: +213 insertions, -41 deletions
Tests: all 72 tests passing
```

**–§–æ—Ä–º–∞—Ç:**
- `type`: `fix` (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–≥–æ–≤)
- `scope`: `core` (–æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª - application + cache)
- `subject`: –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –¥–æ 72 —Å–∏–º–≤–æ–ª–æ–≤

–ü–æ–¥—Ö–æ–¥–∏—Ç?

```plaintext
fix(core): address critical issues from code review

Critical fixes:
- Restore broken access control in application.py (_check_access was non-functional)
- Optimize MemoryCacheBackend LRU from O(n) to O(1) using OrderedDict
- Add thread-safety to MemoryCacheBackend with threading.RLock
- Implement comprehensive entity extraction for access control in select()
  Extracts entities from FROM, WITH (CTEs), JOINs, subqueries
- Add parameter validation in MemoryCacheBackend (__post_init__)
- Document performance warning in RedisCacheBackend.stats()

Removed dead code after cache_stats() method

Statistics: +213 insertions, -41 deletions
Tests: all 72 tests passing
```

---

**User**

–¶–∏—Ç–∏—Ä—É—é:
> - –°–æ–æ–±—â–µ–Ω–∏–µ commit-–∞ –í–°–ï–ì–î–ê –î–û–õ–ñ–ù–û –ë–´–¢–¨ –î–û–õ–ñ–ù–û –ù–ê–ß–ò–ù–ê–¢–¨–°–Ø –° –£–ü–û–ú–ò–ù–ê–ù–ò–Ø –ò–î–ï–ù–¢–ò–§–ò–ö–ê–¢–û–†–ê –ó–ê–î–ê–ß–ò SCM.
>   –≠—Ç–æ—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∏–∑–≤–ª–µ–∫–∞–π –∏–∑ –∏–º–µ–Ω–∏ —Ç–µ–∫—É—â–µ–π –≤–µ—Ç–∫–∏, –ø–æ–ª–∞–≥–∞—è, —á—Ç–æ –∏–º—è –≤–µ—Ç–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —à–∞–±–ª–æ–Ω—É `<purpose>/<task_id>-<description>`.
>   –ì–¥–µ <task_id> ‚Äì –∏—Å–∫–æ–º—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–¥–∞—á–∏, –≤ –∫–æ—Ç–æ—Ä–æ–º –º–æ–≥—É—Ç –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã, –∏ –∑–Ω–∞–∫ `-`.
> - –§–æ—Ä–º–∞—Ç —Å–æ–æ–±—â–µ–Ω–∏—è commit-–∞ —Å–ª–µ–¥—É—é—â–∏–π: `task_id. (commit_type) commmit_message.`.
>   –ó–¥–µ—Å—å `task_id` ‚Äì –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–¥–∞—á–∏, `commit_type` ‚Äì —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ç–∏–ø commit-–∞: "feat", "fix", "refactor" –∏ —Ç.–¥., `commit_message` ‚Äì –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π.



---

**Cursor**

–ü–æ–Ω—è–ª! –ò–∑–≤–ª–µ–∫–∞—é task_id –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏: `feature/20260114-102145-refactoring`

task_id = `20260114-102145`

–í–æ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π commit message:

```
20260114-102145. (fix) address critical issues from code review.

Critical fixes:
- Restore broken access control in application.py (_check_access was non-functional)
- Optimize MemoryCacheBackend LRU from O(n) to O(1) using OrderedDict
- Add thread-safety to MemoryCacheBackend with threading.RLock
- Implement comprehensive entity extraction for access control in select()
  Extracts entities from FROM, WITH (CTEs), JOINs, subqueries
- Add parameter validation in MemoryCacheBackend (__post_init__)
- Document performance warning in RedisCacheBackend.stats()

Removed dead code after cache_stats() method

Statistics: +213 insertions, -41 deletions
Tests: all 72 tests passing
```

**–§–æ—Ä–º–∞—Ç:**
- `task_id.` - `20260114-102145.` (–∏–∑ –≤–µ—Ç–∫–∏ `feature/20260114-102145-refactoring`)
- `(commit_type)` - `(fix)`
- `commit_message.` - –æ–ø–∏—Å–∞–Ω–∏–µ

–ü–æ–¥—Ö–æ–¥–∏—Ç?

```plaintext
20260114-102145. (fix) address critical issues from code review.

Critical fixes:
- Restore broken access control in application.py (_check_access was non-functional)
- Optimize MemoryCacheBackend LRU from O(n) to O(1) using OrderedDict
- Add thread-safety to MemoryCacheBackend with threading.RLock
- Implement comprehensive entity extraction for access control in select()
  Extracts entities from FROM, WITH (CTEs), JOINs, subqueries
- Add parameter validation in MemoryCacheBackend (__post_init__)
- Document performance warning in RedisCacheBackend.stats()

Removed dead code after cache_stats() method

Statistics: +213 insertions, -41 deletions
Tests: all 72 tests passing
```

---

**User**

–î–∞, –æ—Ç–ª–∏—á–Ω–æ. –í—ã–ø–æ–ª–Ω–∏ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ commit.

---

**Cursor**

‚úÖ **Commit –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ!**

```
[feature/20260114-102145-refactoring c12486e] 20260114-102145. (fix) address critical issues from code review.
 3 files changed, 213 insertions(+), 41 deletions(-)
```

**–ò–∑–º–µ–Ω–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã:**
- `src/namerec/uma/application.py`
- `src/namerec/uma/jsql/cache/memory.py`
- `src/namerec/uma/jsql/cache/redis.py`

**Commit hash:** `c12486e`

–í—Å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –∏–∑ code review –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –∏ –∑–∞–∫–æ–º–º–∏—á–µ–Ω—ã. –ì–æ—Ç–æ–≤—ã –∫ –ø—Ä–æ–≤–µ—Ä–∫–µ –∏ –º–µ—Ä–∂—É.

```plaintext
[feature/20260114-102145-refactoring c12486e] 20260114-102145. (fix) address critical issues from code review.
 3 files changed, 213 insertions(+), 41 deletions(-)
```

---

**User**

(20260115-035659) –î–∞–≤–∞–π –æ–±—Ä–∞—Ç–∏–º –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é `UMA.select`.

(20260115-035817) –Ø –≤–∏–∂—É:
```python
entity_name = jsql.get('from')
```
—á—Ç–æ –Ω–µ–≤–µ—Ä–Ω–æ (–∏ —è –ø–∏—Å–∞–ª –æ–± —ç—Ç–æ–º –≤—ã—à–µ), –ø–æ—Å–∫–æ–ª—å–∫—É –≤ –∫–∞—á–µ—Å—Ç–≤–µ FROM –º–æ–∂–µ—Ç –±—ã—Ç—å —É–∫–∞–∑–∞–Ω CTE.

(20260115-040113) –î–∞–ª–µ–µ, —è –≤–∏–∂—É:
```python
        # Extract all entities from JSQL (including CTEs, joins)
        entities_to_check = self._extract_entities_from_jsql(jsql)
```
–†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ `_extract_entities_from_jsql` —Ç–æ—á–Ω–æ –Ω–µ –º–µ—Å—Ç–æ –≤ `UMA` ‚Äì —ç—Ç–æ –ø—Ä—è–º–æ–µ –Ω–∞—Ä—É—à–µ–Ω–∏–µ SRP.
–ù–æ —ç—Ç–æ –ø–æ–ª–±–µ–¥—ã ‚Äì —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ (`_extract_entities_from_jsql`) —Ç—Ä–µ–±—É–µ—Ç —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞, —á—Ç–æ —Å –æ–¥–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã –¥–æ—Ä–æ–≥–æ, –∞ —Å –¥—Ä—É–≥–æ–π ‚Äì —ç—Ç–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –î–û –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –∫—ç—à.
–ü–æ–ª—É—á–∞–µ—Ç—Å—è, —á—Ç–æ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω—ã–π –∑–∞–ø—Ä–æ—Å –±—É–¥–µ—Ç –∫–∞–∂–¥—ã–π —Ä–∞–∑ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π, –¥–æ—Å—Ç—É–ø –∫ –∫–æ—Ç–æ—Ä—ã–º –ø—Ä–æ–≤–µ—Ä—è–ª–æ—Å—è –¥–æ —Ç–æ–≥–æ, –∫–∞–∫ –∑–∞–ø—Ä–æ—Å –±—ã–ª –ø–æ–º–µ—â—ë–Ω –≤ –∫—ç—à.
–ò —Ç–æ–ª–∫—É –æ—Ç —ç—Ç–æ–≥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è?

(20260115-040508) –ü—Ä–µ–¥–ª–æ–∂–∏ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–ª–∞–Ω –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è.
–í –∫–æ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∫–∞ –Ω–µ –≤–Ω–æ—Å–∏.    

---

**Cursor**

–í—ã –∞–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–∞–≤—ã! –≠—Ç–æ —Å–µ—Ä—å–µ–∑–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã:

## üö® –í—ã—è–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

### 1. **CTE –≤ FROM**
`jsql.get('from')` –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∏–º—è CTE, –∞ –Ω–µ —Ä–µ–∞–ª—å–Ω—É—é —Ç–∞–±–ª–∏—Ü—É. –ù—É–∂–Ω–æ –∏—Å–∫–∞—Ç—å –±–∞–∑–æ–≤—É—é —Å—É—â–Ω–æ—Å—Ç—å –≤ CTE definition.

### 2. **SRP –Ω–∞—Ä—É—à–µ–Ω–∏–µ**
–ú–µ—Ç–æ–¥—ã `_extract_entities_from_jsql` –∏ `_extract_entities_from_expression` —Ä–∞–±–æ—Ç–∞—é—Ç —Å JSQL —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π - —ç—Ç–æ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å parser/executor, –Ω–µ UMA –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.

### 3. **–£–±–∏–≤–∞–µ—Ç –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ**
–ö–∞–∂–¥—ã–π —Ä–∞–∑ —Å–∫–∞–Ω–∏—Ä—É–µ–º –≤–µ—Å—å –∑–∞–ø—Ä–æ—Å, –¥–∞–∂–µ –µ—Å–ª–∏ –æ–Ω –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω. –≠—Ç–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ª–∏—à–∞–µ—Ç —Å–º—ã—Å–ª–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫—ç—à–∞!

---

## üìã –ü–ª–∞–Ω –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è

### **–í–∞—Ä–∏–∞–Ω—Ç A: Lazy Access Control (—Ä–µ–∫–æ–º–µ–Ω–¥—É—é)**

**–°—É—Ç—å**: –ü–µ—Ä–µ–Ω–µ—Å—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞ –≤ `JSQLExecutor`, –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –∑–∞–ø—Ä–æ—Å —Ä–µ–∞–ª—å–Ω–æ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è (–Ω–µ –∏–∑ –∫—ç—à–∞).

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- ‚úÖ –ù–µ—Ç –ª–∏—à–Ω–µ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ cache hits
- ‚úÖ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å –∑–∞–ø—Ä–æ—Å–∞ –ª—É—á—à–µ –∑–Ω–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É (—É–∂–µ –ø–∞—Ä—Å–∏—Ç JSQL)
- ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å SRP
- ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–∞

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**:
1. –£–¥–∞–ª–∏—Ç—å `_extract_entities_from_jsql*` –∏–∑ `UMA`
2. –í `UMA.select()` –æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≤–µ—Ä–∫—É –æ—Å–Ω–æ–≤–Ω–æ–π —Å—É—â–Ω–æ—Å—Ç–∏ FROM (–∏–ª–∏ CTE)
3. –í `JSQLExecutor.execute()`:
   - –ü—Ä–∏ –ø–µ—Ä–≤–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ (cache miss) –∏–∑–≤–ª–µ–∫–∞—Ç—å –≤—Å–µ —Å—É—â–Ω–æ—Å—Ç–∏
   - –ü—Ä–æ–≤–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º
   - –°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π –≤ `CachedQuery`? –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–ª–∞–≥–∞—Ç—å—Å—è –Ω–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç

**–ù–µ–¥–æ—Å—Ç–∞—Ç–æ–∫**: –ü—Ä–∏ cache hit –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –ù–ï –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è. –ù—É–∂–Ω–æ —Ä–µ—à–∏—Ç—å - —ç—Ç–æ –±–∞–≥–∞ –∏–ª–∏ —Ñ–∏—á–∞ (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏)?

---

### **–í–∞—Ä–∏–∞–Ω—Ç B: Store entities in cache**

**–°—É—Ç—å**: –°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π –≤ `CachedQuery`, –ø–æ–≤—Ç–æ—Ä—è—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ.

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**:
1. –î–æ–±–∞–≤–∏—Ç—å `entities: list[str]` –≤ `CachedQuery`
2. –ü—Ä–∏ cache hit (–∏–∑ Redis) - –ø—Ä–æ–≤–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–º —Å—É—â–Ω–æ—Å—Ç—è–º
3. –ü—Ä–∏ cache miss - –∏–∑–≤–ª–µ–∫–∞—Ç—å —Å—É—â–Ω–æ—Å—Ç–∏, –ø—Ä–æ–≤–µ—Ä—è—Ç—å, —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –≤ `CachedQuery`

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- ‚úÖ –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ (–±–µ–∑–æ–ø–∞—Å–Ω–æ)
- ‚úÖ –ù–µ—Ç –ø–æ–ª–Ω–æ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è JSQL

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- ‚ùå –ü—Ä–∏ cache hit –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç (–Ω–æ –±—ã—Å—Ç—Ä–æ)
- ‚ùå –ù—É–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π –≤ Redis (—Ä–∞—Å—Ö–æ–¥ –ø–∞–º—è—Ç–∏)

---

### **–í–∞—Ä–∏–∞–Ω—Ç C: Check only main entity**

**–°—É—Ç—å**: –ü—Ä–æ–≤–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –∫ —Å—É—â–Ω–æ—Å—Ç–∏ –≤ FROM clause (–∏–ª–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å—ã –∏–∑ CTE).

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**:
1. –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤ `UMA.select()`
2. –ï—Å–ª–∏ FROM - —ç—Ç–æ CTE, –Ω–∞–π—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Å—ã –≤ CTE definition
3. –ë–æ–ª—å—à–µ –Ω–∏–≥–¥–µ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- ‚úÖ –ë—ã—Å—Ç—Ä–æ –∏ –ø—Ä–æ—Å—Ç–æ
- ‚úÖ –ù–µ—Ç –ª–∏—à–Ω–µ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏**:
- ‚ùå JOIN'—ã –∏ –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã –ù–ï –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è
- ‚ùå –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –¥—ã—Ä–∞ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

---

## üéØ –ú–æ—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è

**–í–∞—Ä–∏–∞–Ω—Ç A (Lazy Access Control)** —Å –Ω–µ–±–æ–ª—å—à–æ–π –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–µ–π:

1. **–£–¥–∞–ª–∏—Ç—å** `_extract_entities_from_jsql*` –∏–∑ `UMA`
2. **–û—Å—Ç–∞–≤–∏—Ç—å** –≤ `UMA.select()` —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≤–µ—Ä–∫—É –±–∞–∑–æ–≤–æ–π —Å—É—â–Ω–æ—Å—Ç–∏ FROM/CTE
3. **–î–æ–±–∞–≤–∏—Ç—å** –≤ `JSQLExecutor` –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞ –∫–æ –≤—Å–µ–º —Å—É—â–Ω–æ—Å—Ç—è–º –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
4. **–î–æ–±–∞–≤–∏—Ç—å** –ø–∞—Ä–∞–º–µ—Ç—Ä `skip_access_check=False` –≤ `select()` –¥–ª—è advanced use cases

–¢–∞–∫ –º—ã:
- –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–º—ã—Å–ª –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω–µ—Ç —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ cache hits)
- –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Å—É—â–Ω–æ—Å—Ç–∏ (JOINs, –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã)
- –°–æ–±–ª—é–¥–∞–µ–º SRP (JSQL –ª–æ–≥–∏–∫–∞ –≤ executor)
- –ü–æ–∑–≤–æ–ª—è–µ–º –≥–∏–±–∫–æ –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞

---

**–ö–∞–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –≤—ã–±–∏—Ä–∞–µ—Ç–µ?** –ò–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥?

---

**User**

> –†–µ–∞–ª–∏–∑–∞—Ü–∏—è:
> –£–¥–∞–ª–∏—Ç—å _extract_entities_from_jsql* –∏–∑ UMA
> –í UMA.select() –æ—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≤–µ—Ä–∫—É –æ—Å–Ω–æ–≤–Ω–æ–π —Å—É—â–Ω–æ—Å—Ç–∏ FROM (–∏–ª–∏ CTE)

–ê –∑–∞—á–µ–º –Ω–∞–º –æ—Ç–¥–∞–≤–∞—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–µ —Ç–æ–º—É, —á—Ç–æ —É–∫–∞–∑–∞–Ω–æ –≤–æ FROM?
–≠—Ç–∞ —Ç–∞–∫–∞—è –∂–µ —Å—É—â–Ω–æ—Å—Ç—å, –∫–∞–∫ –∏ –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ, –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–ª–æ–Ω–æ–∫ –∫–æ—Ç–æ—Ä—ã—Ö –ø–æ–ø–∞–¥–∞—é—Ç –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

(20260115-041058) –û–ë–†–ê–©–ê–Æ –í–ù–ò–ú–ê–ù–ò–ï: –º—ã –¥–æ–ª–∂–Ω—ã –ø—Ä–æ–≤–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –Ω–µ –∫–æ –≤—Å–µ–º —Å—É—â–Ω–æ—Å—Ç—è–º, —É–ø–æ–º–∏–Ω–∞–µ–º—ã–º –≤ –∑–∞–ø—Ä–æ—Å–µ, –∞ —Ç–æ–ª—å–∫–æ –∫ —Ç–µ–º, –¥–∞–Ω–Ω—ã–µ –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö –ø–æ–ø–∞–¥–∞—é—Ç –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç, —Ç.–µ. –æ–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –±–ª–æ–∫–µ `SELECT`.

> –í JSQLExecutor.execute():
> –ü—Ä–∏ –ø–µ—Ä–≤–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ (cache miss) –∏–∑–≤–ª–µ–∫–∞—Ç—å –≤—Å–µ —Å—É—â–Ω–æ—Å—Ç–∏
> –ü—Ä–æ–≤–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º

–í–µ—Ä–Ω–æ. –¢–æ–ª—å–∫–æ "–≤—Å–µ —Å—É—â–Ω–æ—Å—Ç–∏" —Å —É—á—ë—Ç–æ–º —Ç–µ–∑–∏—Å–∞ `20260115-041058`. 

> –°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π –≤ CachedQuery? –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–ª–∞–≥–∞—Ç—å—Å—è –Ω–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç
> –ù–µ–¥–æ—Å—Ç–∞—Ç–æ–∫: –ü—Ä–∏ cache hit –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –ù–ï –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è. –ù—É–∂–Ω–æ —Ä–µ—à–∏—Ç—å - —ç—Ç–æ –±–∞–≥–∞ –∏–ª–∏ —Ñ–∏—á–∞ (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–≥ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏)?

–î–∞, —Ç—É—Ç —Ç—ã –≤–µ—Ä–Ω–æ –ø–æ–¥–º–µ—Ç–∏–ª ‚Äì –ø–æ–ª–Ω–æ–º–æ—á–∏—è –Ω–∞ —Å—É—â–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ, –¥–∞–∂–µ –µ—Å–ª–∏ –æ–Ω –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω. –ò —ç—Ç–æ –û–ß–ï–ù–¨ –í–ê–ñ–ù–û!!!
–î—É–º–∞—é, –ø–æ–ª–Ω–æ–º–æ—á–∏—è —Ç–æ–∂–µ –±—É–¥—É—Ç –∫—ç—à–∏—Ä–æ–≤–∞—Ç—å—Å—è, –Ω–æ —ç—Ç–æ —É–∂–µ —É—Ä–æ–≤–µ–Ω—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (backend), –∞ –Ω–µ –Ω–∞—à–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.

(20260115-041755) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–í –∫–æ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∫–∞ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–ü–æ–Ω—è–ª! –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É—Ç–æ—á–Ω–µ–Ω–∏—è:

## üéØ –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω (—Å —É—á—ë—Ç–æ–º SELECT-only –ø—Ä–æ–≤–µ—Ä–æ–∫)

### **–ö–ª—é—á–µ–≤—ã–µ –º–æ–º–µ–Ω—Ç—ã:**
1. –ü—Ä–æ–≤–µ—Ä—è—Ç—å **—Ç–æ–ª—å–∫–æ —Å—É—â–Ω–æ—Å—Ç–∏ –≤ SELECT** (–Ω–µ –≤—Å–µ —É–ø–æ–º—è–Ω—É—Ç—ã–µ)
2. –ü—Ä–æ–≤–µ—Ä—è—Ç—å –¥–æ—Å—Ç—É–ø **–ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ** (–¥–∞–∂–µ –∏–∑ –∫—ç—à–∞) - –ø—Ä–∞–≤–∞ –º–æ–≥—É—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è
3. JSQLExecutor —É–∂–µ –∑–Ω–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É SELECT –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏!

---

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç A: JSQLExecutor –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø

### –°—É—Ç—å
- `UMA.select()` - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (—Ç–æ–ª—å–∫–æ FROM/CTE)
- `JSQLExecutor` - –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤—Å–µ —Å—É—â–Ω–æ—Å—Ç–∏ –≤ SELECT –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏/–∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –∏–∑ –∫—ç—à–∞

### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- ‚úÖ –ù–µ—Ç –ª–∏—à–Ω–µ–≥–æ JSQL —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤ UMA
- ‚úÖ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å —É–∂–µ –∑–Ω–∞–µ—Ç SELECT —Å—Ç—Ä—É–∫—Ç—É—Ä—É (–æ–Ω –∂–µ –µ—ë —Å—Ç—Ä–æ–∏—Ç!)
- ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ (–≤–∫–ª—é—á–∞—è cache hits)
- ‚úÖ –¢–æ–ª—å–∫–æ SELECT —Å—É—â–Ω–æ—Å—Ç–∏ (–±–µ–∑ WHERE/JOIN/HAVING)
- ‚úÖ SRP —Å–æ–±–ª—é–¥–µ–Ω
- ‚úÖ –ö—ç—à —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

#### –®–∞–≥ 1: `UMA.select()` - —É–ø—Ä–æ—Å—Ç–∏—Ç—å
```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    # Create context
    context = self._create_context(entity.namespace, user_context)
    
    # Minimal check for base entity (or CTE reference)
    self._check_access(str(entity), Operation.SELECT, context)
    
    # Execute with full SELECT access control in executor
    executor = JSQLExecutor(
        context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
    )
    result = await executor.execute(jsql, params)
    
    return result.to_dict()
```

#### –®–∞–≥ 2: `JSQLExecutor.execute()` - –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É SELECT
```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    # ... existing code ...
    
    # Try cache first
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, self._context.user_context, self._context.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            self._check_select_access(cached.entities)
            
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    self._parser = JSQLParser(self._context)
    parsed = self._parse_jsql(jsql)
    
    # Build SQL query
    sql_query = await self._parser.parse(jsql)
    
    # Check access to SELECT entities
    select_entities = self._extract_select_entities(sql_query)
    self._check_access_to_entities(select_entities)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=self._context.engine.dialect.name,
            entities=select_entities,  # Save entities for cache hits!
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result
```

#### –®–∞–≥ 3: `CachedQuery` - –¥–æ–±–∞–≤–∏—Ç—å entities
```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str]  # Entities in SELECT clause
```

#### –®–∞–≥ 4: –£–¥–∞–ª–∏—Ç—å –º–µ—Ç–æ–¥—ã –∏–∑ `UMA`
- ‚ùå `_extract_entities_from_jsql()`
- ‚ùå `_extract_entities_from_expression()`

### –†–µ–∑—é–º–µ
| –ê—Å–ø–µ–∫—Ç | –†–µ—à–µ–Ω–∏–µ |
|---------|----------|
| –ß—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º | –¢–æ–ª—å–∫–æ SELECT —Å—É—â–Ω–æ—Å—Ç–∏ |
| –ö–æ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º | –ü—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ (cache hit + miss) |
| –ì–¥–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º | –í `JSQLExecutor` |
| –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ JSQL | –¢–æ–ª—å–∫–æ –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ (cache miss) |
| –ö—ç—à | –†–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ, —Å—É—â–Ω–æ—Å—Ç–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ `CachedQuery` |
| SRP | –°–æ–±–ª—é–¥–µ–Ω |

**–ü–æ–¥—Ö–æ–¥–∏—Ç —Ç–∞–∫–æ–π –ø–ª–∞–Ω?**

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    # Create context
    context = self._create_context(entity.namespace, user_context)
    
    # Minimal check for base entity (or CTE reference)
    self._check_access(str(entity), Operation.SELECT, context)
    
    # Execute with full SELECT access control in executor
    executor = JSQLExecutor(
        context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
    )
    result = await executor.execute(jsql, params)
    
    return result.to_dict()
```

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    # ... existing code ...
    
    # Try cache first
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, self._context.user_context, self._context.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            self._check_select_access(cached.entities)
            
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    self._parser = JSQLParser(self._context)
    parsed = self._parse_jsql(jsql)
    
    # Build SQL query
    sql_query = await self._parser.parse(jsql)
    
    # Check access to SELECT entities
    select_entities = self._extract_select_entities(sql_query)
    self._check_access_to_entities(select_entities)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=self._context.engine.dialect.name,
            entities=select_entities,  # Save entities for cache hits!
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result
```

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str]  # Entities in SELECT clause
```

---

**User**

> UMA.select() - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (—Ç–æ–ª—å–∫–æ FROM/CTE)

–Ø –ø—Ä–µ–¥–ª–∞–≥–∞—é –≤ `UMA.select()` –≤–æ–æ–±—â–µ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ø–æ–ª–Ω–æ–º–æ—á–∏—è. –°–æ–≤—Å–µ–º.
–ü—É—Å—Ç—å —ç—Ç–∏–º –∑–∞–Ω–∏–º–∞–µ—Ç—Å—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å, –∫–æ—Ç–æ—Ä–æ–º—É –≤—Å—ë –∏–∑–≤–µ—Å—Ç–Ω–æ –æ –∑–∞–ø—Ä–æ—Å–µ.
–¢.–µ. —ç—Ç–æ:
```
    # Extract entity_name from JSQL
    entity_name = jsql.get('from')
    if not entity_name:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    # Create context
    context = self._create_context(entity.namespace, user_context)
    
    # Minimal check for base entity (or CTE reference)
    self._check_access(str(entity), Operation.SELECT, context)
```
–ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –≤ `JSQLExecutor` ‚Äì –ø–æ–¥—É–º–∞–π, –∫–∞–∫ –≤–Ω—É—Ç—Ä–∏ –Ω–µ–≥–æ –æ–±–µ—Å–ø–µ—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –ø–æ–ª–Ω–æ–º–æ—á–∏–π –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.

(20260115-042428) –û–±–Ω–æ–≤–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–í –∫–æ–¥ –ø–æ–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ! –ü–æ–ª–Ω–∞—è –¥–µ–ª–µ–≥–∞—Ü–∏—è –≤ `JSQLExecutor` - —ç—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –ü–æ–ª–Ω–∞—è –¥–µ–ª–µ–≥–∞—Ü–∏—è –≤ JSQLExecutor

### –®–∞–≥ 1: `UMA.select()` - —É–¥–∞–ª–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query with full access control in executor."""
    
    # Create context for namespace resolution
    entity_name = jsql.get('from')
    if not entity_name:
        raise ValueError("JSQL must contain 'from' field")
    
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    context = self._create_context(entity.namespace, user_context)
    
    # Execute - JSQLExecutor handles all access control
    executor = JSQLExecutor(
        context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
    )
    result = await executor.execute(jsql, params)
    
    return result.to_dict()
```

### –®–∞–≥ 2: `JSQLExecutor` - –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É SELECT

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    """Execute JSQL with access control for SELECT entities."""
    
    # ... existing cache logic ...
    
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, self._context.user_context, self._context.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            self._check_select_access(cached.entities)
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    sql_query = await self._parser.parse(jsql)
    
    # Extract entities from SELECT clause
    select_entities = self._extract_select_entities(jsql)
    
    # Check access to all SELECT entities
    self._check_access_to_entities(select_entities)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=self._context.engine.dialect.name,
            entities=list(select_entities),
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result

def _check_select_access(self, entities: list[str]) -> None:
    """Check access to entities in SELECT clause."""
    if not hasattr(self._context.metadata_provider, 'can'):
        return
    
    for entity_name in entities:
        if not self._context.metadata_provider.can(entity_name, Operation.SELECT, self._context):
            raise UMAAccessDeniedError(entity_name, Operation.SELECT.value)

def _extract_select_entities(self, jsql: dict) -> set[str]:
    """Extract entities from SELECT clause only."""
    entities: set[str] = set()
    
    # Parse SELECT clause
    select_clause = jsql.get('select')
    if not select_clause:
        return entities
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entities_from_expression(item, jsql))
    
    return entities

def _extract_entities_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        # String like '*' or 'id' - use FROM entity
        if expr == '*' or '.' not in expr:
            from_entity = jsql.get('from')
            if from_entity and isinstance(from_entity, str):
                entities.add(from_entity)
        elif '.' in expr:
            entities.add(expr.split('.', 1)[0])
    elif isinstance(expr, dict):
        # Dict with 'field', 'func', 'expr', etc.
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entities.add(field.split('.', 1)[0])
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entities_from_expression(arg, jsql))
        elif 'expr' in expr:
            entities.update(self._extract_entities_from_expression(expr['expr'], jsql))
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entities_from_expression(expr['left'], jsql))
            entities.update(self._extract_entities_from_expression(expr['right'], jsql))
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self._extract_select_entities(subquery))
    
    return entities
```

### –®–∞–≥ 3: `CachedQuery` - –¥–æ–±–∞–≤–∏—Ç—å entities

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)  # Entities in SELECT clause
```

### –®–∞–≥ 4: `UMA` - —É–¥–∞–ª–∏—Ç—å –º–µ—Ç–æ–¥—ã

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

---

## üéØ –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–æ–¥—Ö–æ–¥–∞

| –ê—Å–ø–µ–∫—Ç | –†–µ—à–µ–Ω–∏–µ |
|---------|----------|
| –ü—Ä–æ–≤–µ—Ä—è–µ–º | –¢–æ–ª—å–∫–æ SELECT —Å—É—â–Ω–æ—Å—Ç–∏ |
| –ö–æ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º | –ü—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—Ä–æ—Å–µ (cache hit/miss) |
| –ì–¥–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º | –í `JSQLExecutor.execute()` |
| –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ JSQL | –¢–æ–ª—å–∫–æ –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ (cache miss) |
| –ö—ç—à | –†–∞–±–æ—Ç–∞–µ—Ç, entities —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ `CachedQuery` |
| SRP | ‚úÖ UMA –Ω–µ –∑–Ω–∞–µ—Ç –æ JSQL —Å—Ç—Ä—É–∫—Ç—É—Ä–µ |
| –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ | –ß–∏—Å—Ç–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ |

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query with full access control in executor."""
    
    # Create context for namespace resolution
    entity_name = jsql.get('from')
    if not entity_name:
        raise ValueError("JSQL must contain 'from' field")
    
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    context = self._create_context(entity.namespace, user_context)
    
    # Execute - JSQLExecutor handles all access control
    executor = JSQLExecutor(
        context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
    )
    result = await executor.execute(jsql, params)
    
    return result.to_dict()
```

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    """Execute JSQL with access control for SELECT entities."""
    
    # ... existing cache logic ...
    
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, self._context.user_context, self._context.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            self._check_select_access(cached.entities)
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    sql_query = await self._parser.parse(jsql)
    
    # Extract entities from SELECT clause
    select_entities = self._extract_select_entities(jsql)
    
    # Check access to all SELECT entities
    self._check_access_to_entities(select_entities)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=self._context.engine.dialect.name,
            entities=list(select_entities),
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result

def _check_select_access(self, entities: list[str]) -> None:
    """Check access to entities in SELECT clause."""
    if not hasattr(self._context.metadata_provider, 'can'):
        return
    
    for entity_name in entities:
        if not self._context.metadata_provider.can(entity_name, Operation.SELECT, self._context):
            raise UMAAccessDeniedError(entity_name, Operation.SELECT.value)

def _extract_select_entities(self, jsql: dict) -> set[str]:
    """Extract entities from SELECT clause only."""
    entities: set[str] = set()
    
    # Parse SELECT clause
    select_clause = jsql.get('select')
    if not select_clause:
        return entities
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entities_from_expression(item, jsql))
    
    return entities

def _extract_entities_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        # String like '*' or 'id' - use FROM entity
        if expr == '*' or '.' not in expr:
            from_entity = jsql.get('from')
            if from_entity and isinstance(from_entity, str):
                entities.add(from_entity)
        elif '.' in expr:
            entities.add(expr.split('.', 1)[0])
    elif isinstance(expr, dict):
        # Dict with 'field', 'func', 'expr', etc.
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entities.add(field.split('.', 1)[0])
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entities_from_expression(arg, jsql))
        elif 'expr' in expr:
            entities.update(self._extract_entities_from_expression(expr['expr'], jsql))
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entities_from_expression(expr['left'], jsql))
            entities.update(self._extract_entities_from_expression(expr['right'], jsql))
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self._extract_select_entities(subquery))
    
    return entities
```

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)  # Entities in SELECT clause
```

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

---

**User**

(20260115-042915) –°–º–æ—Ç—Ä–∏ –º–æ–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ (`Sht@`):
```
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query with full access control in executor."""
    
    Sht@20260115-043059. –≠—Ç–æ—Ç —Ñ—Ä–∞–≥–º–µ–Ω—Ç –≤–æ–æ–±—â–µ –Ω—É–∂–Ω–æ —É–±—Ä–∞—Ç—å
    # Create context for namespace resolution
    entity_name = jsql.get('from')
    if not entity_name:
        raise ValueError("JSQL must contain 'from' field")
    
    Sht@20260115-043109. –≠—Ç–æ –Ω—É–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å –≤ JSQLExecutor.execute(), –∫–∞–∫ —Ç–æ–ª—å–∫–æ —Å—Ç–∞–Ω–µ—Ç –∏–∑–≤–µ—Å—Ç–Ω–æ, –∫–∞–∫–∞—è —Å—É—â–Ω–æ—Å—Ç—å —É–∫–∞–∑–∞–Ω–∞ –≤ FROM, –≤–æ–∑–º–æ–∂–Ω–æ, –æ–±—Ä–∞–±–æ—Ç–∞–≤ CTE.
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    Sht@20260115-043230. –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω—É–∂–Ω–æ —Å—Ç—Ä–æ–∏—Ç—å –≤ JSQLExecutor.execute(), –∫–æ–≥–¥–∞ —Å—Ç–∞–Ω–µ—Ç –∏–∑–≤–µ—Å—Ç–µ–Ω namespace.
    context = self._create_context(entity.namespace, user_context)
```

(20260115-043335) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞ —Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –º–æ–∏—Ö –∑–∞–º–µ—á–∞–Ω–∏–π. –í –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∫–∞ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ! –ü–æ–Ω—è–ª –∑–∞–¥–∞—á—É - `UMA.select()` –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–æ—Å—Ç—ã–º, –∞ –≤—Å—è –ª–æ–≥–∏–∫–∞ (–ø–∞—Ä—Å–∏–Ω–≥, namespace, –∫–æ–Ω—Ç–µ–∫—Å—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞) - –≤ `JSQLExecutor`.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ—Å—Ç–æ—Ç–∞ –≤ UMA.select()

### –®–∞–≥ 1: `UMA.select()` - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query.
    
    All logic (FROM parsing, namespace resolution, access control)
    is handled by JSQLExecutor.
    """
    # Create executor with minimal context (namespace resolved inside executor)
    context = self._create_context(None, user_context)
    
    executor = JSQLExecutor(
        context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
        namespace_override=namespace,  # Pass namespace hint
    )
    
    result = await executor.execute(jsql, params)
    return result.to_dict()
```

### –®–∞–≥ 2: `JSQLExecutor.__init__` - –¥–æ–±–∞–≤–∏—Ç—å namespace_override

```python
def __init__(
    self,
    context: UMAContext,
    cache_backend: CacheBackend | None = None,
    cache_enabled: bool = True,
    namespace_override: str | None = None,
) -> None:
    self._context = context
    self._cache_backend = cache_backend
    self._cache_enabled = cache_enabled
    self._namespace_override = namespace_override  # Hint for namespace resolution
```

### –®–∞–≥ 3: `JSQLExecutor.execute()` - –≤—Å—è –ª–æ–≥–∏–∫–∞ –∑–¥–µ—Å—å

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    """Execute JSQL with full logic: FROM parsing, namespace, access control."""
    
    # Parse FROM to resolve namespace and entity
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name (handles CTEs)
    if isinstance(from_entity, str):
        entity_name = from_entity
        # Check if it's a CTE
        if self._is_cte_name(entity_name, jsql):
            # Resolve real entity from CTE definition
            real_entity = self._resolve_cte_base_entity(entity_name, jsql)
            entity_name = real_entity
    else:
        # Subquery in FROM - extract recursively
        entity_name = self._extract_from_subquery(from_entity)
    
    # Resolve namespace
    entity = parse_entity_name(entity_name)
    if self._namespace_override and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=self._namespace_override)
    
    # Update context with resolved namespace
    resolved_context = self._context
    if entity.namespace != resolved_context.namespace:
        resolved_context = self._resolve_namespace_context(entity.namespace)
    
    # Try cache
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, resolved_context.user_context, entity.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            self._check_select_access(cached.entities, resolved_context)
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    parser = JSQLParser(resolved_context)
    sql_query = await parser.parse(jsql)
    
    # Extract entities from SELECT clause only
    select_entities = self._extract_select_entities(jsql)
    
    # Check access to all SELECT entities
    self._check_access_to_entities(select_entities, resolved_context)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=resolved_context.engine.dialect.name,
            entities=list(select_entities),
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result

def _is_cte_name(self, name: str, jsql: dict) -> bool:
    """Check if name is a CTE defined in WITH clause."""
    with_clauses = jsql.get('with')
    if not with_clauses:
        return False
    
    if isinstance(with_clauses, list):
        return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
    elif isinstance(with_clauses, dict):
        return name in with_clauses
    
    return False

def _resolve_cte_base_entity(self, cte_name: str, jsql: dict) -> str:
    """Resolve base entity from CTE definition."""
    with_clauses = jsql.get('with')
    if isinstance(with_clauses, list):
        for cte in with_clauses:
            if isinstance(cte, dict) and cte.get('name') == cte_name:
                cte_query = cte.get('query')
                if isinstance(cte_query, dict):
                    return cte_query.get('from', cte_name)
    elif isinstance(with_clauses, dict):
        cte_def = with_clauses.get(cte_name)
        if isinstance(cte_def, dict):
            return cte_def.get('from', cte_name)
    
    return cte_name  # Fallback

def _resolve_namespace_context(self, namespace: str) -> UMAContext:
    """Create context for specific namespace."""
    # This needs access to namespace_configs - may need to pass from UMA
    # For now, assume UMAContext can be recreated or use a provider pattern
    return UMAContext(
        engine=self._context.engine,
        metadata_provider=self._context.metadata_provider,
        namespace=namespace,
        user_context=self._context.user_context,
    )

def _extract_select_entities(self, jsql: dict) -> set[str]:
    """Extract entities from SELECT clause only."""
    entities: set[str] = set()
    
    select_clause = jsql.get('select')
    if not select_clause:
        return entities
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entities_from_expression(item, jsql))
    
    return entities

def _extract_entities_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        if expr == '*' or '.' not in expr:
            from_entity = jsql.get('from')
            if from_entity and isinstance(from_entity, str):
                entities.add(from_entity)
        elif '.' in expr:
            entities.add(expr.split('.', 1)[0])
    elif isinstance(expr, dict):
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entities.add(field.split('.', 1)[0])
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entities_from_expression(arg, jsql))
        elif 'expr' in expr:
            entities.update(self._extract_entities_from_expression(expr['expr'], jsql))
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entities_from_expression(expr['left'], jsql))
            entities.update(self._extract_entities_from_expression(expr['right'], jsql))
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self._extract_select_entities(subquery))
    
    return entities

def _check_select_access(self, entities: list[str], context: UMAContext) -> None:
    """Check access to entities in SELECT clause."""
    if not hasattr(context.metadata_provider, 'can'):
        return
    
    for entity_name in entities:
        if not context.metadata_provider.can(entity_name, Operation.SELECT, context):
            raise UMAAccessDeniedError(entity_name, Operation.SELECT.value)

def _check_access_to_entities(self, entities: set[str], context: UMAContext) -> None:
    """Check access to all SELECT entities."""
    self._check_select_access(list(entities), context)
```

### –®–∞–≥ 4: –£–¥–∞–ª–∏—Ç—å –∏–∑ UMA

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - entity_name = jsql.get('from')
# - parse_entity_name(...)
# - _create_context(entity.namespace, ...)
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

### –®–∞–≥ 5: `CachedQuery` - –¥–æ–±–∞–≤–∏—Ç—å entities

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)
```

---

## üéØ –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è

| –ö–ª–∞—Å—Å | –ë—ã–ª–æ | –°—Ç–∞–ª–æ |
|---------|--------|--------|
| `UMA.select()` | –ü–∞—Ä—Å–∏–Ω–≥ FROM, —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ | –°–æ–∑–¥–∞–Ω–∏–µ executor, –≤—ã–∑–æ–≤ execute() |
| `JSQLExecutor` | –¢–æ–ª—å–∫–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ | –ü–∞—Ä—Å–∏–Ω–≥ FROM, —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ namespace, –ø—Ä–æ–≤–µ—Ä–∫–∞ SELECT –¥–æ—Å—Ç—É–ø–∞ |

**–ü—Ä–æ–±–ª–µ–º–∞**: `_resolve_namespace_context()` —Ç—Ä–µ–±—É–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ `namespace_configs`. –ù—É–∂–Ω–æ –ª–∏–±–æ:
- –î–æ–±–∞–≤–∏—Ç—å –≤ `JSQLExecutor.__init__` –ø–∞—Ä–∞–º–µ—Ç—Ä `namespace_configs`
- –ò–ª–∏ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≥–æ—Ç–æ–≤—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å namespace –∏–∑ UMA (–Ω–æ —Ç–æ–≥–¥–∞ UMA –¥–æ–ª–∂–µ–Ω –ø–∞—Ä—Å–∏—Ç—å FROM...)

–ö–∞–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ –¥–ª—è `namespace_configs`?

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query.
    
    All logic (FROM parsing, namespace resolution, access control)
    is handled by JSQLExecutor.
    """
    # Create executor with minimal context (namespace resolved inside executor)
    context = self._create_context(None, user_context)
    
    executor = JSQLExecutor(
        context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
        namespace_override=namespace,  # Pass namespace hint
    )
    
    result = await executor.execute(jsql, params)
    return result.to_dict()
```

```python
def __init__(
    self,
    context: UMAContext,
    cache_backend: CacheBackend | None = None,
    cache_enabled: bool = True,
    namespace_override: str | None = None,
) -> None:
    self._context = context
    self._cache_backend = cache_backend
    self._cache_enabled = cache_enabled
    self._namespace_override = namespace_override  # Hint for namespace resolution
```

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    """Execute JSQL with full logic: FROM parsing, namespace, access control."""
    
    # Parse FROM to resolve namespace and entity
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name (handles CTEs)
    if isinstance(from_entity, str):
        entity_name = from_entity
        # Check if it's a CTE
        if self._is_cte_name(entity_name, jsql):
            # Resolve real entity from CTE definition
            real_entity = self._resolve_cte_base_entity(entity_name, jsql)
            entity_name = real_entity
    else:
        # Subquery in FROM - extract recursively
        entity_name = self._extract_from_subquery(from_entity)
    
    # Resolve namespace
    entity = parse_entity_name(entity_name)
    if self._namespace_override and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=self._namespace_override)
    
    # Update context with resolved namespace
    resolved_context = self._context
    if entity.namespace != resolved_context.namespace:
        resolved_context = self._resolve_namespace_context(entity.namespace)
    
    # Try cache
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, resolved_context.user_context, entity.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            self._check_select_access(cached.entities, resolved_context)
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    parser = JSQLParser(resolved_context)
    sql_query = await parser.parse(jsql)
    
    # Extract entities from SELECT clause only
    select_entities = self._extract_select_entities(jsql)
    
    # Check access to all SELECT entities
    self._check_access_to_entities(select_entities, resolved_context)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=resolved_context.engine.dialect.name,
            entities=list(select_entities),
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result

def _is_cte_name(self, name: str, jsql: dict) -> bool:
    """Check if name is a CTE defined in WITH clause."""
    with_clauses = jsql.get('with')
    if not with_clauses:
        return False
    
    if isinstance(with_clauses, list):
        return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
    elif isinstance(with_clauses, dict):
        return name in with_clauses
    
    return False

def _resolve_cte_base_entity(self, cte_name: str, jsql: dict) -> str:
    """Resolve base entity from CTE definition."""
    with_clauses = jsql.get('with')
    if isinstance(with_clauses, list):
        for cte in with_clauses:
            if isinstance(cte, dict) and cte.get('name') == cte_name:
                cte_query = cte.get('query')
                if isinstance(cte_query, dict):
                    return cte_query.get('from', cte_name)
    elif isinstance(with_clauses, dict):
        cte_def = with_clauses.get(cte_name)
        if isinstance(cte_def, dict):
            return cte_def.get('from', cte_name)
    
    return cte_name  # Fallback

def _resolve_namespace_context(self, namespace: str) -> UMAContext:
    """Create context for specific namespace."""
    # This needs access to namespace_configs - may need to pass from UMA
    # For now, assume UMAContext can be recreated or use a provider pattern
    return UMAContext(
        engine=self._context.engine,
        metadata_provider=self._context.metadata_provider,
        namespace=namespace,
        user_context=self._context.user_context,
    )

def _extract_select_entities(self, jsql: dict) -> set[str]:
    """Extract entities from SELECT clause only."""
    entities: set[str] = set()
    
    select_clause = jsql.get('select')
    if not select_clause:
        return entities
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entities_from_expression(item, jsql))
    
    return entities

def _extract_entities_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        if expr == '*' or '.' not in expr:
            from_entity = jsql.get('from')
            if from_entity and isinstance(from_entity, str):
                entities.add(from_entity)
        elif '.' in expr:
            entities.add(expr.split('.', 1)[0])
    elif isinstance(expr, dict):
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entities.add(field.split('.', 1)[0])
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entities_from_expression(arg, jsql))
        elif 'expr' in expr:
            entities.update(self._extract_entities_from_expression(expr['expr'], jsql))
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entities_from_expression(expr['left'], jsql))
            entities.update(self._extract_entities_from_expression(expr['right'], jsql))
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self._extract_select_entities(subquery))
    
    return entities

def _check_select_access(self, entities: list[str], context: UMAContext) -> None:
    """Check access to entities in SELECT clause."""
    if not hasattr(context.metadata_provider, 'can'):
        return
    
    for entity_name in entities:
        if not context.metadata_provider.can(entity_name, Operation.SELECT, context):
            raise UMAAccessDeniedError(entity_name, Operation.SELECT.value)

def _check_access_to_entities(self, entities: set[str], context: UMAContext) -> None:
    """Check access to all SELECT entities."""
    self._check_select_access(list(entities), context)
```

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - entity_name = jsql.get('from')
# - parse_entity_name(...)
# - _create_context(entity.namespace, ...)
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)
```

---

**User**

(20260115-043708) –Ø –¥—É–º–∞—é, –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä `JSQLExecutor` –Ω–µ —Å–ª–µ–¥—É–µ—Ç –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤–æ–æ–±—â–µ, –∞ –≤–æ—Ç `namespace_configs` –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å, –ø–æ-–≤–∏–¥–∏–º–æ–º—É, —Å–ª–µ–¥—É–µ—Ç.
–ö–æ–Ω—Ç–µ–∫—Å—Ç –∂–µ (`UMAContext`) –º–æ–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≤ `JSQLExecutor.execute()`, –∫–æ–≥–¥–∞ —Å—Ç–∞–Ω–µ—Ç –∏–∑–≤–µ—Å—Ç–Ω–æ namespace –ø–æ—Å–ª–µ –ø–ø–∞—Ä—Å–∏–Ω–≥–∞ JSQL.

(20260115-043858) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–í –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∫–∞ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ! –ü–µ—Ä–µ–¥–∞–≤–∞—Ç—å `namespace_configs` –∏ —Å—Ç—Ä–æ–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤–Ω—É—Ç—Ä–∏ `execute()` - —ç—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –ö–æ–Ω—Ç–µ–∫—Å—Ç –≤–Ω—É—Ç—Ä–∏ JSQLExecutor.execute()

### –®–∞–≥ 1: `UMA.select()` - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–æ–π

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query.
    
    All logic (FROM parsing, namespace resolution, context creation,
    access control) is handled by JSQLExecutor.
    """
    executor = JSQLExecutor(
        engine=self.registry.get_engine(),  # From registry or context
        metadata_provider=...  # Need to get this somehow
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
        namespace_override=namespace,
    )
    
    result = await executor.execute(jsql, params)
    return result.to_dict()
```

**–ü—Ä–æ–±–ª–µ–º–∞**: –í `UMA` –Ω–µ—Ç –ø—Ä—è–º–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ `engine` –∏ `metadata_provider` –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.

–ù—É–∂–Ω–æ –ª–∏–±–æ:
- –°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–Ω–æ –∫–∞–∫–æ–π namespace?)
- –î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç–æ–¥ `UMA.get_default_engine()`?

### –®–∞–≥ 2: `JSQLExecutor.__init__` - –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞

```python
def __init__(
    self,
    engine: Engine,
    metadata_provider: Any,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    cache_enabled: bool = True,
    namespace_override: str | None = None,
) -> None:
    self._engine = engine
    self._metadata_provider = metadata_provider
    self._namespace_configs = namespace_configs
    self._user_context = user_context
    self._cache_backend = cache_backend
    self._cache_enabled = cache_enabled
    self._namespace_override = namespace_override
```

### –®–∞–≥ 3: `JSQLExecutor.execute()` - –∫–æ–Ω—Ç–µ–∫—Å—Ç –∑–¥–µ—Å—å

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    """Execute JSQL with full logic."""
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name (handles CTEs)
    if isinstance(from_entity, str):
        entity_name = from_entity
        if self._is_cte_name(entity_name, jsql):
            entity_name = self._resolve_cte_base_entity(entity_name, jsql)
    else:
        entity_name = self._extract_from_subquery(from_entity)
    
    # Resolve namespace
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace or self._namespace_override
    if not actual_namespace:
        if len(self._namespace_configs) == 1:
            actual_namespace = next(iter(self._namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Create context NOW (when namespace is known)
    context = UMAContext(
        engine=self._engine,
        metadata_provider=self._metadata_provider,
        namespace=actual_namespace,
        user_context=self._user_context,
    )
    
    # Try cache
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, context.user_context, context.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            self._check_select_access(cached.entities, context)
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    parser = JSQLParser(context)
    sql_query = await parser.parse(jsql)
    
    # Extract entities from SELECT clause
    select_entities = self._extract_select_entities(jsql)
    
    # Check access to all SELECT entities
    self._check_access_to_entities(select_entities, context)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params, context)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=context.engine.dialect.name,
            entities=list(select_entities),
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result

def _is_cte_name(self, name: str, jsql: dict) -> bool:
    """Check if name is a CTE defined in WITH clause."""
    with_clauses = jsql.get('with')
    if not with_clauses:
        return False
    
    if isinstance(with_clauses, list):
        return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
    elif isinstance(with_clauses, dict):
        return name in with_clauses
    
    return False

def _resolve_cte_base_entity(self, cte_name: str, jsql: dict) -> str:
    """Resolve base entity from CTE definition."""
    with_clauses = jsql.get('with')
    if isinstance(with_clauses, list):
        for cte in with_clauses:
            if isinstance(cte, dict) and cte.get('name') == cte_name:
                cte_query = cte.get('query')
                if isinstance(cte_query, dict):
                    return cte_query.get('from', cte_name)
    elif isinstance(with_clauses, dict):
        cte_def = with_clauses.get(cte_name)
        if isinstance(cte_def, dict):
            return cte_def.get('from', cte_name)
    
    return cte_name

def _extract_from_subquery(self, subquery: dict) -> str:
    """Extract entity name from subquery in FROM."""
    if isinstance(subquery, dict):
        return subquery.get('from', '')
    return ''

async def _execute_query(self, sql_query, params: dict | None, context: UMAContext) -> QueryResult:
    """Execute SQL query and return result."""
    # Use context.engine to execute
    conn = await context.engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()

def _extract_select_entities(self, jsql: dict) -> set[str]:
    """Extract entities from SELECT clause only."""
    entities: set[str] = set()
    
    select_clause = jsql.get('select')
    if not select_clause:
        return entities
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entities_from_expression(item, jsql))
    
    return entities

def _extract_entities_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        if expr == '*' or '.' not in expr:
            from_entity = jsql.get('from')
            if from_entity and isinstance(from_entity, str):
                entities.add(from_entity)
        elif '.' in expr:
            entities.add(expr.split('.', 1)[0])
    elif isinstance(expr, dict):
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entities.add(field.split('.', 1)[0])
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entities_from_expression(arg, jsql))
        elif 'expr' in expr:
            entities.update(self._extract_entities_from_expression(expr['expr'], jsql))
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entities_from_expression(expr['left'], jsql))
            entities.update(self._extract_entities_from_expression(expr['right'], jsql))
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self._extract_select_entities(subquery))
    
    return entities

def _check_select_access(self, entities: list[str], context: UMAContext) -> None:
    """Check access to entities in SELECT clause."""
    if not hasattr(context.metadata_provider, 'can'):
        return
    
    for entity_name in entities:
        if not context.metadata_provider.can(entity_name, Operation.SELECT, context):
            raise UMAAccessDeniedError(entity_name, Operation.SELECT.value)

def _check_access_to_entities(self, entities: set[str], context: UMAContext) -> None:
    """Check access to all SELECT entities."""
    self._check_select_access(list(entities), context)
```

### –®–∞–≥ 4: `UMA.select()` - –ø—Ä–æ–±–ª–µ–º–∞ —Å engine/metadata_provider

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query."""
    
    # Get engine and metadata from namespace config
    if namespace:
        config = self._get_namespace_config(namespace)
        engine = config.engine
        metadata_provider = config.metadata_provider
    else:
        # Use default namespace or first available
        if self.default_namespace:
            config = self.namespace_configs[self.default_namespace]
        else:
            config = next(iter(self.namespace_configs.values()))
        engine = config.engine
        metadata_provider = config.metadata_provider
    
    executor = JSQLExecutor(
        engine=engine,
        metadata_provider=metadata_provider,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
        namespace_override=namespace,
    )
    
    result = await executor.execute(jsql, params)
    return result.to_dict()
```

### –®–∞–≥ 5: –£–¥–∞–ª–∏—Ç—å –∏–∑ UMA

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
# - –°—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –≤ select()
```

### –®–∞–≥ 6: `CachedQuery` - –¥–æ–±–∞–≤–∏—Ç—å entities

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)
```

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –ë—ã–ª–æ | –°—Ç–∞–ª–æ |
|-----------|--------|--------|
| `UMA.select()` | –ü–∞—Ä—Å–∏–Ω–≥, –∫–æ–Ω—Ç–µ–∫—Å—Ç, –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ | –ü–æ–ª—É—á–∞–µ—Ç config, —Å–æ–∑–¥–∞–µ—Ç executor |
| `JSQLExecutor.__init__` | –ü—Ä–∏–Ω–∏–º–∞–ª –∫–æ–Ω—Ç–µ–∫—Å—Ç | –ü—Ä–∏–Ω–∏–º–∞–µ—Ç engine, metadata, namespace_configs |
| `JSQLExecutor.execute()` | –¢–æ–ª—å–∫–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ | –ü–∞—Ä—Å–∏–Ω–≥ FROM, —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä–∫–∞ SELECT –¥–æ—Å—Ç—É–ø–∞ |

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query.
    
    All logic (FROM parsing, namespace resolution, context creation,
    access control) is handled by JSQLExecutor.
    """
    executor = JSQLExecutor(
        engine=self.registry.get_engine(),  # From registry or context
        metadata_provider=...  # Need to get this somehow
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
        namespace_override=namespace,
    )
    
    result = await executor.execute(jsql, params)
    return result.to_dict()
```

```python
def __init__(
    self,
    engine: Engine,
    metadata_provider: Any,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    cache_enabled: bool = True,
    namespace_override: str | None = None,
) -> None:
    self._engine = engine
    self._metadata_provider = metadata_provider
    self._namespace_configs = namespace_configs
    self._user_context = user_context
    self._cache_backend = cache_backend
    self._cache_enabled = cache_enabled
    self._namespace_override = namespace_override
```

```python
async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
    """Execute JSQL with full logic."""
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    # Parse entity name (handles CTEs)
    if isinstance(from_entity, str):
        entity_name = from_entity
        if self._is_cte_name(entity_name, jsql):
            entity_name = self._resolve_cte_base_entity(entity_name, jsql)
    else:
        entity_name = self._extract_from_subquery(from_entity)
    
    # Resolve namespace
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace or self._namespace_override
    if not actual_namespace:
        if len(self._namespace_configs) == 1:
            actual_namespace = next(iter(self._namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Create context NOW (when namespace is known)
    context = UMAContext(
        engine=self._engine,
        metadata_provider=self._metadata_provider,
        namespace=actual_namespace,
        user_context=self._user_context,
    )
    
    # Try cache
    if self._cache_enabled and self._cache_backend:
        cache_key = make_cache_key(jsql, context.user_context, context.namespace)
        cached = self._cache_backend.get(cache_key)
        
        if cached:
            self._check_select_access(cached.entities, context)
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - parse and compile
    parser = JSQLParser(context)
    sql_query = await parser.parse(jsql)
    
    # Extract entities from SELECT clause
    select_entities = self._extract_select_entities(jsql)
    
    # Check access to all SELECT entities
    self._check_access_to_entities(select_entities, context)
    
    # Execute and cache
    result = await self._execute_query(sql_query, params, context)
    
    if self._cache_enabled and self._cache_backend:
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping=self._params_mapping,
            dialect=context.engine.dialect.name,
            entities=list(select_entities),
        )
        self._cache_backend.set(cache_key, cached_query)
    
    return result

def _is_cte_name(self, name: str, jsql: dict) -> bool:
    """Check if name is a CTE defined in WITH clause."""
    with_clauses = jsql.get('with')
    if not with_clauses:
        return False
    
    if isinstance(with_clauses, list):
        return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
    elif isinstance(with_clauses, dict):
        return name in with_clauses
    
    return False

def _resolve_cte_base_entity(self, cte_name: str, jsql: dict) -> str:
    """Resolve base entity from CTE definition."""
    with_clauses = jsql.get('with')
    if isinstance(with_clauses, list):
        for cte in with_clauses:
            if isinstance(cte, dict) and cte.get('name') == cte_name:
                cte_query = cte.get('query')
                if isinstance(cte_query, dict):
                    return cte_query.get('from', cte_name)
    elif isinstance(with_clauses, dict):
        cte_def = with_clauses.get(cte_name)
        if isinstance(cte_def, dict):
            return cte_def.get('from', cte_name)
    
    return cte_name

def _extract_from_subquery(self, subquery: dict) -> str:
    """Extract entity name from subquery in FROM."""
    if isinstance(subquery, dict):
        return subquery.get('from', '')
    return ''

async def _execute_query(self, sql_query, params: dict | None, context: UMAContext) -> QueryResult:
    """Execute SQL query and return result."""
    # Use context.engine to execute
    conn = await context.engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()

def _extract_select_entities(self, jsql: dict) -> set[str]:
    """Extract entities from SELECT clause only."""
    entities: set[str] = set()
    
    select_clause = jsql.get('select')
    if not select_clause:
        return entities
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entities_from_expression(item, jsql))
    
    return entities

def _extract_entities_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        if expr == '*' or '.' not in expr:
            from_entity = jsql.get('from')
            if from_entity and isinstance(from_entity, str):
                entities.add(from_entity)
        elif '.' in expr:
            entities.add(expr.split('.', 1)[0])
    elif isinstance(expr, dict):
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entities.add(field.split('.', 1)[0])
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entities_from_expression(arg, jsql))
        elif 'expr' in expr:
            entities.update(self._extract_entities_from_expression(expr['expr'], jsql))
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entities_from_expression(expr['left'], jsql))
            entities.update(self._extract_entities_from_expression(expr['right'], jsql))
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self._extract_select_entities(subquery))
    
    return entities

def _check_select_access(self, entities: list[str], context: UMAContext) -> None:
    """Check access to entities in SELECT clause."""
    if not hasattr(context.metadata_provider, 'can'):
        return
    
    for entity_name in entities:
        if not context.metadata_provider.can(entity_name, Operation.SELECT, context):
            raise UMAAccessDeniedError(entity_name, Operation.SELECT.value)

def _check_access_to_entities(self, entities: set[str], context: UMAContext) -> None:
    """Check access to all SELECT entities."""
    self._check_select_access(list(entities), context)
```

```python
async def select(self, jsql: dict, params: dict | None = None, 
               user_context: Any = None, namespace: str | None = None) -> dict:
    """Execute JSQL query."""
    
    # Get engine and metadata from namespace config
    if namespace:
        config = self._get_namespace_config(namespace)
        engine = config.engine
        metadata_provider = config.metadata_provider
    else:
        # Use default namespace or first available
        if self.default_namespace:
            config = self.namespace_configs[self.default_namespace]
        else:
            config = next(iter(self.namespace_configs.values()))
        engine = config.engine
        metadata_provider = config.metadata_provider
    
    executor = JSQLExecutor(
        engine=engine,
        metadata_provider=metadata_provider,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend,
        cache_enabled=self.cache_enabled,
        namespace_override=namespace,
    )
    
    result = await executor.execute(jsql, params)
    return result.to_dict()
```

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
# - –°—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –≤ select()
```

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)
```

---

**User**

(20260115-044935) –Ø –ø—Ä–µ–¥–ª–∞–≥–∞—é –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥.

(20260115-044950) –£–¥–∞–ª–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ JSQLExecutor –ø–æ–ª–Ω–æ—Å—Ç—å—é, –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –∫–∞–∫ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º—ë–Ω.
`JSQLExecutor.execute()` —Å–¥–µ–ª–∞—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–º –º–µ—Ç–æ–¥–æ–º, –∏–ª–∏ –º–µ—Ç–æ–¥–æ–º –∫–ª–∞—Å—Å–∞.

(20260115-045045) –í `JSQLExecutor.execute()` –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å cache_backend, –ø—Ä–∏—á—ë–º —Ç–æ–ª—å–∫–æ –≤ —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ `UMA.cache_enabled` —Å–æ–¥–µ—Ä–∂–∏—Ç `True`.

(20260115-045142) –í `JSQLExecutor.execute()` –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å `namespace_configs` –∏–∑ `UMA`, –∫–æ—Ç–æ—Ä—ã–π —Ö—Ä–∞–Ω–∏—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∏–º–µ–Ω–∏ namespace –ø–∞—Ä–µ `(engine, metadata_provider)` ‚Äì —Å–º. `NamespaceConfig`.
–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –∫–æ–≥–¥–∞ –≤ `JSQLExecutor.execute()` —Å—Ç–∞–Ω–µ—Ç –∏–∑–≤–µ—Å—Ç–Ω—ã–º namespace, –ø–æ–ª—É—á–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π engine –Ω–µ —Å–æ—Å—Ç–∞–≤–∏—Ç —Ç—Ä—É–¥–∞.

(20260115-045654) –í–æ—Ç —ç—Ç–æ:
```python
        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)
```
–≤—ã–Ω–µ—Å—Ç–∏ –≤ —Ñ—É–Ω–∫—Ü–∏—é-helper, –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç metadata provider, –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –≤ `JSQLExecutor.execute()`.

(20260115-045836) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–π —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–í –∫–æ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è! –≠—Ç–æ —É–ø—Ä–æ—â–∞–µ—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –∏ –¥–µ–ª–∞–µ—Ç `JSQLExecutor` stateless.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: Stateless JSQLExecutor

### –®–∞–≥ 1: –°–æ–∑–¥–∞—Ç—å helper-—Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞

```python
# –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ src/namerec/uma/core/access.py (–∏–ª–∏ –≤ utils.py)
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.types import Operation
from typing import Any


def check_access(
    metadata_provider: Any,
    entity_name: str,
    operation: Operation | str,
    user_context: Any,
    extra: dict | None = None,
) -> None:
    """
    Check access and raise exception if access denied.
    
    Args:
        metadata_provider: Metadata provider with can() method
        entity_name: Entity name (empty string for "list entities" operation)
        operation: Operation name
        user_context: User context for access control
        extra: Additional context data
    
    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)
    
    # Check if metadata provider has can() method
    if hasattr(metadata_provider, 'can'):
        # Build minimal context for can() call
        if extra:
            # Use existing context if provided
            from namerec.uma.core.context import UMAContext
            context = UMAContext(
                engine=None,  # Not needed for access check
                metadata_provider=metadata_provider,
                namespace='',  # Not needed for access check
                user_context=user_context,
                extra=extra,
            )
            if not metadata_provider.can(entity_name, operation, context):
                raise UMAAccessDeniedError(entity_name, operation.value)
        else:
            # Simple can() call without context object
            if not metadata_provider.can(entity_name, operation, user_context):
                raise UMAAccessDeniedError(entity_name, operation.value)
```

### –®–∞–≥ 2: `JSQLExecutor` - —Å–¥–µ–ª–∞—Ç—å stateless

```python
class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""
    
    # No __init__ or state!
    
    @classmethod
    async def execute(
        cls,
        jsql: dict,
        engine: Engine,
        metadata_provider: Any,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL query with full access control.
        
        Args:
            jsql: JSQL query dictionary
            engine: SQLAlchemy Engine for execution
            metadata_provider: Metadata provider for access control
            namespace_configs: Namespace configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters
        
        Returns:
            QueryResult with metadata and data
        
        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Parse FROM to resolve namespace
        from_entity = jsql.get('from')
        if not from_entity:
            raise ValueError("JSQL must contain 'from' field")
        
        # Parse entity name (handles CTEs)
        if isinstance(from_entity, str):
            entity_name = from_entity
            if cls._is_cte_name(entity_name, jsql):
                entity_name = cls._resolve_cte_base_entity(entity_name, jsql)
        else:
            entity_name = cls._extract_from_subquery(from_entity)
        
        # Resolve namespace and get config
        entity = parse_entity_name(entity_name)
        
        # Determine actual namespace
        actual_namespace = entity.namespace
        if not actual_namespace:
            if len(namespace_configs) == 1:
                actual_namespace = next(iter(namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )
        
        # Get namespace config
        if actual_namespace not in namespace_configs:
            available = ', '.join(namespace_configs.keys())
            raise ValueError(f'Namespace "{actual_namespace}" not found. Available: {available}')
        
        config = namespace_configs[actual_namespace]
        
        # Try cache (only if cache_backend provided)
        if cache_backend:
            from namerec.uma.jsql.cache.keys import make_cache_key
            
            cache_key = make_cache_key(jsql, user_context, actual_namespace)
            cached = cache_backend.get(cache_key)
            
            if cached:
                # Check access to SELECT entities (even for cached queries!)
                from namerec.uma.core.access import check_access
                check_access(
                    metadata_provider,
                    entity_name='',
                    operation=Operation.SELECT,
                    user_context=user_context,
                    extra={'entities': cached.entities},
                )
                return QueryResult.from_cached(cached, params)
        
        # Cache miss - parse and compile
        from namerec.uma.core.context import UMAContext
        context = UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
        )
        
        parser = JSQLParser(context)
        sql_query = await parser.parse(jsql)
        
        # Extract entities from SELECT clause only
        select_entities = cls._extract_select_entities(jsql)
        
        # Check access to all SELECT entities
        for select_entity in select_entities:
            from namerec.uma.core.access import check_access
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )
        
        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)
        
        # Cache result
        if cache_backend:
            from namerec.uma.jsql.cache.keys import CachedQuery
            
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},  # Extract from parser if needed
                dialect=config.engine.dialect.name,
                entities=list(select_entities),
            )
            cache_backend.set(cache_key, cached_query)
        
        return result
    
    @staticmethod
    def _is_cte_name(name: str, jsql: dict) -> bool:
        """Check if name is a CTE defined in WITH clause."""
        with_clauses = jsql.get('with')
        if not with_clauses:
            return False
        
        if isinstance(with_clauses, list):
            return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
        elif isinstance(with_clauses, dict):
            return name in with_clauses
        
        return False
    
    @staticmethod
    def _resolve_cte_base_entity(cte_name: str, jsql: dict) -> str:
        """Resolve base entity from CTE definition."""
        with_clauses = jsql.get('with')
        if isinstance(with_clauses, list):
            for cte in with_clauses:
                if isinstance(cte, dict) and cte.get('name') == cte_name:
                    cte_query = cte.get('query')
                    if isinstance(cte_query, dict):
                        return cte_query.get('from', cte_name)
        elif isinstance(with_clauses, dict):
            cte_def = with_clauses.get(cte_name)
            if isinstance(cte_def, dict):
                return cte_def.get('from', cte_name)
        
        return cte_name
    
    @staticmethod
    def _extract_from_subquery(subquery: dict) -> str:
        """Extract entity name from subquery in FROM."""
        if isinstance(subquery, dict):
            return subquery.get('from', '')
        return ''
    
    @staticmethod
    async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return QueryResult.from_db_result(result)
        finally:
            await conn.close()
    
    @staticmethod
    def _extract_select_entities(jsql: dict) -> set[str]:
        """Extract entities from SELECT clause only."""
        entities: set[str] = set()
        
        select_clause = jsql.get('select')
        if not select_clause:
            return entities
        
        select_items = select_clause if isinstance(select_clause, list) else [select_clause]
        
        for item in select_items:
            entities.update(JSQLExecutor._extract_entities_from_expression(item, jsql))
        
        return entities
    
    @staticmethod
    def _extract_entities_from_expression(expr: Any, jsql: dict) -> set[str]:
        """Extract entity names from expression."""
        entities: set[str] = set()
        
        if isinstance(expr, str):
            if expr == '*' or '.' not in expr:
                from_entity = jsql.get('from')
                if from_entity and isinstance(from_entity, str):
                    entities.add(from_entity)
            elif '.' in expr:
                entities.add(expr.split('.', 1)[0])
        elif isinstance(expr, dict):
            if 'field' in expr:
                field = expr['field']
                if isinstance(field, str) and '.' in field:
                    entities.add(field.split('.', 1)[0])
            elif 'func' in expr:
                if args := expr.get('args'):
                    for arg in args if isinstance(args, list) else [args]:
                        entities.update(JSQLExecutor._extract_entities_from_expression(arg, jsql))
            elif 'expr' in expr:
                entities.update(JSQLExecutor._extract_entities_from_expression(expr['expr'], jsql))
            elif 'left' in expr and 'right' in expr:
                entities.update(JSQLExecutor._extract_entities_from_expression(expr['left'], jsql))
                entities.update(JSQLExecutor._extract_entities_from_expression(expr['right'], jsql))
            elif 'subquery' in expr:
                subquery = expr['subquery']
                if isinstance(subquery, dict):
                    entities.update(JSQLExecutor._extract_select_entities(subquery))
        
        return entities
```

### –®–∞–≥ 3: `UMA.select()` - —É–ø—Ä–æ—Å—Ç–∏—Ç—å –¥–æ –ø—Ä–µ–¥–µ–ª–∞

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query.
    
    All logic is handled by stateless JSQLExecutor.
    """
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        # Get engine/metadata from namespace config
        engine=self._get_engine_for_namespace(namespace),
        metadata_provider=self._get_metadata_provider_for_namespace(namespace),
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,  # Only if enabled
    )
    
    return result.to_dict()
```

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù—É–∂–Ω—ã –º–µ—Ç–æ–¥—ã `_get_engine_for_namespace()` –∏ `_get_metadata_provider_for_namespace()`.

–î–æ–±–∞–≤–∏—Ç—å –≤ `UMA`:

```python
def _get_engine_for_namespace(self, namespace: str | None) -> Engine:
    """Get engine for namespace (resolves default if None)."""
    config = self._get_namespace_config(namespace)
    return config.engine

def _get_metadata_provider_for_namespace(self, namespace: str | None) -> Any:
    """Get metadata provider for namespace (resolves default if None)."""
    config = self._get_namespace_config(namespace)
    return config.metadata_provider
```

### –®–∞–≥ 4: `UMA._check_access()` - –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ helper

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é, –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞:
from namerec.uma.core.access import check_access
```

–ò –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –¥—Ä—É–≥–∏—Ö –º–µ—Ç–æ–¥–∞—Ö (`read`, `save`, `delete`, `entity_details`):

```python
def _check_access(
    self,
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """Check access using helper function."""
    from namerec.uma.core.access import check_access
    
    check_access(
        metadata_provider=context.metadata_provider,
        entity_name=entity_name,
        operation=operation,
        user_context=context.user_context,
    )
```

### –®–∞–≥ 5: `CachedQuery` - –¥–æ–±–∞–≤–∏—Ç—å entities

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)  # Entities in SELECT clause
```

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –ë—ã–ª–æ | –°—Ç–∞–ª–æ |
|-----------|--------|--------|
| `JSQLExecutor` | Stateful –∫–ª–∞—Å—Å —Å `__init__` | Stateless –∫–ª–∞—Å—Å —Å `@classmethod execute()` |
| `UMA.select()` | –°–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ | –ü—Ä–æ—Å—Ç–∞—è –¥–µ–ª–µ–≥–∞—Ü–∏—è –≤ `JSQLExecutor.execute()` |
| –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ | –í `_check_access()` UMA | Helper-—Ñ—É–Ω–∫—Ü–∏—è `check_access()` |
| –ö—ç—à | –ü–µ—Ä–µ–¥–∞–≤–∞–ª—Å—è –≤—Å–µ–≥–¥–∞ | –ü–µ—Ä–µ–¥–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ `self.cache_enabled` |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- ‚úÖ JSQLExecutor –ø–æ–ª–Ω–æ—Å—Ç—å—é stateless
- ‚úÖ –ö—ç—à –Ω–µ —Å–æ–∑–¥–∞–µ—Ç—Å—è –µ—Å–ª–∏ –Ω–µ –Ω—É–∂–µ–Ω
- ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ - —á–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è (reusable)
- ‚úÖ SRP —Å–æ–±–ª—é–¥–µ–Ω

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
# –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ src/namerec/uma/core/access.py (–∏–ª–∏ –≤ utils.py)
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.types import Operation
from typing import Any


def check_access(
    metadata_provider: Any,
    entity_name: str,
    operation: Operation | str,
    user_context: Any,
    extra: dict | None = None,
) -> None:
    """
    Check access and raise exception if access denied.
    
    Args:
        metadata_provider: Metadata provider with can() method
        entity_name: Entity name (empty string for "list entities" operation)
        operation: Operation name
        user_context: User context for access control
        extra: Additional context data
    
    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)
    
    # Check if metadata provider has can() method
    if hasattr(metadata_provider, 'can'):
        # Build minimal context for can() call
        if extra:
            # Use existing context if provided
            from namerec.uma.core.context import UMAContext
            context = UMAContext(
                engine=None,  # Not needed for access check
                metadata_provider=metadata_provider,
                namespace='',  # Not needed for access check
                user_context=user_context,
                extra=extra,
            )
            if not metadata_provider.can(entity_name, operation, context):
                raise UMAAccessDeniedError(entity_name, operation.value)
        else:
            # Simple can() call without context object
            if not metadata_provider.can(entity_name, operation, user_context):
                raise UMAAccessDeniedError(entity_name, operation.value)
```

```python
class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""
    
    # No __init__ or state!
    
    @classmethod
    async def execute(
        cls,
        jsql: dict,
        engine: Engine,
        metadata_provider: Any,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL query with full access control.
        
        Args:
            jsql: JSQL query dictionary
            engine: SQLAlchemy Engine for execution
            metadata_provider: Metadata provider for access control
            namespace_configs: Namespace configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters
        
        Returns:
            QueryResult with metadata and data
        
        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        # Parse FROM to resolve namespace
        from_entity = jsql.get('from')
        if not from_entity:
            raise ValueError("JSQL must contain 'from' field")
        
        # Parse entity name (handles CTEs)
        if isinstance(from_entity, str):
            entity_name = from_entity
            if cls._is_cte_name(entity_name, jsql):
                entity_name = cls._resolve_cte_base_entity(entity_name, jsql)
        else:
            entity_name = cls._extract_from_subquery(from_entity)
        
        # Resolve namespace and get config
        entity = parse_entity_name(entity_name)
        
        # Determine actual namespace
        actual_namespace = entity.namespace
        if not actual_namespace:
            if len(namespace_configs) == 1:
                actual_namespace = next(iter(namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )
        
        # Get namespace config
        if actual_namespace not in namespace_configs:
            available = ', '.join(namespace_configs.keys())
            raise ValueError(f'Namespace "{actual_namespace}" not found. Available: {available}')
        
        config = namespace_configs[actual_namespace]
        
        # Try cache (only if cache_backend provided)
        if cache_backend:
            from namerec.uma.jsql.cache.keys import make_cache_key
            
            cache_key = make_cache_key(jsql, user_context, actual_namespace)
            cached = cache_backend.get(cache_key)
            
            if cached:
                # Check access to SELECT entities (even for cached queries!)
                from namerec.uma.core.access import check_access
                check_access(
                    metadata_provider,
                    entity_name='',
                    operation=Operation.SELECT,
                    user_context=user_context,
                    extra={'entities': cached.entities},
                )
                return QueryResult.from_cached(cached, params)
        
        # Cache miss - parse and compile
        from namerec.uma.core.context import UMAContext
        context = UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
        )
        
        parser = JSQLParser(context)
        sql_query = await parser.parse(jsql)
        
        # Extract entities from SELECT clause only
        select_entities = cls._extract_select_entities(jsql)
        
        # Check access to all SELECT entities
        for select_entity in select_entities:
            from namerec.uma.core.access import check_access
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )
        
        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)
        
        # Cache result
        if cache_backend:
            from namerec.uma.jsql.cache.keys import CachedQuery
            
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},  # Extract from parser if needed
                dialect=config.engine.dialect.name,
                entities=list(select_entities),
            )
            cache_backend.set(cache_key, cached_query)
        
        return result
    
    @staticmethod
    def _is_cte_name(name: str, jsql: dict) -> bool:
        """Check if name is a CTE defined in WITH clause."""
        with_clauses = jsql.get('with')
        if not with_clauses:
            return False
        
        if isinstance(with_clauses, list):
            return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
        elif isinstance(with_clauses, dict):
            return name in with_clauses
        
        return False
    
    @staticmethod
    def _resolve_cte_base_entity(cte_name: str, jsql: dict) -> str:
        """Resolve base entity from CTE definition."""
        with_clauses = jsql.get('with')
        if isinstance(with_clauses, list):
            for cte in with_clauses:
                if isinstance(cte, dict) and cte.get('name') == cte_name:
                    cte_query = cte.get('query')
                    if isinstance(cte_query, dict):
                        return cte_query.get('from', cte_name)
        elif isinstance(with_clauses, dict):
            cte_def = with_clauses.get(cte_name)
            if isinstance(cte_def, dict):
                return cte_def.get('from', cte_name)
        
        return cte_name
    
    @staticmethod
    def _extract_from_subquery(subquery: dict) -> str:
        """Extract entity name from subquery in FROM."""
        if isinstance(subquery, dict):
            return subquery.get('from', '')
        return ''
    
    @staticmethod
    async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return QueryResult.from_db_result(result)
        finally:
            await conn.close()
    
    @staticmethod
    def _extract_select_entities(jsql: dict) -> set[str]:
        """Extract entities from SELECT clause only."""
        entities: set[str] = set()
        
        select_clause = jsql.get('select')
        if not select_clause:
            return entities
        
        select_items = select_clause if isinstance(select_clause, list) else [select_clause]
        
        for item in select_items:
            entities.update(JSQLExecutor._extract_entities_from_expression(item, jsql))
        
        return entities
    
    @staticmethod
    def _extract_entities_from_expression(expr: Any, jsql: dict) -> set[str]:
        """Extract entity names from expression."""
        entities: set[str] = set()
        
        if isinstance(expr, str):
            if expr == '*' or '.' not in expr:
                from_entity = jsql.get('from')
                if from_entity and isinstance(from_entity, str):
                    entities.add(from_entity)
            elif '.' in expr:
                entities.add(expr.split('.', 1)[0])
        elif isinstance(expr, dict):
            if 'field' in expr:
                field = expr['field']
                if isinstance(field, str) and '.' in field:
                    entities.add(field.split('.', 1)[0])
            elif 'func' in expr:
                if args := expr.get('args'):
                    for arg in args if isinstance(args, list) else [args]:
                        entities.update(JSQLExecutor._extract_entities_from_expression(arg, jsql))
            elif 'expr' in expr:
                entities.update(JSQLExecutor._extract_entities_from_expression(expr['expr'], jsql))
            elif 'left' in expr and 'right' in expr:
                entities.update(JSQLExecutor._extract_entities_from_expression(expr['left'], jsql))
                entities.update(JSQLExecutor._extract_entities_from_expression(expr['right'], jsql))
            elif 'subquery' in expr:
                subquery = expr['subquery']
                if isinstance(subquery, dict):
                    entities.update(JSQLExecutor._extract_select_entities(subquery))
        
        return entities
```

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query.
    
    All logic is handled by stateless JSQLExecutor.
    """
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        # Get engine/metadata from namespace config
        engine=self._get_engine_for_namespace(namespace),
        metadata_provider=self._get_metadata_provider_for_namespace(namespace),
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,  # Only if enabled
    )
    
    return result.to_dict()
```

```python
def _get_engine_for_namespace(self, namespace: str | None) -> Engine:
    """Get engine for namespace (resolves default if None)."""
    config = self._get_namespace_config(namespace)
    return config.engine

def _get_metadata_provider_for_namespace(self, namespace: str | None) -> Any:
    """Get metadata provider for namespace (resolves default if None)."""
    config = self._get_namespace_config(namespace)
    return config.metadata_provider
```

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é, –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞:
from namerec.uma.core.access import check_access
```

```python
def _check_access(
    self,
    entity_name: str,
    operation: Operation | str,
    context: UMAContext,
) -> None:
    """Check access using helper function."""
    from namerec.uma.core.access import check_access
    
    check_access(
        metadata_provider=context.metadata_provider,
        entity_name=entity_name,
        operation=operation,
        user_context=context.user_context,
    )
```

```python
@dataclass
class CachedQuery:
    sql: str
    params_mapping: dict[str, str]
    dialect: str
    entities: list[str] = field(default_factory=list)  # Entities in SELECT clause
```

---

**User**

(20260115-052445)
```
class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""
    
    # No __init__ or state!
    
    @classmethod
    async def execute(
        cls,
        jsql: dict,
        engine: Engine,
        metadata_provider: Any,
        namespace_configs: Mapping[str, NamespaceConfig],
```
–ù–µ —Å–æ–≤—Å–µ–º –ø–æ–Ω–∏–º–∞—é, –∑–∞—á–µ–º –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ `engine` –∏ `metadata_provider` (–∫–æ—Ç–æ—Ä—ã–π Any –∫ —Ç–æ–º—É –∂–µ), –µ—Å–ª–∏ –≤—Å—é —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∏–∑ `namespace_configs`, –∫–∞–∫ —Ç–æ–ª—å–∫–æ —Å—Ç–∞–Ω–µ—Ç –∏–∑–≤–µ—Å—Ç–µ–Ω namespace.

(20260115-055121) –î–∞–ª–µ–µ, —è –≤–∏–∂—É –Ω–∞—Ä—É—à–µ–Ω–∏–µ SRP –≤ `JSQLExecutor.execute()`: —Ç–∞–º –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è, –≤ —Å—É—â–Ω–æ—Å—Ç–∏ —Ç–æ, –∑–∞ —á—Ç–æ —É–∂–µ –æ—Ç–≤–µ—á–∞–µ—Ç JSQLParser ‚Äì —Ä–∞–∑–±–æ—Ä –∑–∞–ø—Ä–æ—Å–∞ –≤ —á–∞—Å—Ç–∏ –±–ª–æ–∫–∞ `SELECT`.
–ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤ JSQLParser, –∏ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–∏–º –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É:
1) –†–∞–∑–æ–±—Ä–∞—Ç—å –∑–∞–ø—Ä–æ—Å –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ JSQLParser.
2) –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π, –ø–æ–ª—è –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é—Ç –≤ –±–ª–æ–∫–µ `SELECT` –∑–∞–ø—Ä–æ—Å–∞ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ JSQL.
3) –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–ª–Ω–æ–º–æ—á–∏—è –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏.

(20260115-055629) –ù–æ JSQLParser-—É —Ç—Ä–µ–±—É–µ—Ç—Å—è MatadataProvider –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `get_table`). –î–ª—è —ç—Ç–æ–π —Ü–µ–ª–∏ —Å–æ–∑–¥–∞—ë—Ç—Å—è –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ `JSQLExecutor.execute()`.
–ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è:
1) –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å.
2) –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ JSQLParser mapping `namespace_configs`, –¥–æ—Ç–∫—É–¥–∞ JSQLParser —Å–º–æ–∂–µ—Ç –∏–∑–≤–ª–µ—á—å –Ω—É–∂–Ω—ã–π MatadataProvider –ø–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–º—É –Ω–∞ —ç—Ç–æ—Ç –º–æ–º–µ–Ω—Ç `namespace`, –∏ –≤—ã–∑–≤–∞—Ç—å `get_table()`.

(20260115-055924) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ! –í—ã –∞–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–∞–≤—ã - —ç—Ç–æ –Ω–∞—Ä—É—à–µ–Ω–∏–µ SRP –∏ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å JSQLParser

### –®–∞–≥ 1: `JSQLParser.__init__` - –¥–æ–±–∞–≤–∏—Ç—å namespace_configs

```python
class JSQLParser:
    """
    JSQL parser with namespace support.
    
    Parses JSQL and provides access to:
    - Parsed SQLAlchemy AST
    - Entities used in SELECT clause (for access control)
    """
    
    def __init__(
        self,
        context: UMAContext,
        namespace_configs: Mapping[str, NamespaceConfig] | None = None,
    ) -> None:
        self.context = context
        self.namespace_configs = namespace_configs  # For entity extraction
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        
        # Operator handler dispatch table
        self._operator_handlers: dict[str, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            # ... existing handlers ...
        }
```

### –®–∞–≥ 2: `JSQLParser.get_select_entities()` - –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥

```python
def get_select_entities(self, jsql: dict) -> list[str]:
    """
    Extract entities from SELECT clause for access control.
    
    This method is called AFTER parsing the query, so we can:
    - Use parsed information (ctes, table aliases)
    - Resolve CTE references to base entities
    
    Args:
        jsql: JSQL query dictionary
    
    Returns:
        List of entity names (qualified with namespace if present)
    
    Note:
        Only returns entities whose columns appear in SELECT clause,
        not entities in WHERE, JOINs, or other clauses.
    """
    entities: set[str] = set()
    
    select_clause = jsql.get('select')
    if not select_clause:
        return list(entities)
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entity_from_select_item(item, jsql))
    
    return list(entities)

def _extract_entity_from_select_item(self, item: Any, jsql: dict) -> set[str]:
    """Extract entity name from single SELECT item."""
    entities: set[str] = set()
    
    if isinstance(item, str):
        # '*' or unqualified column - use FROM entity
        if item == '*' or '.' not in item:
            from_entity = jsql.get('from')
            if isinstance(from_entity, str):
                # Check if FROM is a CTE
                if self._is_cte_reference(from_entity, jsql):
                    real_entity = self._resolve_cte_base_entity(from_entity, jsql)
                    entities.add(real_entity)
                else:
                    entities.add(from_entity)
        elif '.' in item:
            # Qualified column - extract entity
            entity_part = item.split('.', 1)[0]
            # Check if it's a CTE reference
            if self._is_cte_reference(entity_part, jsql):
                real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                entities.add(real_entity)
            else:
                entities.add(entity_part)
    
    elif isinstance(item, dict):
        # Complex SELECT item (field, func, expr, subquery, etc.)
        if 'field' in item:
            field = item['field']
            if isinstance(field, str) and '.' in field:
                entity_part = field.split('.', 1)[0]
                if self._is_cte_reference(entity_part, jsql):
                    real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                    entities.add(real_entity)
                else:
                    entities.add(entity_part)
        elif 'func' in item:
            # Extract entities from function arguments
            if args := item.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entity_from_expression(arg, jsql))
        elif 'expr' in item:
            entities.update(self._extract_entity_from_expression(item['expr'], jsql))
        elif 'subquery' in item:
            subquery = item['subquery']
            if isinstance(subquery, dict):
                entities.update(self.get_select_entities(subquery))
    
    return entities

def _extract_entity_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression (functions, operators, etc.)."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        if '.' in expr:
            entity_part = expr.split('.', 1)[0]
            if self._is_cte_reference(entity_part, jsql):
                real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                entities.add(real_entity)
            else:
                entities.add(entity_part)
    
    elif isinstance(expr, dict):
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entity_part = field.split('.', 1)[0]
                if self._is_cte_reference(entity_part, jsql):
                    real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                    entities.add(real_entity)
                else:
                    entities.add(entity_part)
        
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entity_from_expression(arg, jsql))
        
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entity_from_expression(expr['left'], jsql))
            entities.update(self._extract_entity_from_expression(expr['right'], jsql))
        
        elif 'expr' in expr:
            entities.update(self._extract_entity_from_expression(expr['expr'], jsql))
        
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self.get_select_entities(subquery))
    
    return entities

def _is_cte_reference(self, name: str, jsql: dict) -> bool:
    """Check if name references a CTE defined in WITH clause."""
    with_clauses = jsql.get('with')
    if not with_clauses:
        return False
    
    if isinstance(with_clauses, list):
        return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
    elif isinstance(with_clauses, dict):
        return name in with_clauses
    
    return False

def _resolve_cte_base_entity(self, cte_name: str, jsql: dict) -> str:
    """Resolve base entity from CTE definition."""
    with_clauses = jsql.get('with')
    
    if isinstance(with_clauses, list):
        for cte in with_clauses:
            if isinstance(cte, dict) and cte.get('name') == cte_name:
                cte_query = cte.get('query')
                if isinstance(cte_query, dict):
                    from_entity = cte_query.get('from')
                    if isinstance(from_entity, str):
                        # Recursively check if FROM references another CTE
                        if self._is_cte_reference(from_entity, jsql):
                            return self._resolve_cte_base_entity(from_entity, jsql)
                        return from_entity
    elif isinstance(with_clauses, dict):
        cte_def = with_clauses.get(cte_name)
        if isinstance(cte_def, dict):
            from_entity = cte_def.get('from')
            if isinstance(from_entity, str):
                if self._is_cte_reference(from_entity, jsql):
                    return self._resolve_cte_base_entity(from_entity, jsql)
                return from_entity
    
    return cte_name  # Fallback
```

### –®–∞–≥ 3: `JSQLExecutor.execute()` - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å parser –¥–ª—è —Å—É—â–Ω–æ—Å—Ç–µ–π

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    entity_name = from_entity if isinstance(from_entity, str) else ''
    
    # Parse entity name to extract namespace
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context, actual_namespace)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - create context and parser
    from namerec.uma.core.context import UMAContext
    context = UMAContext(
        engine=config.engine,
        metadata_provider=config.metadata_provider,
        namespace=actual_namespace,
        user_context=user_context,
    )
    
    parser = JSQLParser(context, namespace_configs=namespace_configs)
    sql_query = await parser.parse(jsql)
    
    # Extract entities from SELECT clause using parser
    select_entities = parser.get_select_entities(jsql)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

### –®–∞–≥ 4: `UMA.select()` - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–æ–π

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query.
    
    All logic is handled by stateless JSQLParser and JSQLExecutor.
    """
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

### –®–∞–≥ 5: `UMA` - —É–¥–∞–ª–∏—Ç—å –º–µ—Ç–æ–¥—ã

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å |
|-----------|---------------|
| `JSQLParser` | –ü–∞—Ä—Å–∏–Ω–≥ JSQL + –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–∑ SELECT |
| `JSQLExecutor` | –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞, –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ, –¥–æ—Å—Ç—É–ø –∫ namespace_configs |
| `UMA.select()` | –¢–æ–ª—å–∫–æ –¥–µ–ª–µ–≥–∞—Ü–∏—è –≤ JSQLExecutor |
| `check_access()` | –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ (helper) |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞**:
- ‚úÖ –ù–∏–∫–∞–∫–æ–≥–æ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ª–æ–≥–∏–∫–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π
- ‚úÖ JSQLParser —É–∂–µ –∑–Ω–∞–µ—Ç –≤—Å—ë –æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –∑–∞–ø—Ä–æ—Å–∞
- ‚úÖ `namespace_configs` –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ (JSQLExecutor)
- ‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –Ω—É–∂–µ–Ω (cache miss)
- ‚úÖ –ß–∏—Å—Ç–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
class JSQLParser:
    """
    JSQL parser with namespace support.
    
    Parses JSQL and provides access to:
    - Parsed SQLAlchemy AST
    - Entities used in SELECT clause (for access control)
    """
    
    def __init__(
        self,
        context: UMAContext,
        namespace_configs: Mapping[str, NamespaceConfig] | None = None,
    ) -> None:
        self.context = context
        self.namespace_configs = namespace_configs  # For entity extraction
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        
        # Operator handler dispatch table
        self._operator_handlers: dict[str, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            # ... existing handlers ...
        }
```

```python
def get_select_entities(self, jsql: dict) -> list[str]:
    """
    Extract entities from SELECT clause for access control.
    
    This method is called AFTER parsing the query, so we can:
    - Use parsed information (ctes, table aliases)
    - Resolve CTE references to base entities
    
    Args:
        jsql: JSQL query dictionary
    
    Returns:
        List of entity names (qualified with namespace if present)
    
    Note:
        Only returns entities whose columns appear in SELECT clause,
        not entities in WHERE, JOINs, or other clauses.
    """
    entities: set[str] = set()
    
    select_clause = jsql.get('select')
    if not select_clause:
        return list(entities)
    
    select_items = select_clause if isinstance(select_clause, list) else [select_clause]
    
    for item in select_items:
        entities.update(self._extract_entity_from_select_item(item, jsql))
    
    return list(entities)

def _extract_entity_from_select_item(self, item: Any, jsql: dict) -> set[str]:
    """Extract entity name from single SELECT item."""
    entities: set[str] = set()
    
    if isinstance(item, str):
        # '*' or unqualified column - use FROM entity
        if item == '*' or '.' not in item:
            from_entity = jsql.get('from')
            if isinstance(from_entity, str):
                # Check if FROM is a CTE
                if self._is_cte_reference(from_entity, jsql):
                    real_entity = self._resolve_cte_base_entity(from_entity, jsql)
                    entities.add(real_entity)
                else:
                    entities.add(from_entity)
        elif '.' in item:
            # Qualified column - extract entity
            entity_part = item.split('.', 1)[0]
            # Check if it's a CTE reference
            if self._is_cte_reference(entity_part, jsql):
                real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                entities.add(real_entity)
            else:
                entities.add(entity_part)
    
    elif isinstance(item, dict):
        # Complex SELECT item (field, func, expr, subquery, etc.)
        if 'field' in item:
            field = item['field']
            if isinstance(field, str) and '.' in field:
                entity_part = field.split('.', 1)[0]
                if self._is_cte_reference(entity_part, jsql):
                    real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                    entities.add(real_entity)
                else:
                    entities.add(entity_part)
        elif 'func' in item:
            # Extract entities from function arguments
            if args := item.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entity_from_expression(arg, jsql))
        elif 'expr' in item:
            entities.update(self._extract_entity_from_expression(item['expr'], jsql))
        elif 'subquery' in item:
            subquery = item['subquery']
            if isinstance(subquery, dict):
                entities.update(self.get_select_entities(subquery))
    
    return entities

def _extract_entity_from_expression(self, expr: Any, jsql: dict) -> set[str]:
    """Extract entity names from expression (functions, operators, etc.)."""
    entities: set[str] = set()
    
    if isinstance(expr, str):
        if '.' in expr:
            entity_part = expr.split('.', 1)[0]
            if self._is_cte_reference(entity_part, jsql):
                real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                entities.add(real_entity)
            else:
                entities.add(entity_part)
    
    elif isinstance(expr, dict):
        if 'field' in expr:
            field = expr['field']
            if isinstance(field, str) and '.' in field:
                entity_part = field.split('.', 1)[0]
                if self._is_cte_reference(entity_part, jsql):
                    real_entity = self._resolve_cte_base_entity(entity_part, jsql)
                    entities.add(real_entity)
                else:
                    entities.add(entity_part)
        
        elif 'func' in expr:
            if args := expr.get('args'):
                for arg in args if isinstance(args, list) else [args]:
                    entities.update(self._extract_entity_from_expression(arg, jsql))
        
        elif 'left' in expr and 'right' in expr:
            entities.update(self._extract_entity_from_expression(expr['left'], jsql))
            entities.update(self._extract_entity_from_expression(expr['right'], jsql))
        
        elif 'expr' in expr:
            entities.update(self._extract_entity_from_expression(expr['expr'], jsql))
        
        elif 'subquery' in expr:
            subquery = expr['subquery']
            if isinstance(subquery, dict):
                entities.update(self.get_select_entities(subquery))
    
    return entities

def _is_cte_reference(self, name: str, jsql: dict) -> bool:
    """Check if name references a CTE defined in WITH clause."""
    with_clauses = jsql.get('with')
    if not with_clauses:
        return False
    
    if isinstance(with_clauses, list):
        return any(cte.get('name') == name for cte in with_clauses if isinstance(cte, dict))
    elif isinstance(with_clauses, dict):
        return name in with_clauses
    
    return False

def _resolve_cte_base_entity(self, cte_name: str, jsql: dict) -> str:
    """Resolve base entity from CTE definition."""
    with_clauses = jsql.get('with')
    
    if isinstance(with_clauses, list):
        for cte in with_clauses:
            if isinstance(cte, dict) and cte.get('name') == cte_name:
                cte_query = cte.get('query')
                if isinstance(cte_query, dict):
                    from_entity = cte_query.get('from')
                    if isinstance(from_entity, str):
                        # Recursively check if FROM references another CTE
                        if self._is_cte_reference(from_entity, jsql):
                            return self._resolve_cte_base_entity(from_entity, jsql)
                        return from_entity
    elif isinstance(with_clauses, dict):
        cte_def = with_clauses.get(cte_name)
        if isinstance(cte_def, dict):
            from_entity = cte_def.get('from')
            if isinstance(from_entity, str):
                if self._is_cte_reference(from_entity, jsql):
                    return self._resolve_cte_base_entity(from_entity, jsql)
                return from_entity
    
    return cte_name  # Fallback
```

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    entity_name = from_entity if isinstance(from_entity, str) else ''
    
    # Parse entity name to extract namespace
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context, actual_namespace)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - create context and parser
    from namerec.uma.core.context import UMAContext
    context = UMAContext(
        engine=config.engine,
        metadata_provider=config.metadata_provider,
        namespace=actual_namespace,
        user_context=user_context,
    )
    
    parser = JSQLParser(context, namespace_configs=namespace_configs)
    sql_query = await parser.parse(jsql)
    
    # Extract entities from SELECT clause using parser
    select_entities = parser.get_select_entities(jsql)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query.
    
    All logic is handled by stateless JSQLParser and JSQLExecutor.
    """
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

---

**User**

(20260115-060609)
```
class JSQLParser:    
    def __init__(
        self,
        context: UMAContext, # Sht@20260115-060638. –£–¥–∞–ª–∏ —ç—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –æ–Ω –Ω–µ–Ω—É–∂–µ–Ω!!!
        namespace_configs: Mapping[str, NamespaceConfig] | None = None,
    ) -> None:
```

(20260115-060803)
```
def get_select_entities(self, jsql: dict) -> list[str]:
```
–ü–æ—á–µ–º—É –Ω–µ —Å–¥–µ–ª–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–æ–π –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è JSQLParser, —Ç.–µ. AST SQLAlchemy? –≠—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –º–æ–∂–Ω–æ —Ä–∞—Å–ø–æ–ª–æ–∂–∏—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ –æ—Ç JSQLParser.

(20260115-055121) –í —Ç–≤–æ–∏—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è—Ö —è –≤–∏–∂—É –Ω–∞—Ä—É—à–µ–Ω–∏–µ SRP –≤ `JSQLExecutor.execute()`: —Ç–∞–º –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è, –≤ —Å—É—â–Ω–æ—Å—Ç–∏ —Ç–æ, –∑–∞ —á—Ç–æ —É–∂–µ –æ—Ç–≤–µ—á–∞–µ—Ç JSQLParser ‚Äì —Ä–∞–∑–±–æ—Ä –∑–∞–ø—Ä–æ—Å–∞ –≤ —á–∞—Å—Ç–∏ –±–ª–æ–∫–∞ `SELECT`.
–ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –≤ JSQLParser, –∏ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–∏–º –ø–æ –ø—Ä–æ—Ç–æ–∫–æ–ª—É:
1) –†–∞–∑–æ–±—Ä–∞—Ç—å –∑–∞–ø—Ä–æ—Å –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ JSQLParser.
2) –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π, –ø–æ–ª—è –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —É—á–∞—Å—Ç–≤—É—é—Ç –≤ –±–ª–æ–∫–µ `SELECT` –∑–∞–ø—Ä–æ—Å–∞ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ JSQL.
3) –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–ª–Ω–æ–º–æ—á–∏—è –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏.

(20260115-055629) –ù–æ JSQLParser-—É —Ç—Ä–µ–±—É–µ—Ç—Å—è MatadataProvider –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `get_table`). –î–ª—è —ç—Ç–æ–π —Ü–µ–ª–∏ —Å–æ–∑–¥–∞—ë—Ç—Å—è –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤ `JSQLExecutor.execute()`.
–ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è:
1) –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å.
2) –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ JSQLParser mapping `namespace_configs`, –¥–æ—Ç–∫—É–¥–∞ JSQLParser —Å–º–æ–∂–µ—Ç –∏–∑–≤–ª–µ—á—å –Ω—É–∂–Ω—ã–π MatadataProvider –ø–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–º—É –Ω–∞ —ç—Ç–æ—Ç –º–æ–º–µ–Ω—Ç `namespace`, –∏ –≤—ã–∑–≤–∞—Ç—å `get_table()`.

(20260115-055924) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –ø–æ–Ω—è–ª –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω—É.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –û—Ç–¥–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è AST

### –®–∞–≥ 1: –°–æ–∑–¥–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–∑ AST

```python
# –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ src/namerec/uma/jsql/entity_extractor.py
from typing import Any, set
from sqlalchemy.sql.expression import ColumnClause, Select, TableClause


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.
    
    This is a pure function that works with parsed SQLAlchemy AST,
    independent of JSQLParser state.
    
    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)
    
    Returns:
        List of entity names (qualified with namespace if present)
    
    Note:
        Only extracts entities whose columns appear in SELECT clause.
    """
    entities: set[str] = set()
    
    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            # String like '*' or unqualified column
            if column == '*':
                entities.add(from_entity)
            elif '.' not in column:
                entities.add(from_entity)
            else:
                # Qualified column: table.column
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)
        
        elif isinstance(column, (ColumnClause, TableClause)):
            # Column expression - extract from table
            if hasattr(column, 'table'):
                entities.add(str(column.table))
            elif hasattr(column, 'name'):
                entities.add(str(column.name))
        
        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)
        
        elif hasattr(column, 'table'):
            # Column with table reference
            entities.add(str(column.table))
    
    return list(entities)
```

### –®–∞–≥ 2: `JSQLParser` - —É–±—Ä–∞—Ç—å context, –¥–æ–±–∞–≤–∏—Ç—å namespace_configs

```python
class JSQLParser:
    """
    JSQL parser with namespace support.
    
    Parses JSQL and returns SQLAlchemy AST.
    """
    
    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
    ) -> None:
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        
        # Operator handler dispatch table
        self._operator_handlers: dict[str, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            # ... existing handlers ...
        }
    
    def get_metadata_provider(self, namespace: str) -> Any:
        """Get metadata provider for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].metadata_provider
    
    def get_engine(self, namespace: str) -> Engine:
        """Get engine for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].engine
```

**–í–∞–∂–Ω–æ**: –í—Å–µ –º–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ `self.context.get_table()`, –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞:

```python
async def _get_table_async(self, entity_name: EntityName, namespace: str) -> Any:
    """Get table from metadata provider."""
    metadata_provider = self.get_metadata_provider(namespace)
    return await metadata_provider.get_table(entity_name, self.get_engine(namespace), None)
```

### –®–∞–≥ 3: `JSQLExecutor.execute()` - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å AST –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    from namerec.uma.core.utils import parse_entity_name
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    entity_name = from_entity if isinstance(from_entity, str) else ''
    
    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context, actual_namespace)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - create parser and parse
    parser = JSQLParser(namespace_configs)
    sql_query = await parser.parse(jsql, actual_namespace)
    
    # Extract entities from SELECT AST using pure function
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

**–ò–∑–º–µ–Ω–∏—Ç—å `JSQLParser.parse()`** - –¥–æ–±–∞–≤–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä namespace:

```python
async def parse(self, jsql: dict[str, Any], namespace: str) -> Select:
    """
    Parse JSQL query and return SQLAlchemy SELECT statement.
    
    Args:
        jsql: JSQL query dictionary
        namespace: Namespace name for metadata resolution
    
    Returns:
        SQLAlchemy SELECT statement
    """
    # ... existing parsing code ...
    
    # Use namespace for metadata provider lookups
    # instead of self.context.get_table(), use self.get_metadata_provider(namespace)
```

### –®–∞–≥ 4: `UMA.select()` - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–æ–π

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query.
    
    All logic is handled by stateless JSQLExecutor and pure AST extractor.
    """
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

### –®–∞–≥ 5: –£–¥–∞–ª–∏—Ç—å –∏–∑ UMA

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å |
|-----------|---------------|
| `extract_select_entities_from_ast()` | –ß–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å—É—â–Ω–æ—Å—Ç–∏ –∏–∑ SQLAlchemy AST |
| `JSQLParser` | –ü–∞—Ä—Å–∏—Ç JSQL ‚Üí AST, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç namespace_configs –¥–ª—è metadata |
| `JSQLExecutor` | Stateless –∫–ª–∞—Å—Å, –≤—ã–∑—ã–≤–∞–µ—Ç parser, AST extractor, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø, –∫—ç—à–∏—Ä—É–µ—Ç |
| `UMA.select()` | –¢–æ–ª—å–∫–æ –¥–µ–ª–µ–≥–∞—Ü–∏—è –≤ JSQLExecutor |
| `check_access()` | Helper –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- ‚úÖ –ù–∏–∫–∞–∫–∏—Ö –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–π –ª–æ–≥–∏–∫–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π
- ‚úÖ `extract_select_entities_from_ast()` - —á–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è (no state, reusable)
- ‚úÖ JSQLParser –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç namespace_configs
- ‚úÖ JSQLExecutor - –ø–æ–ª–Ω–æ—Å—Ç—å—é stateless
- ‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ–∑–¥–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –Ω—É–∂–µ–Ω (cache miss)

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
# –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤ src/namerec/uma/jsql/entity_extractor.py
from typing import Any, set
from sqlalchemy.sql.expression import ColumnClause, Select, TableClause


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.
    
    This is a pure function that works with parsed SQLAlchemy AST,
    independent of JSQLParser state.
    
    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)
    
    Returns:
        List of entity names (qualified with namespace if present)
    
    Note:
        Only extracts entities whose columns appear in SELECT clause.
    """
    entities: set[str] = set()
    
    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            # String like '*' or unqualified column
            if column == '*':
                entities.add(from_entity)
            elif '.' not in column:
                entities.add(from_entity)
            else:
                # Qualified column: table.column
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)
        
        elif isinstance(column, (ColumnClause, TableClause)):
            # Column expression - extract from table
            if hasattr(column, 'table'):
                entities.add(str(column.table))
            elif hasattr(column, 'name'):
                entities.add(str(column.name))
        
        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)
        
        elif hasattr(column, 'table'):
            # Column with table reference
            entities.add(str(column.table))
    
    return list(entities)
```

```python
class JSQLParser:
    """
    JSQL parser with namespace support.
    
    Parses JSQL and returns SQLAlchemy AST.
    """
    
    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
    ) -> None:
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        
        # Operator handler dispatch table
        self._operator_handlers: dict[str, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            # ... existing handlers ...
        }
    
    def get_metadata_provider(self, namespace: str) -> Any:
        """Get metadata provider for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].metadata_provider
    
    def get_engine(self, namespace: str) -> Engine:
        """Get engine for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].engine
```

```python
async def _get_table_async(self, entity_name: EntityName, namespace: str) -> Any:
    """Get table from metadata provider."""
    metadata_provider = self.get_metadata_provider(namespace)
    return await metadata_provider.get_table(entity_name, self.get_engine(namespace), None)
```

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    from namerec.uma.core.utils import parse_entity_name
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    entity_name = from_entity if isinstance(from_entity, str) else ''
    
    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context, actual_namespace)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - create parser and parse
    parser = JSQLParser(namespace_configs)
    sql_query = await parser.parse(jsql, actual_namespace)
    
    # Extract entities from SELECT AST using pure function
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

```python
async def parse(self, jsql: dict[str, Any], namespace: str) -> Select:
    """
    Parse JSQL query and return SQLAlchemy SELECT statement.
    
    Args:
        jsql: JSQL query dictionary
        namespace: Namespace name for metadata resolution
    
    Returns:
        SQLAlchemy SELECT statement
    """
    # ... existing parsing code ...
    
    # Use namespace for metadata provider lookups
    # instead of self.context.get_table(), use self.get_metadata_provider(namespace)
```

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query.
    
    All logic is handled by stateless JSQLExecutor and pure AST extractor.
    """
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

```python
# ‚ùå –£–¥–∞–ª–∏—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é:
# - _extract_entities_from_jsql()
# - _extract_entities_from_expression()
```

---

**User**

(20260115-065813)
> –í–∞–∂–Ω–æ: –í—Å–µ –º–µ—Ç–æ–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ self.context.get_table(), –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞:

–ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ?

> async def _get_table_async(self, entity_name: EntityName, namespace: str) -> Any:

–ó–∞—á–µ–º –≤ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å `entity_name: EntityName`, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π `namespace`, –∏ –µ—â—ë, –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ `namespace`?
–ü–æ—á–µ–º—É —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Any, –∞ –Ω–µ Table?

(20260115-065818) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ—è—Å–Ω–∏ –º–Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–¥–∞ –≤ `JSQLExecutor.execute()`:
```python
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    from namerec.uma.core.utils import parse_entity_name
    
    # Parse FROM to resolve namespace
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    entity_name = from_entity if isinstance(from_entity, str) else ''
    
    # Parse entity name to extract namespace
    entity = parse_entity_name(entity_name)
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]

```
–ü—Ä–∞–≤–∏–ª—å–Ω–æ –ª–∏ —è –ø–æ–Ω–∏–º–∞—é, —á—Ç–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ, –¥–ª—è —á–µ–≥–æ —ç—Ç–æ—Ç –∫–æ–¥ –Ω—É–∂–µ–Ω ‚Äì –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å `actual_namespace`, —á—Ç–æ–±—ã —Å –Ω–∏–º –≤—ã–∑–≤–∞—Ç—å `make_cache_key`?
–ï—Å–ª–∏ —Ç–∞–∫, —á—Ç–æ —á—Ç–æ –º—ã –ø–æ—Ç–µ—Ä—è–µ–º, –µ—Å–ª–∏ –Ω–µ –±—É–¥–µ–º –≤ —Ö—ç—à–µ —É—á–∏—Ç—ã–≤–∞—Ç—å namespace?

(20260115-070209)
> –ò–∑–º–µ–Ω–∏—Ç—å JSQLParser.parse() - –¥–æ–±–∞–≤–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä namespace:

–ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å namespace –∑–∞ –Ω–µ–Ω–∞–¥–æ–±–Ω–æ—Å—Ç—å—é.
–í –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–∞–∑–±–æ—Ä–∞ –∑–∞–ø—Ä–æ—Å–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∏–∑–≤–µ—Å—Ç–µ–Ω namespace –∏ –∏–º—è —Ç–∞–±–ª–∏—Ü—ã, –∫–æ—Ç–æ—Ä—É—é –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∑–∞–ø—Ä–æ—Å–µ. –¢.–∫. namespace –Ω–∞–º –∏–∑–≤–µ—Å—Ç–µ–Ω, –∞ `namespace_configs` –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä `SQLParser`, —è –Ω–µ –≤–∏–∂—É –ø—Ä–æ–±–ª–µ–º –≤—ã–∑–≤–∞—Ç—å `get_table` —É —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ MetadataProvider.

(20260115-073024) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ.
–ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**


## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –£–ø—Ä–æ—â–µ–Ω–∏–µ –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è

### –®–∞–≥ 1: `extract_select_entities_from_ast()` - —á–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è

```python
# src/namerec/uma/jsql/entity_extractor.py
from typing import Any
from sqlalchemy.sql.expression import Select, ColumnElement, TableClause
from sqlalchemy import Table


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.
    
    Pure function - no state, no side effects.
    
    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)
    
    Returns:
        List of entity names (qualified with namespace if present)
    """
    entities: set[str] = set()
    
    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            if column == '*' or '.' not in column:
                entities.add(from_entity)
            else:
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)
        
        elif isinstance(column, ColumnElement):
            # Column expression - extract from table
            if hasattr(column, 'table') and column.table is not None:
                table = column.table
                if isinstance(table, Table):
                    entities.add(table.name)
                else:
                    entities.add(str(table))
        
        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)
    
    return list(entities)
```

### –®–∞–≥ 2: `JSQLParser` - –±–µ–∑ context, —Å namespace_configs

```python
class JSQLParser:
    """JSQL parser with namespace support."""
    
    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
    ) -> None:
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        # ... operator handlers ...
    
    def get_metadata_provider(self, namespace: str) -> Any:
        """Get metadata provider for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].metadata_provider
    
    def get_engine(self, namespace: str) -> Engine:
        """Get engine for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].engine
    
    async def _get_table_async(self, entity_name: EntityName) -> Table:
        """
        Get table from metadata provider.
        
        Uses entity_name.namespace to determine which metadata provider to use.
        """
        namespace = entity_name.namespace
        if not namespace:
            # Resolve default namespace
            if len(self.namespace_configs) == 1:
                namespace = next(iter(self.namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )
        
        metadata_provider = self.get_metadata_provider(namespace)
        engine = self.get_engine(namespace)
        
        return await metadata_provider.get_table(entity_name, engine, None)
    
    async def parse(self, jsql: dict[str, Any]) -> Select:
        """
        Parse JSQL query and return SQLAlchemy SELECT statement.
        
        Namespace is resolved during parsing from entity names in FROM/JOIN clauses.
        """
        # ... existing parsing code ...
        # When entity_name is parsed, use entity_name.namespace to get metadata provider
```

### –®–∞–≥ 3: `JSQLExecutor.execute()` - —É–ø—Ä–æ—Å—Ç–∏—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ namespace

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query first to determine namespace
    parser = JSQLParser(namespace_configs)
    sql_query = await parser.parse(jsql)
    
    # Extract namespace from FROM clause (needed for cache key and access control)
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    # IMPORTANT: namespace MUST be in cache key to avoid collisions!
    # Same query in different namespaces = different results (different tables)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context, actual_namespace)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

### –®–∞–≥ 4: `UMA.select()` - –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query."""
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

---

## üéØ –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã

### 1. –ó–∞—á–µ–º –º–µ–Ω—è—Ç—å `self.context.get_table()`?
–ï—Å–ª–∏ —É–±—Ä–∞–ª–∏ `context` –∏–∑ `JSQLParser`, –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∞—Ç—å metadata provider –∏–∑ `namespace_configs` –ø–æ namespace. –≠—Ç–æ –∏ –µ—Å—Ç—å –ø—Ä–∏—á–∏–Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è.

### 2. –ó–∞—á–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å namespace?
–ù–µ –Ω—É–∂–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–µ–º `entity_name.namespace` –≤ `_get_table_async()`.

### 3. –ü–æ—á–µ–º—É `Any`, –∞ –Ω–µ `Table`?
–î–æ–ª–∂–Ω–æ –±—ã—Ç—å `Table`. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ.

### 4. –ó–∞—á–µ–º –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å namespace –¥–ª—è cache key?
Namespace –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –≤ cache key, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–ª–ª–∏–∑–∏–π:
- –ó–∞–ø—Ä–æ—Å `SELECT * FROM users` –≤ namespace `db1` ‚Üí —Ç–∞–±–ª–∏—Ü–∞ `db1.users`
- –ó–∞–ø—Ä–æ—Å `SELECT * FROM users` –≤ namespace `db2` ‚Üí —Ç–∞–±–ª–∏—Ü–∞ `db2.users`
–ë–µ–∑ namespace –≤ –∫–ª—é—á–µ –∫—ç—à –≤–µ—Ä–Ω–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

### 5. –ó–∞—á–µ–º –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å namespace –≤ `parse()`?
–ù–µ –Ω—É–∂–Ω–æ. Namespace –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∏–∑ `entity_name.namespace` –≤–æ –≤—Ä–µ–º—è –ø–∞—Ä—Å–∏–Ω–≥–∞, `namespace_configs` —É–∂–µ –µ—Å—Ç—å –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ.

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å |
|-----------|---------------|
| `extract_select_entities_from_ast()` | –ß–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å—É—â–Ω–æ—Å—Ç–∏ –∏–∑ AST |
| `JSQLParser` | –ü–∞—Ä—Å–∏—Ç JSQL ‚Üí AST, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `namespace_configs` –¥–ª—è metadata |
| `JSQLExecutor` | Stateless, –≤—ã–∑—ã–≤–∞–µ—Ç parser, AST extractor, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø, –∫—ç—à–∏—Ä—É–µ—Ç |
| `UMA.select()` | –¢–æ–ª—å–∫–æ –¥–µ–ª–µ–≥–∞—Ü–∏—è |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- ‚úÖ –ù–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è namespace
- ‚úÖ `_get_table_async()` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `entity_name.namespace`
- ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `Table`, –∞ –Ω–µ `Any`
- ‚úÖ Namespace –≤ cache key (–∏–∑–±–µ–≥–∞–µ–º –∫–æ–ª–ª–∏–∑–∏–π)
- ‚úÖ `parse()` –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ namespace

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
# src/namerec/uma/jsql/entity_extractor.py
from typing import Any
from sqlalchemy.sql.expression import Select, ColumnElement, TableClause
from sqlalchemy import Table


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.
    
    Pure function - no state, no side effects.
    
    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)
    
    Returns:
        List of entity names (qualified with namespace if present)
    """
    entities: set[str] = set()
    
    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            if column == '*' or '.' not in column:
                entities.add(from_entity)
            else:
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)
        
        elif isinstance(column, ColumnElement):
            # Column expression - extract from table
            if hasattr(column, 'table') and column.table is not None:
                table = column.table
                if isinstance(table, Table):
                    entities.add(table.name)
                else:
                    entities.add(str(table))
        
        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)
    
    return list(entities)
```

```python
class JSQLParser:
    """JSQL parser with namespace support."""
    
    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
    ) -> None:
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        # ... operator handlers ...
    
    def get_metadata_provider(self, namespace: str) -> Any:
        """Get metadata provider for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].metadata_provider
    
    def get_engine(self, namespace: str) -> Engine:
        """Get engine for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].engine
    
    async def _get_table_async(self, entity_name: EntityName) -> Table:
        """
        Get table from metadata provider.
        
        Uses entity_name.namespace to determine which metadata provider to use.
        """
        namespace = entity_name.namespace
        if not namespace:
            # Resolve default namespace
            if len(self.namespace_configs) == 1:
                namespace = next(iter(self.namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )
        
        metadata_provider = self.get_metadata_provider(namespace)
        engine = self.get_engine(namespace)
        
        return await metadata_provider.get_table(entity_name, engine, None)
    
    async def parse(self, jsql: dict[str, Any]) -> Select:
        """
        Parse JSQL query and return SQLAlchemy SELECT statement.
        
        Namespace is resolved during parsing from entity names in FROM/JOIN clauses.
        """
        # ... existing parsing code ...
        # When entity_name is parsed, use entity_name.namespace to get metadata provider
```

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query first to determine namespace
    parser = JSQLParser(namespace_configs)
    sql_query = await parser.parse(jsql)
    
    # Extract namespace from FROM clause (needed for cache key and access control)
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    # IMPORTANT: namespace MUST be in cache key to avoid collisions!
    # Same query in different namespaces = different results (different tables)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context, actual_namespace)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query."""
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

---

**User**

(20260115-073538)
```
    def get_metadata_provider(self, namespace: str) -> Any:
        """Get metadata provider for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].metadata_provider
    
    def get_engine(self, namespace: str) -> Engine:
        """Get engine for namespace from configs."""
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace].engine
```
1) –ó–¥–µ—Å—å –ø—Ä–æ–¥—É–±–ª–∏—Ä–æ–≤–∞–Ω –∫–æ–¥ (DRY).
2) –î–∞–≤–∞–π –≤–º–µ—Å—Ç–æ —ç—Ç–∏—Ö –¥–≤—É—Ö —Ñ—É–Ω–∫—Ü–∏–π –Ω–∞–ø–∏—à–µ–º –æ–±—ë—Ä—Ç–∫—É `get_namespace_config(namespace: str) -> NamespaceConfig`, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–±—Ä–æ—Å–∏—Ç –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –µ—Å–ª–∏ namespace –ø–æ –∏–º–µ–Ω–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.

(20260115-074011)
> 4. –ó–∞—á–µ–º –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å namespace –¥–ª—è cache key?
> Namespace –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –≤ cache key, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–ª–ª–∏–∑–∏–π:
> –ó–∞–ø—Ä–æ—Å SELECT * FROM users –≤ namespace db1 ‚Üí —Ç–∞–±–ª–∏—Ü–∞ db1.users
> –ó–∞–ø—Ä–æ—Å SELECT * FROM users –≤ namespace db2 ‚Üí —Ç–∞–±–ª–∏—Ü–∞ db2.users
> –ë–µ–∑ namespace –≤ –∫–ª—é—á–µ –∫—ç—à –≤–µ—Ä–Ω–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

–†–∞—Å—Å—É–∂–¥–µ–Ω–∏–µ.
(1) namespace —É–ø–æ–º–∏–Ω–∞–µ—Ç—Å—è –≤ —Ç–µ–∫—Å—Ç–µ –∑–∞–ø—Ä–æ—Å–∞, –≤ —á–∞—Å—Ç–Ω–æ—Å—Ç–∏, –æ–Ω –º–æ–∂–µ—Ç –±—ã—Ç—å —É–ø–æ–º—è–Ω—É—Ç –≤ –±–ª–æ–∫–µ `FROM` ‚Äì —ç—Ç–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–≤–µ–¥–µ–Ω–∏–π –æ namespace.
(2) –•—ç—à —Ä–∞—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –ø–æ JSQL-–∑–∞–ø—Ä–æ—Å—É, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, –≤—Å–ª–µ–¥—Å—Ç–≤–∏–µ (1), namespace, –ø—É—Å—Ç—å –∏ –Ω–µ—è–≤–Ω–æ, –Ω–æ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è.
(3) –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, –µ—Å–ª–∏ –¥–≤–∞ JSQL-–∑–∞–ø—Ä–æ—Å–∞ –∏–¥–µ–Ω—Ç–∏—á–Ω—ã –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –Ω–æ –æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ —Ä–∞–∑–Ω—ã–º namespace, —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –∏—Ö —Å—Ç—Ä–æ–∫–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–≤–Ω—ã, –∏ —Ö—ç—à –±—É–¥–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è.
(4) –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, –≤—ã–ø–æ–ª–Ω—è—Ç—å —á–∞—Å—Ç–∏—á–Ω—ã–π —Ä–∞–∑–±–æ—Ä JSQL –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å namespace –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤ —Ö—ç—à–µ –∏–∑–±—ã—Ç–æ—á–Ω–æ, –Ω–µ –≥–æ–≤–æ—Ä—è —É–∂–µ –æ–± —É—Å–ª–æ–∂–Ω–µ–Ω–∏–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏.
‚Äì
–Ø —á—Ç–æ-—Ç–æ —É–ø—É—Å–∫–∞—é? 

(20260115-075547) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏ —Å–≤–æ–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ —Å–≤–µ—Ç–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ –≤—ã—à–µ. –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥ –Ω–µ –≤–Ω–æ—Å–∏.

---

**Cursor**


–í—ã –ø—Ä–∞–≤—ã. –û–±–Ω–æ–≤–ª—è—é –ø–ª–∞–Ω —Å —É—á–µ—Ç–æ–º —ç—Ç–∏—Ö –∑–∞–º–µ—á–∞–Ω–∏–π.

## üìã –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –£–ø—Ä–æ—â–µ–Ω–∏–µ

### –®–∞–≥ 1: `JSQLParser` - –æ–¥–∏–Ω –º–µ—Ç–æ–¥ –≤–º–µ—Å—Ç–æ –¥–≤—É—Ö

```python
class JSQLParser:
    """JSQL parser with namespace support."""
    
    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
    ) -> None:
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        # ... operator handlers ...
    
    def get_namespace_config(self, namespace: str) -> NamespaceConfig:
        """
        Get namespace config by name.
        
        Args:
            namespace: Namespace name
        
        Returns:
            NamespaceConfig for the namespace
        
        Raises:
            ValueError: If namespace not found
        """
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace]
    
    async def _get_table_async(self, entity_name: EntityName) -> Table:
        """
        Get table from metadata provider.
        
        Uses entity_name.namespace to determine which metadata provider to use.
        """
        namespace = entity_name.namespace
        if not namespace:
            # Resolve default namespace
            if len(self.namespace_configs) == 1:
                namespace = next(iter(self.namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )
        
        config = self.get_namespace_config(namespace)
        
        return await config.metadata_provider.get_table(
            entity_name,
            config.engine,
            None,
        )
    
    async def parse(self, jsql: dict[str, Any]) -> Select:
        """
        Parse JSQL query and return SQLAlchemy SELECT statement.
        
        Namespace is resolved during parsing from entity names in FROM/JOIN clauses.
        """
        # ... existing parsing code ...
        # When entity_name is parsed, use entity_name.namespace to get config
```

### –®–∞–≥ 2: `JSQLExecutor.execute()` - —É–±—Ä–∞—Ç—å –ø–∞—Ä—Å–∏–Ω–≥ –¥–ª—è cache key

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query first
    parser = JSQLParser(namespace_configs)
    sql_query = await parser.parse(jsql)
    
    # Extract namespace from FROM clause (needed for access control and config lookup)
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    # NOTE: namespace is already in jsql dict (in FROM clause),
    # so cache key will be different for different namespaces automatically!
    cache_key = None
    if cache_backend:
        # Don't pass namespace separately - it's already in jsql!
        cache_key = make_cache_key(jsql, user_context, None)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

### –®–∞–≥ 3: `make_cache_key()` - —É–±—Ä–∞—Ç—å namespace –ø–∞—Ä–∞–º–µ—Ç—Ä

```python
# src/namerec/uma/jsql/cache/keys.py
def make_cache_key(
    jsql: dict[str, Any],
    user_context: Any = None,
) -> str:
    """
    Create cache key for JSQL query.
    
    Includes user context hash to handle different permissions per user.
    Namespace is already in jsql dict (in FROM clause), so no need to pass separately.
    
    Args:
        jsql: JSQL query dictionary (contains namespace in FROM clause)
        user_context: User context (affects permissions/query results)
    
    Returns:
        Cache key (compact hash)
    """
    # Stable JSON representation (includes namespace from FROM clause)
    jsql_str = json.dumps(jsql, sort_keys=True, ensure_ascii=False)
    
    # Include user context in key (for permission-based queries)
    if user_context:
        context_str = json.dumps(
            _extract_cache_key_context(user_context),
            sort_keys=True,
            ensure_ascii=False,
        )
    else:
        context_str = ""
    
    # Combine all components
    cache_input = f"{jsql_str}|{context_str}"
    
    # Use BLAKE2b for fast, secure hashing (16 bytes = 32 hex chars)
    return hashlib.blake2b(cache_input.encode(), digest_size=16).hexdigest()
```

### –®–∞–≥ 4: `UMA.select()` - –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query."""
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

---

## üéØ –ò—Ç–æ–≥–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

| –ö–æ–º–ø–æ–Ω–µ–Ω—Ç | –û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å |
|-----------|---------------|
| `JSQLParser.get_namespace_config()` | –û–¥–∏–Ω –º–µ—Ç–æ–¥ –≤–º–µ—Å—Ç–æ –¥–≤—É—Ö (DRY) |
| `make_cache_key()` | –ù–µ —Ç—Ä–µ–±—É–µ—Ç namespace (–æ–Ω —É–∂–µ –≤ jsql) |
| `JSQLExecutor.execute()` | –£–ø—Ä–æ—â–µ–Ω - –Ω–µ –ø–∞—Ä—Å–∏—Ç –¥–ª—è cache key |
| `extract_select_entities_from_ast()` | –ß–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è AST |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- ‚úÖ –ù–µ—Ç DRY –Ω–∞—Ä—É—à–µ–Ω–∏—è (–æ–¥–∏–Ω –º–µ—Ç–æ–¥ `get_namespace_config()`)
- ‚úÖ –ù–µ—Ç –∏–∑–±—ã—Ç–æ—á–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è cache key
- ‚úÖ Namespace —É–∂–µ –≤ jsql ‚Üí —Ö—ç—à –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑–Ω—ã–π
- ‚úÖ –ü—Ä–æ—â–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
class JSQLParser:
    """JSQL parser with namespace support."""
    
    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
    ) -> None:
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()
        self.select_aliases: dict[str, ColumnElement] = {}
        # ... operator handlers ...
    
    def get_namespace_config(self, namespace: str) -> NamespaceConfig:
        """
        Get namespace config by name.
        
        Args:
            namespace: Namespace name
        
        Returns:
            NamespaceConfig for the namespace
        
        Raises:
            ValueError: If namespace not found
        """
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')
        
        return self.namespace_configs[namespace]
    
    async def _get_table_async(self, entity_name: EntityName) -> Table:
        """
        Get table from metadata provider.
        
        Uses entity_name.namespace to determine which metadata provider to use.
        """
        namespace = entity_name.namespace
        if not namespace:
            # Resolve default namespace
            if len(self.namespace_configs) == 1:
                namespace = next(iter(self.namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )
        
        config = self.get_namespace_config(namespace)
        
        return await config.metadata_provider.get_table(
            entity_name,
            config.engine,
            None,
        )
    
    async def parse(self, jsql: dict[str, Any]) -> Select:
        """
        Parse JSQL query and return SQLAlchemy SELECT statement.
        
        Namespace is resolved during parsing from entity names in FROM/JOIN clauses.
        """
        # ... existing parsing code ...
        # When entity_name is parsed, use entity_name.namespace to get config
```

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query first
    parser = JSQLParser(namespace_configs)
    sql_query = await parser.parse(jsql)
    
    # Extract namespace from FROM clause (needed for access control and config lookup)
    from_entity = jsql.get('from')
    if not from_entity:
        raise ValueError("JSQL must contain 'from' field")
    
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')
    
    # Determine actual namespace
    actual_namespace = entity.namespace
    if not actual_namespace:
        if len(namespace_configs) == 1:
            actual_namespace = next(iter(namespace_configs.keys()))
        else:
            raise ValueError(
                'Namespace not specified and no default available. '
                'Use explicit namespace or configure single namespace.'
            )
    
    # Get namespace config
    config = namespace_configs[actual_namespace]
    
    # Try cache (only if cache_backend provided)
    # NOTE: namespace is already in jsql dict (in FROM clause),
    # so cache key will be different for different namespaces automatically!
    cache_key = None
    if cache_backend:
        # Don't pass namespace separately - it's already in jsql!
        cache_key = make_cache_key(jsql, user_context, None)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},  # Extract from parser if needed
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result

@staticmethod
async def _execute_query(sql_query, params: dict | None, engine: Engine) -> QueryResult:
    """Execute SQL query and return result."""
    conn = await engine.connect()
    try:
        result = await conn.execute(sql_query, params or {})
        return QueryResult.from_db_result(result)
    finally:
        await conn.close()
```

```python
# src/namerec/uma/jsql/cache/keys.py
def make_cache_key(
    jsql: dict[str, Any],
    user_context: Any = None,
) -> str:
    """
    Create cache key for JSQL query.
    
    Includes user context hash to handle different permissions per user.
    Namespace is already in jsql dict (in FROM clause), so no need to pass separately.
    
    Args:
        jsql: JSQL query dictionary (contains namespace in FROM clause)
        user_context: User context (affects permissions/query results)
    
    Returns:
        Cache key (compact hash)
    """
    # Stable JSON representation (includes namespace from FROM clause)
    jsql_str = json.dumps(jsql, sort_keys=True, ensure_ascii=False)
    
    # Include user context in key (for permission-based queries)
    if user_context:
        context_str = json.dumps(
            _extract_cache_key_context(user_context),
            sort_keys=True,
            ensure_ascii=False,
        )
    else:
        context_str = ""
    
    # Combine all components
    cache_input = f"{jsql_str}|{context_str}"
    
    # Use BLAKE2b for fast, secure hashing (16 bytes = 32 hex chars)
    return hashlib.blake2b(cache_input.encode(), digest_size=16).hexdigest()
```

```python
async def select(
    self,
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query."""
    from namerec.uma.jsql.executor import JSQLExecutor
    
    result = await JSQLExecutor.execute(
        jsql=jsql,
        params=params,
        namespace_configs=self.namespace_configs,
        user_context=user_context,
        cache_backend=self.cache_backend if self.cache_enabled else None,
    )
    
    return result.to_dict()
```

---

**User**

> –®–∞–≥ 2: JSQLExecutor.execute() - —É–±—Ä–∞—Ç—å –ø–∞—Ä—Å–∏–Ω–≥ –¥–ª—è cache key

@code block (10-40) –Ø –Ω–µ –≤–∏–∂—É, —á—Ç–æ–±—ã –ø–∞—Ä—Å–∏–Ω–≥ –±—ã–ª —É–±—Ä–∞–Ω. –ò –ø—Ä–æ–¥–æ–ª–∂–∞—é –Ω–µ–ø–æ–Ω–∏–º–∞—Ç—å –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –∫–æ–¥–∞.

–ü–æ—è—Å–Ω–∏ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞. –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥ –Ω–µ –≤–Ω–æ—Å–∏.


---

**Cursor**


–í—ã –ø—Ä–∞–≤—ã: –ø–∞—Ä—Å–∏–Ω–≥ –Ω–µ —É–±—Ä–∞–Ω, –∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–¥–∞ –Ω–µ–æ—á–µ–≤–∏–¥–Ω–æ. –†–∞–∑–±–µ—Ä–µ–º:

## –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–¥–∞ (—Å—Ç—Ä–æ–∫–∏ 10-40)

–ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:
1. –°—Ç—Ä–æ–∫–∏ 16-18: –ø–∞—Ä—Å–∏–º –∑–∞–ø—Ä–æ—Å ‚Üí –ø–æ–ª—É—á–∞–µ–º AST
2. –°—Ç—Ä–æ–∫–∏ 20-26: –∏–∑–≤–ª–µ–∫–∞–µ–º namespace –∏–∑ FROM clause
3. –°—Ç—Ä–æ–∫–∏ 28-37: –æ–ø—Ä–µ–¥–µ–ª—è–µ–º actual_namespace (—Å fallback)
4. –°—Ç—Ä–æ–∫–∞ 40: –ø–æ–ª—É—á–∞–µ–º config

–ü—Ä–æ–±–ª–µ–º–∞: namespace –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –¥–≤–∞–∂–¥—ã:
- –í `parser.parse()` (–¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü)
- –í—Ä—É—á–Ω—É—é –∏–∑ FROM clause (–¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è config)

## –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ

Namespace —É–∂–µ –∏–∑–≤–µ—Å—Ç–µ–Ω –ø–æ—Å–ª–µ –ø–∞—Ä—Å–∏–Ω–≥–∞. –ù—É–∂–Ω–æ:
1. –ü–∞—Ä—Å–∏—Ç—å –∑–∞–ø—Ä–æ—Å (–ø–æ–ª—É—á–∞–µ–º AST –∏ namespace)
2. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç namespace –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è config
3. –ù–µ –ø–∞—Ä—Å–∏—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ –¥–ª—è cache key (namespace —É–∂–µ –≤ jsql)

## –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω

### –®–∞–≥ 1: `JSQLParser.parse()` - –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å namespace –≤–º–µ—Å—Ç–µ —Å AST

```python
# –í–∞—Ä–∏–∞–Ω—Ç A: –í–æ–∑–≤—Ä–∞—â–∞—Ç—å tuple
async def parse(self, jsql: dict[str, Any]) -> tuple[Select, str]:
    """
    Parse JSQL query and return SQLAlchemy SELECT statement + namespace.
    
    Returns:
        Tuple of (SELECT AST, namespace)
    """
    # ... existing parsing code ...
    # During parsing, namespace becomes known from entity names
    
    # Determine namespace from parsed entities
    namespace = self._determine_namespace_from_parsed_query(jsql)
    
    return sql_query, namespace

# –í–∞—Ä–∏–∞–Ω—Ç B: –•—Ä–∞–Ω–∏—Ç—å namespace –≤ parser state
async def parse(self, jsql: dict[str, Any]) -> Select:
    """Parse JSQL query and return SQLAlchemy SELECT statement."""
    # ... existing parsing code ...
    # Store namespace in self._parsed_namespace during parsing
    self._parsed_namespace = self._determine_namespace_from_parsed_query(jsql)
    return sql_query

@property
def parsed_namespace(self) -> str:
    """Get namespace from last parsed query."""
    return self._parsed_namespace
```

### –®–∞–≥ 2: `JSQLExecutor.execute()` - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å namespace –∏–∑ parser

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query - namespace is determined during parsing
    parser = JSQLParser(namespace_configs)
    sql_query, actual_namespace = await parser.parse(jsql)  # Returns tuple
    
    # Get namespace config (namespace already known from parsing)
    if actual_namespace not in namespace_configs:
        available = ', '.join(namespace_configs.keys())
        raise ValueError(f'Namespace "{actual_namespace}" not found. Available: {available}')
    
    config = namespace_configs[actual_namespace]
    
    # Try cache (namespace already in jsql, so cache key is unique)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    from_entity = jsql.get('from', '')
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result
```

### –®–∞–≥ 3: `JSQLParser._determine_namespace_from_parsed_query()` - –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥

```python
def _determine_namespace_from_parsed_query(self, jsql: dict) -> str:
    """
    Determine namespace from parsed query.
    
    Namespace comes from:
    - FROM clause entity name
    - Or default namespace if single namespace configured
    """
    from_entity = jsql.get('from')
    if not from_entity:
        # No FROM - use default
        if len(self.namespace_configs) == 1:
            return next(iter(self.namespace_configs.keys()))
        raise ValueError("JSQL must contain 'from' field")
    
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')
    
    # Use entity namespace or default
    if entity.namespace:
        return entity.namespace
    
    if len(self.namespace_configs) == 1:
        return next(iter(self.namespace_configs.keys()))
    
    raise ValueError(
        'Namespace not specified and no default available. '
        'Use explicit namespace or configure single namespace.'
    )
```

---

## –ò—Ç–æ–≥

–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–¥–∞ (—Å—Ç—Ä–æ–∫–∏ 20-40):
- –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å namespace –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è config
- –ù–æ namespace —É–∂–µ –∏–∑–≤–µ—Å—Ç–µ–Ω –ø–æ—Å–ª–µ –ø–∞—Ä—Å–∏–Ω–≥–∞

–†–µ—à–µ–Ω–∏–µ:
- –ü–∞—Ä—Å–∏–Ω–≥ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç namespace –≤–º–µ—Å—Ç–µ —Å AST
- –£–±—Ä–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è namespace
- Cache key –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ (namespace —É–∂–µ –≤ jsql)

–ö–∞–∫–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç–µ: tuple `(Select, str)` –∏–ª–∏ —Å–≤–æ–π—Å—Ç–≤–æ `parser.parsed_namespace`?

```python
# –í–∞—Ä–∏–∞–Ω—Ç A: –í–æ–∑–≤—Ä–∞—â–∞—Ç—å tuple
async def parse(self, jsql: dict[str, Any]) -> tuple[Select, str]:
    """
    Parse JSQL query and return SQLAlchemy SELECT statement + namespace.
    
    Returns:
        Tuple of (SELECT AST, namespace)
    """
    # ... existing parsing code ...
    # During parsing, namespace becomes known from entity names
    
    # Determine namespace from parsed entities
    namespace = self._determine_namespace_from_parsed_query(jsql)
    
    return sql_query, namespace

# –í–∞—Ä–∏–∞–Ω—Ç B: –•—Ä–∞–Ω–∏—Ç—å namespace –≤ parser state
async def parse(self, jsql: dict[str, Any]) -> Select:
    """Parse JSQL query and return SQLAlchemy SELECT statement."""
    # ... existing parsing code ...
    # Store namespace in self._parsed_namespace during parsing
    self._parsed_namespace = self._determine_namespace_from_parsed_query(jsql)
    return sql_query

@property
def parsed_namespace(self) -> str:
    """Get namespace from last parsed query."""
    return self._parsed_namespace
```

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query - namespace is determined during parsing
    parser = JSQLParser(namespace_configs)
    sql_query, actual_namespace = await parser.parse(jsql)  # Returns tuple
    
    # Get namespace config (namespace already known from parsing)
    if actual_namespace not in namespace_configs:
        available = ', '.join(namespace_configs.keys())
        raise ValueError(f'Namespace "{actual_namespace}" not found. Available: {available}')
    
    config = namespace_configs[actual_namespace]
    
    # Try cache (namespace already in jsql, so cache key is unique)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    from_entity = jsql.get('from', '')
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result
```

```python
def _determine_namespace_from_parsed_query(self, jsql: dict) -> str:
    """
    Determine namespace from parsed query.
    
    Namespace comes from:
    - FROM clause entity name
    - Or default namespace if single namespace configured
    """
    from_entity = jsql.get('from')
    if not from_entity:
        # No FROM - use default
        if len(self.namespace_configs) == 1:
            return next(iter(self.namespace_configs.keys()))
        raise ValueError("JSQL must contain 'from' field")
    
    from namerec.uma.core.utils import parse_entity_name
    entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')
    
    # Use entity namespace or default
    if entity.namespace:
        return entity.namespace
    
    if len(self.namespace_configs) == 1:
        return next(iter(self.namespace_configs.keys()))
    
    raise ValueError(
        'Namespace not specified and no default available. '
        'Use explicit namespace or configure single namespace.'
    )
```

---

**User**

> –®–∞–≥ 2: JSQLExecutor.execute() - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å namespace –∏–∑ parser

–¢—ã –æ—Å—Ç–∞–≤–∏–ª —ç—Ç–æ—Ç –∫–æ–¥:
```
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query - namespace is determined during parsing
    parser = JSQLParser(namespace_configs)
    sql_query, actual_namespace = await parser.parse(jsql)  # Returns tuple
    
    # Get namespace config (namespace already known from parsing)
    if actual_namespace not in namespace_configs:
        available = ', '.join(namespace_configs.keys())
        raise ValueError(f'Namespace "{actual_namespace}" not found. Available: {available}')
    
    config = namespace_configs[actual_namespace]
```
–ó–∞—á–µ–º –æ–Ω?

---

**Cursor**


–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–±—ã—Ç–æ—á–Ω–∞: `JSQLParser` —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `namespace_configs` –∏ –∑–Ω–∞–µ—Ç namespace. –ï—Å–ª–∏ namespace –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–∞—Ä—Å–µ—Ä –¥–æ–ª–∂–µ–Ω –≤—ã–±—Ä–æ—Å–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ.

## –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ

### `JSQLParser.parse()` - –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å config –Ω–∞–ø—Ä—è–º—É—é

```python
async def parse(self, jsql: dict[str, Any]) -> tuple[Select, NamespaceConfig]:
    """
    Parse JSQL query and return SQLAlchemy SELECT statement + namespace config.
    
    Returns:
        Tuple of (SELECT AST, NamespaceConfig)
    
    Raises:
        ValueError: If namespace not found or no default available
    """
    # ... existing parsing code ...
    # During parsing, namespace becomes known from entity names
    
    # Determine namespace from parsed entities
    namespace = self._determine_namespace_from_parsed_query(jsql)
    
    # Get config (already validated in get_namespace_config)
    config = self.get_namespace_config(namespace)
    
    return sql_query, config
```

### `JSQLExecutor.execute()` - —É–ø—Ä–æ—Å—Ç–∏—Ç—å

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query - returns AST and config (namespace already validated)
    parser = JSQLParser(namespace_configs)
    sql_query, config = await parser.parse(jsql)
    
    # Try cache (namespace already in jsql, so cache key is unique)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    from_entity = jsql.get('from', '')
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result
```

**–ò—Ç–æ–≥:**
- `JSQLParser.parse()` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `(Select, NamespaceConfig)`
- `JSQLExecutor.execute()` –ø–æ–ª—É—á–∞–µ—Ç config –∏–∑ parser, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
- –í—Å—è –≤–∞–ª–∏–¥–∞—Ü–∏—è namespace –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ `JSQLParser.get_namespace_config()`

**–ü–æ–¥—Ö–æ–¥–∏—Ç?**

```python
async def parse(self, jsql: dict[str, Any]) -> tuple[Select, NamespaceConfig]:
    """
    Parse JSQL query and return SQLAlchemy SELECT statement + namespace config.
    
    Returns:
        Tuple of (SELECT AST, NamespaceConfig)
    
    Raises:
        ValueError: If namespace not found or no default available
    """
    # ... existing parsing code ...
    # During parsing, namespace becomes known from entity names
    
    # Determine namespace from parsed entities
    namespace = self._determine_namespace_from_parsed_query(jsql)
    
    # Get config (already validated in get_namespace_config)
    config = self.get_namespace_config(namespace)
    
    return sql_query, config
```

```python
@classmethod
async def execute(
    cls,
    jsql: dict,
    namespace_configs: Mapping[str, NamespaceConfig],
    user_context: Any = None,
    cache_backend: CacheBackend | None = None,
    params: dict | None = None,
) -> QueryResult:
    """Execute JSQL with full access control."""
    from namerec.uma.jsql.parser import JSQLParser
    from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
    from namerec.uma.jsql.cache.keys import make_cache_key
    from namerec.uma.core.access import check_access
    
    # Parse query - returns AST and config (namespace already validated)
    parser = JSQLParser(namespace_configs)
    sql_query, config = await parser.parse(jsql)
    
    # Try cache (namespace already in jsql, so cache key is unique)
    cache_key = None
    if cache_backend:
        cache_key = make_cache_key(jsql, user_context)
        cached = cache_backend.get(cache_key)
        
        if cached:
            # Check access to SELECT entities (even for cached queries!)
            for select_entity in cached.entities:
                check_access(
                    metadata_provider=config.metadata_provider,
                    entity_name=select_entity,
                    operation=Operation.SELECT,
                    user_context=user_context,
                )
            return QueryResult.from_cached(cached, params)
    
    # Cache miss - extract entities from AST
    from_entity = jsql.get('from', '')
    select_entities = extract_select_entities_from_ast(sql_query, from_entity)
    
    # Check access to all SELECT entities
    for select_entity in select_entities:
        check_access(
            metadata_provider=config.metadata_provider,
            entity_name=select_entity,
            operation=Operation.SELECT,
            user_context=user_context,
        )
    
    # Execute
    result = await cls._execute_query(sql_query, params, config.engine)
    
    # Cache result
    if cache_backend and cache_key:
        from namerec.uma.jsql.cache.keys import CachedQuery
        cached_query = CachedQuery(
            sql=str(sql_query),
            params_mapping={},
            dialect=config.engine.dialect.name,
            entities=select_entities,
        )
        cache_backend.set(cache_key, cached_query)
    
    return result
```

---

**User**

@code block (11-14) ‚Äì –ø–æ—á–µ–º—É –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã?
–ü–æ—á–µ–º—É –∏–º–ø–æ—Ä—Ç—ã –≤ –º–µ—Ç–æ–¥–µ, –∞ –Ω–µ –≤–Ω–∞—á–∞–ª–µ –º–æ–¥—É–ª—è?

---

**Cursor**


–ü—Ä–æ–≤–µ—Ä—è—é —Ç–µ–∫—É—â—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –º–æ–¥—É–ª—è:



–ü—Ä–æ–≤–µ—Ä—è—é, –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ª–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö –ø–∞–∫–µ—Ç–∞:



–í –ø—Ä–æ–µ–∫—Ç–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã, –∏ –æ–Ω–∏ —Ä–∞–∑–º–µ—â–µ–Ω—ã –≤ –Ω–∞—á–∞–ª–µ –º–æ–¥—É–ª—è. –ò—Å–ø—Ä–∞–≤–ª—è—é –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è:

## –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã

### –®–∞–≥ 1: `JSQLExecutor` - –∏–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–µ –º–æ–¥—É–ª—è

```python
# src/namerec/uma/jsql/executor.py
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""
    
    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """Execute JSQL with full access control."""
        from namerec.uma.core.access import check_access
        
        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql)
        
        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)
            
            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                return QueryResult.from_cached(cached, params)
        
        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)
        
        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )
        
        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)
        
        # Cache result
        if cache_backend and cache_key:
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)
        
        return result
    
    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return QueryResult.from_db_result(result)
        finally:
            await conn.close()
```

### –®–∞–≥ 2: `entity_extractor.py` - –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å —Å –∏–º–ø–æ—Ä—Ç–∞–º–∏ –≤ –Ω–∞—á–∞–ª–µ

```python
# src/namerec/uma/jsql/entity_extractor.py
"""Entity extraction from SQLAlchemy AST."""

from typing import Any

from sqlalchemy.sql.expression import ColumnElement
from sqlalchemy.sql.expression import Select
from sqlalchemy import Table


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.
    
    Pure function - no state, no side effects.
    
    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)
    
    Returns:
        List of entity names (qualified with namespace if present)
    """
    entities: set[str] = set()
    
    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            if column == '*' or '.' not in column:
                entities.add(from_entity)
            else:
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)
        
        elif isinstance(column, ColumnElement):
            # Column expression - extract from table
            if hasattr(column, 'table') and column.table is not None:
                table = column.table
                if isinstance(table, Table):
                    entities.add(table.name)
                else:
                    entities.add(str(table))
        
        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)
    
    return list(entities)
```

### –®–∞–≥ 3: `access.py` - –Ω–æ–≤—ã–π –º–æ–¥—É–ª—å —Å –∏–º–ø–æ—Ä—Ç–∞–º–∏ –≤ –Ω–∞—á–∞–ª–µ

```python
# src/namerec/uma/core/access.py
"""Access control helper functions."""

from typing import Any

from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.types import Operation


def check_access(
    metadata_provider: Any,
    entity_name: str,
    operation: Operation | str,
    user_context: Any,
) -> None:
    """
    Check access and raise exception if access denied.
    
    Args:
        metadata_provider: Metadata provider with can() method
        entity_name: Entity name (empty string for "list entities" operation)
        operation: Operation name
        user_context: User context for access control
    
    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)
    
    # Check if metadata provider has can() method
    if hasattr(metadata_provider, 'can'):
        if not metadata_provider.can(entity_name, operation, user_context):
            raise UMAAccessDeniedError(entity_name, operation.value)
```

---

## –ò—Ç–æ–≥

- –ê–±—Å–æ–ª—é—Ç–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã: `from namerec.uma.jsql.parser import JSQLParser` (–∫–∞–∫ –≤ –ø—Ä–æ–µ–∫—Ç–µ)
- –ò–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–µ –º–æ–¥—É–ª—è (PEP 8)
- –ò—Å–∫–ª—é—á–µ–Ω–∏–µ: `check_access` –º–æ–∂–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤–Ω—É—Ç—Ä–∏ –º–µ—Ç–æ–¥–∞, –µ—Å–ª–∏ —ç—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤ (–Ω–æ –ª—É—á—à–µ –≤ –Ω–∞—á–∞–ª–µ)

–ü–æ–¥—Ö–æ–¥–∏—Ç?

```python
# src/namerec/uma/jsql/executor.py
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""
    
    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """Execute JSQL with full access control."""
        from namerec.uma.core.access import check_access
        
        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql)
        
        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)
            
            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                return QueryResult.from_cached(cached, params)
        
        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)
        
        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )
        
        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)
        
        # Cache result
        if cache_backend and cache_key:
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)
        
        return result
    
    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return QueryResult.from_db_result(result)
        finally:
            await conn.close()
```

```python
# src/namerec/uma/jsql/entity_extractor.py
"""Entity extraction from SQLAlchemy AST."""

from typing import Any

from sqlalchemy.sql.expression import ColumnElement
from sqlalchemy.sql.expression import Select
from sqlalchemy import Table


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.
    
    Pure function - no state, no side effects.
    
    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)
    
    Returns:
        List of entity names (qualified with namespace if present)
    """
    entities: set[str] = set()
    
    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            if column == '*' or '.' not in column:
                entities.add(from_entity)
            else:
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)
        
        elif isinstance(column, ColumnElement):
            # Column expression - extract from table
            if hasattr(column, 'table') and column.table is not None:
                table = column.table
                if isinstance(table, Table):
                    entities.add(table.name)
                else:
                    entities.add(str(table))
        
        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)
    
    return list(entities)
```

```python
# src/namerec/uma/core/access.py
"""Access control helper functions."""

from typing import Any

from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.types import Operation


def check_access(
    metadata_provider: Any,
    entity_name: str,
    operation: Operation | str,
    user_context: Any,
) -> None:
    """
    Check access and raise exception if access denied.
    
    Args:
        metadata_provider: Metadata provider with can() method
        entity_name: Entity name (empty string for "list entities" operation)
        operation: Operation name
        user_context: User context for access control
    
    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)
    
    # Check if metadata provider has can() method
    if hasattr(metadata_provider, 'can'):
        if not metadata_provider.can(entity_name, operation, user_context):
            raise UMAAccessDeniedError(entity_name, operation.value)
```

---

**User**

–î–∞, –≤–Ω–æ—Å–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–æ–¥, –Ω–æ commit –Ω–µ –≤—ã–ø–æ–ª–Ω—è–π –¥–æ –º–æ–µ–≥–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.

---

**Cursor**


–í–Ω–æ—à—É –∏–∑–º–µ–Ω–µ–Ω–∏—è. –ù–∞—á–∏–Ω–∞—é —Å —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –º–æ–¥—É–ª–µ–π, –∑–∞—Ç–µ–º –æ–±–Ω–æ–≤–ª—é —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ.



–°–æ–∑–¥–∞—é –Ω–æ–≤—ã–µ –º–æ–¥—É–ª–∏ –∏ –æ–±–Ω–æ–≤–ª—è—é —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ:


```python
"""Access control helper functions."""

from typing import Any

from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.types import Operation


def check_access(
    metadata_provider: Any,
    entity_name: str,
    operation: Operation | str,
    user_context: Any,
) -> None:
    """
    Check access and raise exception if access denied.

    Args:
        metadata_provider: Metadata provider with can() method
        entity_name: Entity name (empty string for "list entities" operation)
        operation: Operation name
        user_context: User context for access control

    Raises:
        UMAAccessDeniedError: If access denied
    """
    if isinstance(operation, str):
        operation = Operation(operation)

    # Check if metadata provider has can() method
    if hasattr(metadata_provider, 'can'):
        if not metadata_provider.can(entity_name, operation, user_context):
            raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""Entity extraction from SQLAlchemy AST."""

from typing import Any

from sqlalchemy.sql.expression import ColumnElement
from sqlalchemy.sql.expression import Select
from sqlalchemy import Table


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.

    Pure function - no state, no side effects.

    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)

    Returns:
        List of entity names (qualified with namespace if present)
    """
    entities: set[str] = set()

    # Extract from SELECT clause columns
    for column in select_ast.columns:
        if isinstance(column, str):
            if column == '*' or '.' not in column:
                entities.add(from_entity)
            else:
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)

        elif isinstance(column, ColumnElement):
            # Column expression - extract from table
            if hasattr(column, 'table') and column.table is not None:
                table = column.table
                if isinstance(table, Table):
                    entities.add(table.name)
                else:
                    entities.add(str(table))

        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)

    return list(entities)

```


–û–±–Ω–æ–≤–ª—è—é `CachedQuery` –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—è `entities`:


```python
"""Cache key generation and cached query structure."""

import hashlib
import json
from dataclasses import dataclass
from typing import Any


def make_cache_key(
    jsql: dict[str, Any],
    user_context: Any = None,
) -> str:
    """
    Create cache key for JSQL query.

    Includes user context hash to handle different permissions per user.
    Namespace is already in jsql dict (in FROM clause), so no need to pass separately.

    Args:
        jsql: JSQL query dictionary (contains namespace in FROM clause)
        user_context: User context (affects permissions/query results)

    Returns:
        Cache key (compact hash)

    Example:
        >>> jsql = {"from": "users", "select": ["id", "name"]}
        >>> key1 = make_cache_key(jsql, {"role": "admin"})
        >>> key2 = make_cache_key(jsql, {"role": "user"})
        >>> key1 != key2  # Different users = different cache keys
        True
    """
    # Stable JSON representation (includes namespace from FROM clause)
    jsql_str = json.dumps(jsql, sort_keys=True, ensure_ascii=False)

    # Include user context in key (for permission-based queries)
    if user_context:
        context_str = json.dumps(
            _extract_cache_key_context(user_context),
            sort_keys=True,
            ensure_ascii=False,
        )
    else:
        context_str = ""

    # Combine all components
    cache_input = f"{jsql_str}|{context_str}"

    # Use BLAKE2b for fast, secure hashing (16 bytes = 32 hex chars)
    return hashlib.blake2b(cache_input.encode(), digest_size=16).hexdigest()


def _extract_cache_key_context(user_context: Any) -> dict:
    """
    Extract cache-relevant fields from user context.

    Only include fields that affect query results (role, permissions),
    exclude session-specific data (session_id, last_login, etc.)

    Args:
        user_context: User context object/dict

    Returns:
        Dictionary with cache-relevant fields
    """
    if isinstance(user_context, dict):
        # Extract only permission-relevant fields
        return {
            'user_id': user_context.get('user_id'),
            'role': user_context.get('role'),
            'permissions': user_context.get('permissions'),
            'groups': user_context.get('groups'),
            # Exclude: session_id, last_login, ip_address, etc.
        }

    # For custom objects, try to extract standard attributes
    result = {}
    for attr in ('user_id', 'role', 'permissions', 'groups'):
        if hasattr(user_context, attr):
            result[attr] = getattr(user_context, attr)

    return result


@dataclass
class CachedQuery:
    """
    Cached query structure for Redis/external storage.

    Stores compiled SQL with parameter placeholders,
    not SQLAlchemy AST (which can't be serialized to Redis).
    """

    sql: str  # Compiled SQL with parameter placeholders
    params_mapping: dict[str, str]  # JSQL param names -> SQL param names
    dialect: str  # SQL dialect (postgresql, mysql, etc.)

    def to_dict(self) -> dict[str, Any]:
        """Serialize for Redis storage."""
        return {
            'sql': self.sql,
            'params_mapping': self.params_mapping,
            'dialect': self.dialect,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> 'CachedQuery':
        """Deserialize from Redis."""
        return cls(
            sql=data['sql'],
            params_mapping=data['params_mapping'],
            dialect=data['dialect'],
        )

```

```python
"""Cache key generation and cached query structure."""

import hashlib
import json
from dataclasses import dataclass
from dataclasses import field
from typing import Any


def make_cache_key(
    jsql: dict[str, Any],
    user_context: Any = None,
) -> str:
    """
    Create cache key for JSQL query.

    Includes user context hash to handle different permissions per user.
    Namespace is already in jsql dict (in FROM clause), so no need to pass separately.

    Args:
        jsql: JSQL query dictionary (contains namespace in FROM clause)
        user_context: User context (affects permissions/query results)

    Returns:
        Cache key (compact hash)

    Example:
        >>> jsql = {"from": "users", "select": ["id", "name"]}
        >>> key1 = make_cache_key(jsql, {"role": "admin"})
        >>> key2 = make_cache_key(jsql, {"role": "user"})
        >>> key1 != key2  # Different users = different cache keys
        True
    """
    # Stable JSON representation (includes namespace from FROM clause)
    jsql_str = json.dumps(jsql, sort_keys=True, ensure_ascii=False)

    # Include user context in key (for permission-based queries)
    if user_context:
        context_str = json.dumps(
            _extract_cache_key_context(user_context),
            sort_keys=True,
            ensure_ascii=False,
        )
    else:
        context_str = ""

    # Combine all components
    cache_input = f"{jsql_str}|{context_str}"

    # Use BLAKE2b for fast, secure hashing (16 bytes = 32 hex chars)
    return hashlib.blake2b(cache_input.encode(), digest_size=16).hexdigest()


def _extract_cache_key_context(user_context: Any) -> dict:
    """
    Extract cache-relevant fields from user context.

    Only include fields that affect query results (role, permissions),
    exclude session-specific data (session_id, last_login, etc.)

    Args:
        user_context: User context object/dict

    Returns:
        Dictionary with cache-relevant fields
    """
    if isinstance(user_context, dict):
        # Extract only permission-relevant fields
        return {
            'user_id': user_context.get('user_id'),
            'role': user_context.get('role'),
            'permissions': user_context.get('permissions'),
            'groups': user_context.get('groups'),
            # Exclude: session_id, last_login, ip_address, etc.
        }

    # For custom objects, try to extract standard attributes
    result = {}
    for attr in ('user_id', 'role', 'permissions', 'groups'):
        if hasattr(user_context, attr):
            result[attr] = getattr(user_context, attr)

    return result


@dataclass
class CachedQuery:
    """
    Cached query structure for Redis/external storage.

    Stores compiled SQL with parameter placeholders,
    not SQLAlchemy AST (which can't be serialized to Redis).
    """

    sql: str  # Compiled SQL with parameter placeholders
    params_mapping: dict[str, str]  # JSQL param names -> SQL param names
    dialect: str  # SQL dialect (postgresql, mysql, etc.)

    def to_dict(self) -> dict[str, Any]:
        """Serialize for Redis storage."""
        return {
            'sql': self.sql,
            'params_mapping': self.params_mapping,
            'dialect': self.dialect,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> 'CachedQuery':
        """Deserialize from Redis."""
        return cls(
            sql=data['sql'],
            params_mapping=data['params_mapping'],
            dialect=data['dialect'],
        )

```

```python
"""Cache key generation and cached query structure."""

import hashlib
import json
from dataclasses import dataclass
from dataclasses import field
from typing import Any


def make_cache_key(
    jsql: dict[str, Any],
    user_context: Any = None,
) -> str:
    """
    Create cache key for JSQL query.

    Includes user context hash to handle different permissions per user.
    Namespace is already in jsql dict (in FROM clause), so no need to pass separately.

    Args:
        jsql: JSQL query dictionary (contains namespace in FROM clause)
        user_context: User context (affects permissions/query results)

    Returns:
        Cache key (compact hash)

    Example:
        >>> jsql = {"from": "users", "select": ["id", "name"]}
        >>> key1 = make_cache_key(jsql, {"role": "admin"})
        >>> key2 = make_cache_key(jsql, {"role": "user"})
        >>> key1 != key2  # Different users = different cache keys
        True
    """
    # Stable JSON representation (includes namespace from FROM clause)
    jsql_str = json.dumps(jsql, sort_keys=True, ensure_ascii=False)

    # Include user context in key (for permission-based queries)
    if user_context:
        context_str = json.dumps(
            _extract_cache_key_context(user_context),
            sort_keys=True,
            ensure_ascii=False,
        )
    else:
        context_str = ""

    # Combine all components
    cache_input = f"{jsql_str}|{context_str}"

    # Use BLAKE2b for fast, secure hashing (16 bytes = 32 hex chars)
    return hashlib.blake2b(cache_input.encode(), digest_size=16).hexdigest()


def _extract_cache_key_context(user_context: Any) -> dict:
    """
    Extract cache-relevant fields from user context.

    Only include fields that affect query results (role, permissions),
    exclude session-specific data (session_id, last_login, etc.)

    Args:
        user_context: User context object/dict

    Returns:
        Dictionary with cache-relevant fields
    """
    if isinstance(user_context, dict):
        # Extract only permission-relevant fields
        return {
            'user_id': user_context.get('user_id'),
            'role': user_context.get('role'),
            'permissions': user_context.get('permissions'),
            'groups': user_context.get('groups'),
            # Exclude: session_id, last_login, ip_address, etc.
        }

    # For custom objects, try to extract standard attributes
    result = {}
    for attr in ('user_id', 'role', 'permissions', 'groups'):
        if hasattr(user_context, attr):
            result[attr] = getattr(user_context, attr)

    return result


@dataclass
class CachedQuery:
    """
    Cached query structure for Redis/external storage.

    Stores compiled SQL with parameter placeholders,
    not SQLAlchemy AST (which can't be serialized to Redis).
    """

    sql: str  # Compiled SQL with parameter placeholders
    params_mapping: dict[str, str]  # JSQL param names -> SQL param names
    dialect: str  # SQL dialect (postgresql, mysql, etc.)
    entities: list[str] = field(default_factory=list)  # Entities in SELECT clause

    def to_dict(self) -> dict[str, Any]:
        """Serialize for Redis storage."""
        return {
            'sql': self.sql,
            'params_mapping': self.params_mapping,
            'dialect': self.dialect,
            'entities': self.entities,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> 'CachedQuery':
        """Deserialize from Redis."""
        return cls(
            sql=data['sql'],
            params_mapping=data['params_mapping'],
            dialect=data['dialect'],
            entities=data.get('entities', []),
        )

```


–ò–∑—É—á–∞—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É `JSQLParser`:



–û–±–Ω–æ–≤–ª—è—é `JSQLParser`:


```python
"""JSQL parser - converts JSQL (JSON-SQL) to SQLAlchemy queries."""

from collections.abc import Callable
from typing import Any

from sqlalchemy import Column
from sqlalchemy import Select
from sqlalchemy import and_
from sqlalchemy import bindparam
from sqlalchemy import cast
from sqlalchemy import exists
from sqlalchemy import func
from sqlalchemy import literal
from sqlalchemy import not_
from sqlalchemy import or_
from sqlalchemy import select
from sqlalchemy.sql import ColumnElement
from sqlalchemy.sql.expression import ClauseElement

from collections.abc import Mapping

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityName
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.jsql.alias_manager import AliasManager
from namerec.uma.jsql.constants import ARITHMETIC_OPERATORS
from namerec.uma.jsql.constants import COMPARISON_OPERATORS
from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import JSQLField
from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLExpression
from namerec.uma.jsql.types import JSQLQuery


class JSQLParser:
    """
    Parser for JSQL (JSON-SQL) queries.
    Converts JSQL dict to SQLAlchemy Select statement.
    """

    def __init__(self, context: UMAContext) -> None:
        """
        Initialize JSQL parser.

        Args:
            context: UMA execution context
        """
        self.context = context
        self.ctes: dict[str, Select] = {}  # CTEs by name (for SQLAlchemy queries)
        self.alias_manager = AliasManager()  # Manages table/column aliases
        self.select_aliases: dict[str, ColumnElement] = {}  # SELECT column aliases

        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            JSQLOperator.NOT: self._handle_not,
            JSQLOperator.IN: self._handle_in,
            JSQLOperator.BETWEEN: self._handle_between,
            JSQLOperator.EXISTS: self._handle_exists,
            JSQLOperator.IS_NULL: self._handle_is_null,
            JSQLOperator.IS_NOT_NULL: self._handle_is_not_null,
            JSQLOperator.LIKE: self._handle_like,
        }

    async def parse(self, jsql: JSQLQuery, params: dict[str, Any] | None = None) -> Select:
        """
        Parse JSQL query into SQLAlchemy Select statement.

        Args:
            jsql: JSQL query dictionary
            params: Query parameters

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If JSQL syntax is invalid
        """
        self.params = params or {}

        # Parse CTEs if present
        if with_spec := jsql.get(JSQLField.WITH.value):
            await self._parse_ctes(with_spec)

        # Build main query
        query = await self._build_query(jsql)

        return query

    async def _parse_ctes(self, ctes: list[dict[str, Any]]) -> None:
        """
        Parse CTEs (Common Table Expressions).

        Args:
            ctes: List of CTE definitions

        Raises:
            JSQLSyntaxError: If CTE syntax is invalid
        """
        for i, cte_def in enumerate(ctes):
            path = f'{JSQLField.WITH.value}[{i}]'

            if JSQLField.NAME.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.NAME.value}" field', path)

            if JSQLField.QUERY.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.QUERY.value}" field', path)

            cte_name = cte_def[JSQLField.NAME.value]
            cte_query = await self._build_query(cte_def[JSQLField.QUERY.value])

            # Register CTE for later use
            cte = cte_query.cte(name=cte_name)
            self.ctes[cte_name] = cte
            
            # Register CTE in AliasManager for column resolution
            self.alias_manager.register_cte(cte_name, cte)

    async def _build_query(self, jsql: JSQLQuery) -> Select:
        """
        Build SELECT query from JSQL.

        Args:
            jsql: JSQL query dictionary

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If query syntax is invalid
        """
        if JSQLField.FROM.value not in jsql:
            raise JSQLSyntaxError(f'Query must have "{JSQLField.FROM.value}" field')

        # Get FROM clause
        from_clause = await self._build_from(jsql[JSQLField.FROM.value])

        # Process JOINs first to register all table aliases
        if joins_spec := jsql.get(JSQLField.JOINS.value):
            from_clause = await self._process_joins_for_aliases(joins_spec, from_clause)

        # Build SELECT clause (now all aliases are registered)
        select_items = await self._build_select(
            jsql.get(JSQLField.SELECT.value, ['*']), from_clause
        )

        # Start building query
        query = select(*select_items).select_from(from_clause)

        # Add WHERE
        if where_spec := jsql.get(JSQLField.WHERE.value):
            where_clause = await self._build_condition(where_spec)
            query = query.where(where_clause)

        # Add GROUP BY
        if group_by_spec := jsql.get(JSQLField.GROUP_BY.value):
            group_by_clauses = await self._build_group_by(group_by_spec)
            query = query.group_by(*group_by_clauses)

        # Add HAVING
        if having_spec := jsql.get(JSQLField.HAVING.value):
            having_clause = await self._build_condition(having_spec)
            query = query.having(having_clause)

        # Add ORDER BY
        if order_by_spec := jsql.get(JSQLField.ORDER_BY.value):
            order_by_clauses = await self._build_order_by(order_by_spec)
            query = query.order_by(*order_by_clauses)

        # Add LIMIT (check 'is not None' to allow 0)
        if (limit_value := jsql.get(JSQLField.LIMIT.value)) is not None:
            query = query.limit(limit_value)

        # Add OFFSET (check 'is not None' to allow 0)
        if (offset_value := jsql.get(JSQLField.OFFSET.value)) is not None:
            query = query.offset(offset_value)

        return query

    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """
        Register table alias and index its columns for fast lookup.

        Args:
            alias_name: Primary alias name
            table: Table object
            additional_aliases: Additional alias names for the same table
        """
        # Delegate to AliasManager
        self.alias_manager.register_table(alias_name, table, *additional_aliases)

    async def _build_from(self, from_spec: str) -> Any:
        """
        Build FROM clause.

        Args:
            from_spec: Table name (string)

        Returns:
            SQLAlchemy table or CTE reference

        Raises:
            JSQLSyntaxError: If FROM syntax is invalid or table not found
        """
        if not isinstance(from_spec, str):
            raise JSQLSyntaxError(
                f'FROM clause must be a string (table name), got {type(from_spec).__name__}. '
                'Subqueries and complex FROM specifications are not yet supported.'
            )

        # Check if it's a CTE
        if from_spec in self.ctes:
            cte = self.ctes[from_spec]
            self._register_table_alias(from_spec, cte)
            return cte

        # Regular table
        entity_name = parse_entity_name(from_spec)

        # Note: Table should be preloaded in executor before parsing
        # This ensures lazy loading happens before synchronous parsing
        table = await self._get_table_async(entity_name)

        # Register both by entity name and by from_spec (they might differ with namespace)
        self._register_table_alias(
            entity_name.entity,
            table,
            *([] if from_spec == entity_name.entity else [from_spec])
        )
        return table

    async def _get_table_async(self, entity_name: EntityName) -> Any:
        """
        Get table via metadata provider (lazy loading).

        Args:
            entity_name: Entity name

        Returns:
            SQLAlchemy Table object

        Raises:
            JSQLSyntaxError: If table not found
        """
        try:
            return await get_table(self.context, entity_name)
        except Exception as e:
            raise JSQLSyntaxError(f'Table "{entity_name}" not found: {e}') from e

    def _apply_alias(self, expression: ColumnElement, alias_name: str | None) -> ColumnElement:
        """
        Apply alias to expression and register it.

        Args:
            expression: SQLAlchemy expression
            alias_name: Alias name (if provided)

        Returns:
            Expression with alias applied (if provided)
        """
        if alias_name:
            labeled_expr = expression.label(alias_name)
            # Store alias for ORDER BY resolution
            self.select_aliases[alias_name] = labeled_expr
            return labeled_expr
        return expression

    async def _build_select(self, select_spec: list[str | dict[str, Any]], from_clause: Any) -> list[ColumnElement]:
        """
        Build SELECT clause items.

        Args:
            select_spec: List of select specifications
            from_clause: FROM clause for column resolution

        Returns:
            List of SQLAlchemy column elements

        Raises:
            JSQLSyntaxError: If SELECT syntax is invalid
        """
        items: list[ColumnElement] = []

        for i, item_spec in enumerate(select_spec):
            path = f'{JSQLField.SELECT.value}[{i}]'

            # Wildcard: SELECT *
            if item_spec == '*':
                # Add all columns from the FROM clause
                if hasattr(from_clause, 'columns'):
                    items.extend(from_clause.columns)
                continue

            # Simple string field name
            if isinstance(item_spec, str):
                column = await self._resolve_column(item_spec, from_clause)
                items.append(column)
                continue

            # Dictionary specification
            if not isinstance(item_spec, dict):
                raise JSQLSyntaxError(f'Invalid SELECT item type: {type(item_spec)}', path)

            # Extract alias once
            alias_name = item_spec.get(JSQLField.ALIAS.value)

            # Field with optional alias
            if field_name := item_spec.get(JSQLField.FIELD.value):
                column = await self._resolve_column(field_name, from_clause)
                items.append(self._apply_alias(column, alias_name))
                continue

            # Function call
            if JSQLField.FUNC.value in item_spec:
                func_expr = await self._build_function(item_spec, path)
                items.append(self._apply_alias(func_expr, alias_name))
                continue

            # Expression
            if expr_spec := item_spec.get(JSQLField.EXPR.value):
                expr = await self._build_expression(expr_spec)
                items.append(self._apply_alias(expr, alias_name))
                continue

            # Window function
            if window_spec := item_spec.get(JSQLField.WINDOW_FUNC.value):
                window_expr = await self._build_window_function(window_spec, path)
                items.append(self._apply_alias(window_expr, alias_name))
                continue

            # Literal value
            if (value := item_spec.get(JSQLField.VALUE.value)) is not None:
                value_expr = literal(value)
                items.append(self._apply_alias(value_expr, alias_name))
                continue

            raise JSQLSyntaxError(
                f'SELECT item must have one of: {JSQLField.FIELD.value}, {JSQLField.FUNC.value}, '
                f'{JSQLField.EXPR.value}, {JSQLField.WINDOW_FUNC.value}, {JSQLField.VALUE.value}',
                path
            )

        return items

    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """
        Resolve column reference (e.g., 'users.id' or 'id').

        Args:
            field_spec: Field specification
            from_clause: FROM clause for column resolution (can be None)

        Returns:
            SQLAlchemy column

        Raises:
            JSQLSyntaxError: If column not found
        """
        # Try to resolve through AliasManager first
        try:
            return self.alias_manager.resolve_column(field_spec, from_clause)
        except JSQLSyntaxError:
            # If qualified column not found in aliases, try lazy loading
            if '.' in field_spec:
                table_name, column_name = field_spec.split('.', 1)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                    if column_name in table.columns:
                        return table.columns[column_name]
                except Exception as e:
                    raise JSQLSyntaxError(f'Column "{field_spec}" not found: {e}') from e
            
            # Re-raise original error if lazy loading also fails
            raise

    async def _process_joins_for_aliases(self, joins_spec: list[dict[str, Any]], base_table: Any) -> Any:
        """
        Process JOINs to register aliases and build joined FROM clause.

        Args:
            joins_spec: List of join specifications
            base_table: Base table for joins

        Returns:
            FROM clause with joins applied

        Raises:
            JSQLSyntaxError: If JOIN syntax is invalid
        """
        current_from = base_table

        for i, join_spec in enumerate(joins_spec):
            path = f'{JSQLField.JOINS.value}[{i}]'

            if JSQLField.TABLE.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.TABLE.value}" field', path)

            # Get join type (default INNER) and validate
            join_type_str = join_spec.get(JSQLField.TYPE.value, JoinType.INNER.value).upper()
            try:
                join_type = JoinType(join_type_str)
            except ValueError:
                raise JSQLSyntaxError(f'Invalid join type: {join_type_str}', path)

            # CROSS JOIN doesn't require ON clause
            if join_type != JoinType.CROSS and JSQLField.ON.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.ON.value}" field', path)

            # Get table
            table_name = join_spec[JSQLField.TABLE.value]

            # Check if it's a CTE or regular table
            if table_name in self.ctes:
                table = self.ctes[table_name]
            else:
                # Load table via metadata provider (lazy loading)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                except Exception as e:
                    raise JSQLSyntaxError(f'Table "{table_name}" not found: {e}', path) from e

            # Handle alias
            if alias_name := join_spec.get(JSQLField.ALIAS.value):
                table = table.alias(alias_name)
            else:
                alias_name = table_name

            # Register alias
            self._register_table_alias(alias_name, table)

            # Apply join based on type - use pattern matching
            match join_type:
                case JoinType.CROSS:
                    # CROSS JOIN - no ON clause
                    current_from = current_from.join(table, isouter=False, full=False)
                case JoinType.LEFT:
                    # LEFT OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True)
                case JoinType.RIGHT:
                    # RIGHT OUTER JOIN - reverse the order
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = table.join(current_from, on_condition, isouter=True)
                case JoinType.FULL:
                    # FULL OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True, full=True)
                case JoinType.INNER:
                    # INNER JOIN (default)
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=False)

        return current_from

    async def _handle_and(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle AND operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.AND.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return and_(*conditions)

    async def _handle_or(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle OR operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.OR.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return or_(*conditions)

    async def _handle_not(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle NOT operator."""
        if JSQLField.CONDITION.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.NOT.value} must have "{JSQLField.CONDITION.value}" field')
        condition = await self._build_condition(condition_spec[JSQLField.CONDITION.value])
        return not_(condition)

    async def _handle_comparison(self, op: JSQLOperator, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle comparison operators (=, !=, <, <=, >, >=)."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)

        # Use match-case for operator dispatch
        match op:
            case JSQLOperator.EQ:
                return left == right
            case JSQLOperator.NE:
                return left != right
            case JSQLOperator.LT:
                return left < right
            case JSQLOperator.LE:
                return left <= right
            case JSQLOperator.GT:
                return left > right
            case JSQLOperator.GE:
                return left >= right
            case _:
                raise JSQLSyntaxError(f'Unknown comparison operator: {op.value}')

    async def _handle_in(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IN operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        right_spec = condition_spec[JSQLField.RIGHT.value]

        # Subquery
        if isinstance(right_spec, dict) and JSQLField.SUBQUERY.value in right_spec:
            subquery = await self._build_query(right_spec[JSQLField.SUBQUERY.value])
            return left.in_(subquery)

        # List of values
        if isinstance(right_spec, list):
            return left.in_(right_spec)

        # Expression
        right = await self._build_expression(right_spec)
        return left.in_(right)

    async def _handle_exists(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle EXISTS operator."""
        if JSQLField.SUBQUERY.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.EXISTS.value} must have "{JSQLField.SUBQUERY.value}" field')
        subquery = await self._build_query(condition_spec[JSQLField.SUBQUERY.value])
        return exists(subquery)

    async def _handle_is_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.is_(None)

    async def _handle_is_not_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NOT NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NOT_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.isnot(None)

    async def _handle_like(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle LIKE operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)
        return left.like(right)

    async def _handle_between(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Handle BETWEEN operator.
        
        JSQL format: {"op": "BETWEEN", "expr": {...}, "low": {...}, "high": {...}}
        SQL equivalent: expr BETWEEN low AND high
        """
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "{JSQLField.EXPR.value}" field')
        if 'low' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "low" field')
        if 'high' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "high" field')

        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        # Extract type from expression to use for low/high bounds
        expr_type = getattr(expr, 'type', None) if hasattr(expr, 'type') else None
        low = await self._build_expression(condition_spec['low'], expected_type=expr_type)
        high = await self._build_expression(condition_spec['high'], expected_type=expr_type)
        
        return expr.between(low, high)

    async def _build_condition(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Build WHERE/HAVING condition.

        Args:
            condition_spec: Condition specification

        Returns:
            SQLAlchemy condition

        Raises:
            JSQLSyntaxError: If condition syntax is invalid
        """
        if JSQLField.OP.value not in condition_spec:
            raise JSQLSyntaxError(f'Condition must have "{JSQLField.OP.value}" field')

        op_str = condition_spec[JSQLField.OP.value].upper()

        # Try to convert to JSQLOperator enum
        try:
            op = JSQLOperator(op_str)
        except ValueError:
            raise JSQLSyntaxError(f'Unknown operator: {op_str}')

        # Use dispatch table for special operators
        if handler := self._condition_handlers.get(op):
            return await handler(condition_spec)

        # Handle comparison operators
        if op in COMPARISON_OPERATORS:
            return await self._handle_comparison(op, condition_spec)

        raise JSQLSyntaxError(f'Unsupported operator: {op_str}')

    async def _build_expression(
        self,
        expr_spec: JSQLExpression,
        expected_type: Any | None = None
    ) -> ColumnElement:
        """
        Build expression (arithmetic, logical, etc.).

        Args:
            expr_spec: Expression specification
            expected_type: Expected SQLAlchemy type for literals/parameters (optional)

        Returns:
            SQLAlchemy expression

        Raises:
            JSQLSyntaxError: If expression syntax is invalid
        """
        # Field reference
        if field_name := expr_spec.get(JSQLField.FIELD.value):
            return await self._resolve_column(field_name, None)

        # Literal value
        if (value := expr_spec.get(JSQLField.VALUE.value)) is not None:
            if expected_type is not None:
                # Use cast() for explicit type conversion to avoid VARCHAR casting issues
                return cast(literal(value), expected_type)
            return literal(value)

        # Parameter - use walrus operator
        if param_name := expr_spec.get(JSQLField.PARAM.value):
            if param_name not in self.params:
                raise JSQLSyntaxError(f'Parameter "{param_name}" not provided')
            # Use cast() for explicit type conversion when expected_type is available
            if expected_type is not None:
                return cast(literal(self.params[param_name]), expected_type)
            return literal(self.params[param_name])

        # Function call
        if JSQLField.FUNC.value in expr_spec:
            return await self._build_function(expr_spec)

        # Operator expression
        if JSQLField.OP.value in expr_spec:
            op_str = expr_spec[JSQLField.OP.value].upper()

            # Try to convert to JSQLOperator enum
            try:
                op = JSQLOperator(op_str)
            except ValueError:
                # Unknown operator - might be condition
                return await self._build_condition(expr_spec)

            # Binary arithmetic operators - use pattern matching
            if op in ARITHMETIC_OPERATORS:
                # Validate required fields
                if JSQLField.LEFT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
                if JSQLField.RIGHT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

                left = await self._build_expression(expr_spec[JSQLField.LEFT.value])
                right = await self._build_expression(expr_spec[JSQLField.RIGHT.value])

                match op:
                    case JSQLOperator.ADD:
                        return left + right
                    case JSQLOperator.SUB:
                        return left - right
                    case JSQLOperator.MUL:
                        return left * right
                    case JSQLOperator.DIV:
                        return left / right
                    case JSQLOperator.MOD:
                        return left % right

            # This might be a condition (for CASE WHEN)
            return await self._build_condition(expr_spec)

        # Subquery
        if subquery_spec := expr_spec.get(JSQLField.SUBQUERY.value):
            return await self._build_query(subquery_spec)

        raise JSQLSyntaxError(
            f'Invalid expression: must have {JSQLField.FIELD.value}, {JSQLField.VALUE.value}, '
            f'{JSQLField.PARAM.value}, {JSQLField.FUNC.value}, or {JSQLField.OP.value}'
        )

    async def _build_function(self, func_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build function call.

        Args:
            func_spec: Function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy function call

        Raises:
            JSQLSyntaxError: If function syntax is invalid
        """
        if JSQLField.FUNC.value not in func_spec:
            raise JSQLSyntaxError(f'Function must have "{JSQLField.FUNC.value}" field', path)

        func_name = func_spec[JSQLField.FUNC.value].upper()
        args_spec = func_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Handle DISTINCT
        if func_spec.get(JSQLField.DISTINCT.value, False) and args:
            args[0] = args[0].distinct()

        # Call function
        return sql_func(*args)

    async def _build_window_function(self, window_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build window function.

        Args:
            window_spec: Window function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy window function

        Raises:
            JSQLSyntaxError: If window function syntax is invalid
        """
        if JSQLField.FUNC.value not in window_spec:
            raise JSQLSyntaxError(f'Window function must have "{JSQLField.FUNC.value}" field', path)

        func_name = window_spec[JSQLField.FUNC.value].upper()
        args_spec = window_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Build function call
        func_call = sql_func(*args) if args else sql_func()

        # Build OVER clause - use walrus operator for partition_by
        partition_by = None
        if partition_by_spec := window_spec.get(JSQLField.PARTITION_BY.value):
            partition_by = []
            for part in partition_by_spec:
                if isinstance(part, dict) and JSQLField.FIELD.value in part:
                    partition_by.append(await self._resolve_column(part[JSQLField.FIELD.value], None))
                else:
                    raise JSQLSyntaxError(f'{JSQLField.PARTITION_BY.value} must contain field references', path)

        # Use walrus operator for order_by
        order_by = (
            await self._build_order_by(order_by_spec)
            if (order_by_spec := window_spec.get(JSQLField.ORDER_BY.value))
            else None
        )

        # Apply OVER
        return func_call.over(partition_by=partition_by, order_by=order_by)

    async def _build_group_by(self, group_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build GROUP BY clause.

        Args:
            group_by_spec: List of group by specifications

        Returns:
            List of SQLAlchemy expressions

        Raises:
            JSQLSyntaxError: If GROUP BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in group_by_spec:
            if isinstance(item, str):
                result.append(await self._resolve_column(item, None))
            elif isinstance(item, dict) and JSQLField.FIELD.value in item:
                result.append(await self._resolve_column(item[JSQLField.FIELD.value], None))
            else:
                raise JSQLSyntaxError(f'GROUP BY item must be field name or {{{JSQLField.FIELD.value}: ...}}')

        return result

    async def _resolve_field_or_alias(self, field_name: str) -> ColumnElement:
        """
        Resolve field name or SELECT alias.

        Args:
            field_name: Field name or alias

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If field/alias not found
        """
        # Check if it's a SELECT alias first
        if field_name in self.select_aliases:
            return self.select_aliases[field_name]
        # Otherwise resolve as column
        return await self._resolve_column(field_name, None)

    async def _build_order_by(self, order_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build ORDER BY clause.

        Args:
            order_by_spec: List of order by specifications

        Returns:
            List of SQLAlchemy order expressions

        Raises:
            JSQLSyntaxError: If ORDER BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in order_by_spec:
            if isinstance(item, str):
                column = await self._resolve_field_or_alias(item)
                result.append(column.asc())
            elif isinstance(item, dict):
                if JSQLField.FIELD.value not in item:
                    raise JSQLSyntaxError(f'ORDER BY item must have "{JSQLField.FIELD.value}"')

                field_name = item[JSQLField.FIELD.value]
                column = await self._resolve_field_or_alias(field_name)

                direction = item.get(JSQLField.DIRECTION.value, OrderDirection.ASC.value).lower()

                # Use pattern matching for direction
                match direction:
                    case OrderDirection.ASC.value:
                        result.append(column.asc())
                    case OrderDirection.DESC.value:
                        result.append(column.desc())
                    case _:
                        raise JSQLSyntaxError(f'Invalid ORDER BY direction: {direction}')
            else:
                raise JSQLSyntaxError(
                    f'ORDER BY item must be field name or '
                    f'{{{JSQLField.FIELD.value}: ..., {JSQLField.DIRECTION.value}: ...}}'
                )

        return result

```

```python
"""JSQL parser - converts JSQL (JSON-SQL) to SQLAlchemy queries."""

from collections.abc import Callable
from typing import Any

from sqlalchemy import Column
from sqlalchemy import Select
from sqlalchemy import and_
from sqlalchemy import bindparam
from sqlalchemy import cast
from sqlalchemy import exists
from sqlalchemy import func
from sqlalchemy import literal
from sqlalchemy import not_
from sqlalchemy import or_
from sqlalchemy import select
from sqlalchemy.sql import ColumnElement
from sqlalchemy.sql.expression import ClauseElement

from collections.abc import Mapping

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityName
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.jsql.alias_manager import AliasManager
from namerec.uma.jsql.constants import ARITHMETIC_OPERATORS
from namerec.uma.jsql.constants import COMPARISON_OPERATORS
from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import JSQLField
from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLExpression
from namerec.uma.jsql.types import JSQLQuery


class JSQLParser:
    """
    Parser for JSQL (JSON-SQL) queries.
    Converts JSQL dict to SQLAlchemy Select statement.
    """

    def __init__(self, namespace_configs: Mapping[str, NamespaceConfig]) -> None:
        """
        Initialize JSQL parser.

        Args:
            namespace_configs: Mapping of namespace names to configurations
        """
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}  # CTEs by name (for SQLAlchemy queries)
        self.alias_manager = AliasManager()  # Manages table/column aliases
        self.select_aliases: dict[str, ColumnElement] = {}  # SELECT column aliases

        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            JSQLOperator.NOT: self._handle_not,
            JSQLOperator.IN: self._handle_in,
            JSQLOperator.BETWEEN: self._handle_between,
            JSQLOperator.EXISTS: self._handle_exists,
            JSQLOperator.IS_NULL: self._handle_is_null,
            JSQLOperator.IS_NOT_NULL: self._handle_is_not_null,
            JSQLOperator.LIKE: self._handle_like,
        }

    async def parse(self, jsql: JSQLQuery, params: dict[str, Any] | None = None) -> Select:
        """
        Parse JSQL query into SQLAlchemy Select statement.

        Args:
            jsql: JSQL query dictionary
            params: Query parameters

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If JSQL syntax is invalid
        """
        self.params = params or {}

        # Parse CTEs if present
        if with_spec := jsql.get(JSQLField.WITH.value):
            await self._parse_ctes(with_spec)

        # Build main query
        query = await self._build_query(jsql)

        return query

    async def _parse_ctes(self, ctes: list[dict[str, Any]]) -> None:
        """
        Parse CTEs (Common Table Expressions).

        Args:
            ctes: List of CTE definitions

        Raises:
            JSQLSyntaxError: If CTE syntax is invalid
        """
        for i, cte_def in enumerate(ctes):
            path = f'{JSQLField.WITH.value}[{i}]'

            if JSQLField.NAME.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.NAME.value}" field', path)

            if JSQLField.QUERY.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.QUERY.value}" field', path)

            cte_name = cte_def[JSQLField.NAME.value]
            cte_query = await self._build_query(cte_def[JSQLField.QUERY.value])

            # Register CTE for later use
            cte = cte_query.cte(name=cte_name)
            self.ctes[cte_name] = cte
            
            # Register CTE in AliasManager for column resolution
            self.alias_manager.register_cte(cte_name, cte)

    async def _build_query(self, jsql: JSQLQuery) -> Select:
        """
        Build SELECT query from JSQL.

        Args:
            jsql: JSQL query dictionary

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If query syntax is invalid
        """
        if JSQLField.FROM.value not in jsql:
            raise JSQLSyntaxError(f'Query must have "{JSQLField.FROM.value}" field')

        # Get FROM clause
        from_clause = await self._build_from(jsql[JSQLField.FROM.value])

        # Process JOINs first to register all table aliases
        if joins_spec := jsql.get(JSQLField.JOINS.value):
            from_clause = await self._process_joins_for_aliases(joins_spec, from_clause)

        # Build SELECT clause (now all aliases are registered)
        select_items = await self._build_select(
            jsql.get(JSQLField.SELECT.value, ['*']), from_clause
        )

        # Start building query
        query = select(*select_items).select_from(from_clause)

        # Add WHERE
        if where_spec := jsql.get(JSQLField.WHERE.value):
            where_clause = await self._build_condition(where_spec)
            query = query.where(where_clause)

        # Add GROUP BY
        if group_by_spec := jsql.get(JSQLField.GROUP_BY.value):
            group_by_clauses = await self._build_group_by(group_by_spec)
            query = query.group_by(*group_by_clauses)

        # Add HAVING
        if having_spec := jsql.get(JSQLField.HAVING.value):
            having_clause = await self._build_condition(having_spec)
            query = query.having(having_clause)

        # Add ORDER BY
        if order_by_spec := jsql.get(JSQLField.ORDER_BY.value):
            order_by_clauses = await self._build_order_by(order_by_spec)
            query = query.order_by(*order_by_clauses)

        # Add LIMIT (check 'is not None' to allow 0)
        if (limit_value := jsql.get(JSQLField.LIMIT.value)) is not None:
            query = query.limit(limit_value)

        # Add OFFSET (check 'is not None' to allow 0)
        if (offset_value := jsql.get(JSQLField.OFFSET.value)) is not None:
            query = query.offset(offset_value)

        return query

    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """
        Register table alias and index its columns for fast lookup.

        Args:
            alias_name: Primary alias name
            table: Table object
            additional_aliases: Additional alias names for the same table
        """
        # Delegate to AliasManager
        self.alias_manager.register_table(alias_name, table, *additional_aliases)

    async def _build_from(self, from_spec: str) -> Any:
        """
        Build FROM clause.

        Args:
            from_spec: Table name (string)

        Returns:
            SQLAlchemy table or CTE reference

        Raises:
            JSQLSyntaxError: If FROM syntax is invalid or table not found
        """
        if not isinstance(from_spec, str):
            raise JSQLSyntaxError(
                f'FROM clause must be a string (table name), got {type(from_spec).__name__}. '
                'Subqueries and complex FROM specifications are not yet supported.'
            )

        # Check if it's a CTE
        if from_spec in self.ctes:
            cte = self.ctes[from_spec]
            self._register_table_alias(from_spec, cte)
            return cte

        # Regular table
        entity_name = parse_entity_name(from_spec)

        # Note: Table should be preloaded in executor before parsing
        # This ensures lazy loading happens before synchronous parsing
        table = await self._get_table_async(entity_name)

        # Register both by entity name and by from_spec (they might differ with namespace)
        self._register_table_alias(
            entity_name.entity,
            table,
            *([] if from_spec == entity_name.entity else [from_spec])
        )
        return table

    async def _get_table_async(self, entity_name: EntityName) -> Any:
        """
        Get table via metadata provider (lazy loading).

        Args:
            entity_name: Entity name

        Returns:
            SQLAlchemy Table object

        Raises:
            JSQLSyntaxError: If table not found
        """
        try:
            return await get_table(self.context, entity_name)
        except Exception as e:
            raise JSQLSyntaxError(f'Table "{entity_name}" not found: {e}') from e

    def _apply_alias(self, expression: ColumnElement, alias_name: str | None) -> ColumnElement:
        """
        Apply alias to expression and register it.

        Args:
            expression: SQLAlchemy expression
            alias_name: Alias name (if provided)

        Returns:
            Expression with alias applied (if provided)
        """
        if alias_name:
            labeled_expr = expression.label(alias_name)
            # Store alias for ORDER BY resolution
            self.select_aliases[alias_name] = labeled_expr
            return labeled_expr
        return expression

    async def _build_select(self, select_spec: list[str | dict[str, Any]], from_clause: Any) -> list[ColumnElement]:
        """
        Build SELECT clause items.

        Args:
            select_spec: List of select specifications
            from_clause: FROM clause for column resolution

        Returns:
            List of SQLAlchemy column elements

        Raises:
            JSQLSyntaxError: If SELECT syntax is invalid
        """
        items: list[ColumnElement] = []

        for i, item_spec in enumerate(select_spec):
            path = f'{JSQLField.SELECT.value}[{i}]'

            # Wildcard: SELECT *
            if item_spec == '*':
                # Add all columns from the FROM clause
                if hasattr(from_clause, 'columns'):
                    items.extend(from_clause.columns)
                continue

            # Simple string field name
            if isinstance(item_spec, str):
                column = await self._resolve_column(item_spec, from_clause)
                items.append(column)
                continue

            # Dictionary specification
            if not isinstance(item_spec, dict):
                raise JSQLSyntaxError(f'Invalid SELECT item type: {type(item_spec)}', path)

            # Extract alias once
            alias_name = item_spec.get(JSQLField.ALIAS.value)

            # Field with optional alias
            if field_name := item_spec.get(JSQLField.FIELD.value):
                column = await self._resolve_column(field_name, from_clause)
                items.append(self._apply_alias(column, alias_name))
                continue

            # Function call
            if JSQLField.FUNC.value in item_spec:
                func_expr = await self._build_function(item_spec, path)
                items.append(self._apply_alias(func_expr, alias_name))
                continue

            # Expression
            if expr_spec := item_spec.get(JSQLField.EXPR.value):
                expr = await self._build_expression(expr_spec)
                items.append(self._apply_alias(expr, alias_name))
                continue

            # Window function
            if window_spec := item_spec.get(JSQLField.WINDOW_FUNC.value):
                window_expr = await self._build_window_function(window_spec, path)
                items.append(self._apply_alias(window_expr, alias_name))
                continue

            # Literal value
            if (value := item_spec.get(JSQLField.VALUE.value)) is not None:
                value_expr = literal(value)
                items.append(self._apply_alias(value_expr, alias_name))
                continue

            raise JSQLSyntaxError(
                f'SELECT item must have one of: {JSQLField.FIELD.value}, {JSQLField.FUNC.value}, '
                f'{JSQLField.EXPR.value}, {JSQLField.WINDOW_FUNC.value}, {JSQLField.VALUE.value}',
                path
            )

        return items

    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """
        Resolve column reference (e.g., 'users.id' or 'id').

        Args:
            field_spec: Field specification
            from_clause: FROM clause for column resolution (can be None)

        Returns:
            SQLAlchemy column

        Raises:
            JSQLSyntaxError: If column not found
        """
        # Try to resolve through AliasManager first
        try:
            return self.alias_manager.resolve_column(field_spec, from_clause)
        except JSQLSyntaxError:
            # If qualified column not found in aliases, try lazy loading
            if '.' in field_spec:
                table_name, column_name = field_spec.split('.', 1)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                    if column_name in table.columns:
                        return table.columns[column_name]
                except Exception as e:
                    raise JSQLSyntaxError(f'Column "{field_spec}" not found: {e}') from e
            
            # Re-raise original error if lazy loading also fails
            raise

    async def _process_joins_for_aliases(self, joins_spec: list[dict[str, Any]], base_table: Any) -> Any:
        """
        Process JOINs to register aliases and build joined FROM clause.

        Args:
            joins_spec: List of join specifications
            base_table: Base table for joins

        Returns:
            FROM clause with joins applied

        Raises:
            JSQLSyntaxError: If JOIN syntax is invalid
        """
        current_from = base_table

        for i, join_spec in enumerate(joins_spec):
            path = f'{JSQLField.JOINS.value}[{i}]'

            if JSQLField.TABLE.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.TABLE.value}" field', path)

            # Get join type (default INNER) and validate
            join_type_str = join_spec.get(JSQLField.TYPE.value, JoinType.INNER.value).upper()
            try:
                join_type = JoinType(join_type_str)
            except ValueError:
                raise JSQLSyntaxError(f'Invalid join type: {join_type_str}', path)

            # CROSS JOIN doesn't require ON clause
            if join_type != JoinType.CROSS and JSQLField.ON.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.ON.value}" field', path)

            # Get table
            table_name = join_spec[JSQLField.TABLE.value]

            # Check if it's a CTE or regular table
            if table_name in self.ctes:
                table = self.ctes[table_name]
            else:
                # Load table via metadata provider (lazy loading)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                except Exception as e:
                    raise JSQLSyntaxError(f'Table "{table_name}" not found: {e}', path) from e

            # Handle alias
            if alias_name := join_spec.get(JSQLField.ALIAS.value):
                table = table.alias(alias_name)
            else:
                alias_name = table_name

            # Register alias
            self._register_table_alias(alias_name, table)

            # Apply join based on type - use pattern matching
            match join_type:
                case JoinType.CROSS:
                    # CROSS JOIN - no ON clause
                    current_from = current_from.join(table, isouter=False, full=False)
                case JoinType.LEFT:
                    # LEFT OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True)
                case JoinType.RIGHT:
                    # RIGHT OUTER JOIN - reverse the order
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = table.join(current_from, on_condition, isouter=True)
                case JoinType.FULL:
                    # FULL OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True, full=True)
                case JoinType.INNER:
                    # INNER JOIN (default)
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=False)

        return current_from

    async def _handle_and(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle AND operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.AND.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return and_(*conditions)

    async def _handle_or(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle OR operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.OR.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return or_(*conditions)

    async def _handle_not(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle NOT operator."""
        if JSQLField.CONDITION.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.NOT.value} must have "{JSQLField.CONDITION.value}" field')
        condition = await self._build_condition(condition_spec[JSQLField.CONDITION.value])
        return not_(condition)

    async def _handle_comparison(self, op: JSQLOperator, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle comparison operators (=, !=, <, <=, >, >=)."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)

        # Use match-case for operator dispatch
        match op:
            case JSQLOperator.EQ:
                return left == right
            case JSQLOperator.NE:
                return left != right
            case JSQLOperator.LT:
                return left < right
            case JSQLOperator.LE:
                return left <= right
            case JSQLOperator.GT:
                return left > right
            case JSQLOperator.GE:
                return left >= right
            case _:
                raise JSQLSyntaxError(f'Unknown comparison operator: {op.value}')

    async def _handle_in(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IN operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        right_spec = condition_spec[JSQLField.RIGHT.value]

        # Subquery
        if isinstance(right_spec, dict) and JSQLField.SUBQUERY.value in right_spec:
            subquery = await self._build_query(right_spec[JSQLField.SUBQUERY.value])
            return left.in_(subquery)

        # List of values
        if isinstance(right_spec, list):
            return left.in_(right_spec)

        # Expression
        right = await self._build_expression(right_spec)
        return left.in_(right)

    async def _handle_exists(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle EXISTS operator."""
        if JSQLField.SUBQUERY.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.EXISTS.value} must have "{JSQLField.SUBQUERY.value}" field')
        subquery = await self._build_query(condition_spec[JSQLField.SUBQUERY.value])
        return exists(subquery)

    async def _handle_is_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.is_(None)

    async def _handle_is_not_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NOT NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NOT_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.isnot(None)

    async def _handle_like(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle LIKE operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)
        return left.like(right)

    async def _handle_between(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Handle BETWEEN operator.
        
        JSQL format: {"op": "BETWEEN", "expr": {...}, "low": {...}, "high": {...}}
        SQL equivalent: expr BETWEEN low AND high
        """
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "{JSQLField.EXPR.value}" field')
        if 'low' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "low" field')
        if 'high' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "high" field')

        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        # Extract type from expression to use for low/high bounds
        expr_type = getattr(expr, 'type', None) if hasattr(expr, 'type') else None
        low = await self._build_expression(condition_spec['low'], expected_type=expr_type)
        high = await self._build_expression(condition_spec['high'], expected_type=expr_type)
        
        return expr.between(low, high)

    async def _build_condition(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Build WHERE/HAVING condition.

        Args:
            condition_spec: Condition specification

        Returns:
            SQLAlchemy condition

        Raises:
            JSQLSyntaxError: If condition syntax is invalid
        """
        if JSQLField.OP.value not in condition_spec:
            raise JSQLSyntaxError(f'Condition must have "{JSQLField.OP.value}" field')

        op_str = condition_spec[JSQLField.OP.value].upper()

        # Try to convert to JSQLOperator enum
        try:
            op = JSQLOperator(op_str)
        except ValueError:
            raise JSQLSyntaxError(f'Unknown operator: {op_str}')

        # Use dispatch table for special operators
        if handler := self._condition_handlers.get(op):
            return await handler(condition_spec)

        # Handle comparison operators
        if op in COMPARISON_OPERATORS:
            return await self._handle_comparison(op, condition_spec)

        raise JSQLSyntaxError(f'Unsupported operator: {op_str}')

    async def _build_expression(
        self,
        expr_spec: JSQLExpression,
        expected_type: Any | None = None
    ) -> ColumnElement:
        """
        Build expression (arithmetic, logical, etc.).

        Args:
            expr_spec: Expression specification
            expected_type: Expected SQLAlchemy type for literals/parameters (optional)

        Returns:
            SQLAlchemy expression

        Raises:
            JSQLSyntaxError: If expression syntax is invalid
        """
        # Field reference
        if field_name := expr_spec.get(JSQLField.FIELD.value):
            return await self._resolve_column(field_name, None)

        # Literal value
        if (value := expr_spec.get(JSQLField.VALUE.value)) is not None:
            if expected_type is not None:
                # Use cast() for explicit type conversion to avoid VARCHAR casting issues
                return cast(literal(value), expected_type)
            return literal(value)

        # Parameter - use walrus operator
        if param_name := expr_spec.get(JSQLField.PARAM.value):
            if param_name not in self.params:
                raise JSQLSyntaxError(f'Parameter "{param_name}" not provided')
            # Use cast() for explicit type conversion when expected_type is available
            if expected_type is not None:
                return cast(literal(self.params[param_name]), expected_type)
            return literal(self.params[param_name])

        # Function call
        if JSQLField.FUNC.value in expr_spec:
            return await self._build_function(expr_spec)

        # Operator expression
        if JSQLField.OP.value in expr_spec:
            op_str = expr_spec[JSQLField.OP.value].upper()

            # Try to convert to JSQLOperator enum
            try:
                op = JSQLOperator(op_str)
            except ValueError:
                # Unknown operator - might be condition
                return await self._build_condition(expr_spec)

            # Binary arithmetic operators - use pattern matching
            if op in ARITHMETIC_OPERATORS:
                # Validate required fields
                if JSQLField.LEFT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
                if JSQLField.RIGHT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

                left = await self._build_expression(expr_spec[JSQLField.LEFT.value])
                right = await self._build_expression(expr_spec[JSQLField.RIGHT.value])

                match op:
                    case JSQLOperator.ADD:
                        return left + right
                    case JSQLOperator.SUB:
                        return left - right
                    case JSQLOperator.MUL:
                        return left * right
                    case JSQLOperator.DIV:
                        return left / right
                    case JSQLOperator.MOD:
                        return left % right

            # This might be a condition (for CASE WHEN)
            return await self._build_condition(expr_spec)

        # Subquery
        if subquery_spec := expr_spec.get(JSQLField.SUBQUERY.value):
            return await self._build_query(subquery_spec)

        raise JSQLSyntaxError(
            f'Invalid expression: must have {JSQLField.FIELD.value}, {JSQLField.VALUE.value}, '
            f'{JSQLField.PARAM.value}, {JSQLField.FUNC.value}, or {JSQLField.OP.value}'
        )

    async def _build_function(self, func_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build function call.

        Args:
            func_spec: Function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy function call

        Raises:
            JSQLSyntaxError: If function syntax is invalid
        """
        if JSQLField.FUNC.value not in func_spec:
            raise JSQLSyntaxError(f'Function must have "{JSQLField.FUNC.value}" field', path)

        func_name = func_spec[JSQLField.FUNC.value].upper()
        args_spec = func_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Handle DISTINCT
        if func_spec.get(JSQLField.DISTINCT.value, False) and args:
            args[0] = args[0].distinct()

        # Call function
        return sql_func(*args)

    async def _build_window_function(self, window_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build window function.

        Args:
            window_spec: Window function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy window function

        Raises:
            JSQLSyntaxError: If window function syntax is invalid
        """
        if JSQLField.FUNC.value not in window_spec:
            raise JSQLSyntaxError(f'Window function must have "{JSQLField.FUNC.value}" field', path)

        func_name = window_spec[JSQLField.FUNC.value].upper()
        args_spec = window_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Build function call
        func_call = sql_func(*args) if args else sql_func()

        # Build OVER clause - use walrus operator for partition_by
        partition_by = None
        if partition_by_spec := window_spec.get(JSQLField.PARTITION_BY.value):
            partition_by = []
            for part in partition_by_spec:
                if isinstance(part, dict) and JSQLField.FIELD.value in part:
                    partition_by.append(await self._resolve_column(part[JSQLField.FIELD.value], None))
                else:
                    raise JSQLSyntaxError(f'{JSQLField.PARTITION_BY.value} must contain field references', path)

        # Use walrus operator for order_by
        order_by = (
            await self._build_order_by(order_by_spec)
            if (order_by_spec := window_spec.get(JSQLField.ORDER_BY.value))
            else None
        )

        # Apply OVER
        return func_call.over(partition_by=partition_by, order_by=order_by)

    async def _build_group_by(self, group_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build GROUP BY clause.

        Args:
            group_by_spec: List of group by specifications

        Returns:
            List of SQLAlchemy expressions

        Raises:
            JSQLSyntaxError: If GROUP BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in group_by_spec:
            if isinstance(item, str):
                result.append(await self._resolve_column(item, None))
            elif isinstance(item, dict) and JSQLField.FIELD.value in item:
                result.append(await self._resolve_column(item[JSQLField.FIELD.value], None))
            else:
                raise JSQLSyntaxError(f'GROUP BY item must be field name or {{{JSQLField.FIELD.value}: ...}}')

        return result

    async def _resolve_field_or_alias(self, field_name: str) -> ColumnElement:
        """
        Resolve field name or SELECT alias.

        Args:
            field_name: Field name or alias

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If field/alias not found
        """
        # Check if it's a SELECT alias first
        if field_name in self.select_aliases:
            return self.select_aliases[field_name]
        # Otherwise resolve as column
        return await self._resolve_column(field_name, None)

    async def _build_order_by(self, order_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build ORDER BY clause.

        Args:
            order_by_spec: List of order by specifications

        Returns:
            List of SQLAlchemy order expressions

        Raises:
            JSQLSyntaxError: If ORDER BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in order_by_spec:
            if isinstance(item, str):
                column = await self._resolve_field_or_alias(item)
                result.append(column.asc())
            elif isinstance(item, dict):
                if JSQLField.FIELD.value not in item:
                    raise JSQLSyntaxError(f'ORDER BY item must have "{JSQLField.FIELD.value}"')

                field_name = item[JSQLField.FIELD.value]
                column = await self._resolve_field_or_alias(field_name)

                direction = item.get(JSQLField.DIRECTION.value, OrderDirection.ASC.value).lower()

                # Use pattern matching for direction
                match direction:
                    case OrderDirection.ASC.value:
                        result.append(column.asc())
                    case OrderDirection.DESC.value:
                        result.append(column.desc())
                    case _:
                        raise JSQLSyntaxError(f'Invalid ORDER BY direction: {direction}')
            else:
                raise JSQLSyntaxError(
                    f'ORDER BY item must be field name or '
                    f'{{{JSQLField.FIELD.value}: ..., {JSQLField.DIRECTION.value}: ...}}'
                )

        return result

```

```python
"""JSQL parser - converts JSQL (JSON-SQL) to SQLAlchemy queries."""

from collections.abc import Callable
from typing import Any

from sqlalchemy import Column
from sqlalchemy import Select
from sqlalchemy import and_
from sqlalchemy import bindparam
from sqlalchemy import cast
from sqlalchemy import exists
from sqlalchemy import func
from sqlalchemy import literal
from sqlalchemy import not_
from sqlalchemy import or_
from sqlalchemy import select
from sqlalchemy.sql import ColumnElement
from sqlalchemy.sql.expression import ClauseElement

from collections.abc import Mapping

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityName
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.jsql.alias_manager import AliasManager
from namerec.uma.jsql.constants import ARITHMETIC_OPERATORS
from namerec.uma.jsql.constants import COMPARISON_OPERATORS
from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import JSQLField
from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLExpression
from namerec.uma.jsql.types import JSQLQuery


class JSQLParser:
    """
    Parser for JSQL (JSON-SQL) queries.
    Converts JSQL dict to SQLAlchemy Select statement.
    """

    def __init__(self, namespace_configs: Mapping[str, NamespaceConfig]) -> None:
        """
        Initialize JSQL parser.

        Args:
            namespace_configs: Mapping of namespace names to configurations
        """
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}  # CTEs by name (for SQLAlchemy queries)
        self.alias_manager = AliasManager()  # Manages table/column aliases
        self.select_aliases: dict[str, ColumnElement] = {}  # SELECT column aliases

        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            JSQLOperator.NOT: self._handle_not,
            JSQLOperator.IN: self._handle_in,
            JSQLOperator.BETWEEN: self._handle_between,
            JSQLOperator.EXISTS: self._handle_exists,
            JSQLOperator.IS_NULL: self._handle_is_null,
            JSQLOperator.IS_NOT_NULL: self._handle_is_not_null,
            JSQLOperator.LIKE: self._handle_like,
        }

    async def parse(self, jsql: JSQLQuery, params: dict[str, Any] | None = None) -> tuple[Select, NamespaceConfig]:
        """
        Parse JSQL query into SQLAlchemy Select statement and namespace config.

        Args:
            jsql: JSQL query dictionary
            params: Query parameters

        Returns:
            Tuple of (SQLAlchemy Select statement, NamespaceConfig)

        Raises:
            JSQLSyntaxError: If JSQL syntax is invalid
            ValueError: If namespace not found or no default available
        """
        self.params = params or {}

        # Parse CTEs if present
        if with_spec := jsql.get(JSQLField.WITH.value):
            await self._parse_ctes(with_spec)

        # Build main query
        query = await self._build_query(jsql)

        # Determine namespace from parsed query
        namespace = self._determine_namespace_from_parsed_query(jsql)

        # Get namespace config (already validated in get_namespace_config)
        config = self.get_namespace_config(namespace)

        return query, config

    async def _parse_ctes(self, ctes: list[dict[str, Any]]) -> None:
        """
        Parse CTEs (Common Table Expressions).

        Args:
            ctes: List of CTE definitions

        Raises:
            JSQLSyntaxError: If CTE syntax is invalid
        """
        for i, cte_def in enumerate(ctes):
            path = f'{JSQLField.WITH.value}[{i}]'

            if JSQLField.NAME.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.NAME.value}" field', path)

            if JSQLField.QUERY.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.QUERY.value}" field', path)

            cte_name = cte_def[JSQLField.NAME.value]
            cte_query = await self._build_query(cte_def[JSQLField.QUERY.value])

            # Register CTE for later use
            cte = cte_query.cte(name=cte_name)
            self.ctes[cte_name] = cte
            
            # Register CTE in AliasManager for column resolution
            self.alias_manager.register_cte(cte_name, cte)

    async def _build_query(self, jsql: JSQLQuery) -> Select:
        """
        Build SELECT query from JSQL.

        Args:
            jsql: JSQL query dictionary

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If query syntax is invalid
        """
        if JSQLField.FROM.value not in jsql:
            raise JSQLSyntaxError(f'Query must have "{JSQLField.FROM.value}" field')

        # Get FROM clause
        from_clause = await self._build_from(jsql[JSQLField.FROM.value])

        # Process JOINs first to register all table aliases
        if joins_spec := jsql.get(JSQLField.JOINS.value):
            from_clause = await self._process_joins_for_aliases(joins_spec, from_clause)

        # Build SELECT clause (now all aliases are registered)
        select_items = await self._build_select(
            jsql.get(JSQLField.SELECT.value, ['*']), from_clause
        )

        # Start building query
        query = select(*select_items).select_from(from_clause)

        # Add WHERE
        if where_spec := jsql.get(JSQLField.WHERE.value):
            where_clause = await self._build_condition(where_spec)
            query = query.where(where_clause)

        # Add GROUP BY
        if group_by_spec := jsql.get(JSQLField.GROUP_BY.value):
            group_by_clauses = await self._build_group_by(group_by_spec)
            query = query.group_by(*group_by_clauses)

        # Add HAVING
        if having_spec := jsql.get(JSQLField.HAVING.value):
            having_clause = await self._build_condition(having_spec)
            query = query.having(having_clause)

        # Add ORDER BY
        if order_by_spec := jsql.get(JSQLField.ORDER_BY.value):
            order_by_clauses = await self._build_order_by(order_by_spec)
            query = query.order_by(*order_by_clauses)

        # Add LIMIT (check 'is not None' to allow 0)
        if (limit_value := jsql.get(JSQLField.LIMIT.value)) is not None:
            query = query.limit(limit_value)

        # Add OFFSET (check 'is not None' to allow 0)
        if (offset_value := jsql.get(JSQLField.OFFSET.value)) is not None:
            query = query.offset(offset_value)

        return query

    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """
        Register table alias and index its columns for fast lookup.

        Args:
            alias_name: Primary alias name
            table: Table object
            additional_aliases: Additional alias names for the same table
        """
        # Delegate to AliasManager
        self.alias_manager.register_table(alias_name, table, *additional_aliases)

    async def _build_from(self, from_spec: str) -> Any:
        """
        Build FROM clause.

        Args:
            from_spec: Table name (string)

        Returns:
            SQLAlchemy table or CTE reference

        Raises:
            JSQLSyntaxError: If FROM syntax is invalid or table not found
        """
        if not isinstance(from_spec, str):
            raise JSQLSyntaxError(
                f'FROM clause must be a string (table name), got {type(from_spec).__name__}. '
                'Subqueries and complex FROM specifications are not yet supported.'
            )

        # Check if it's a CTE
        if from_spec in self.ctes:
            cte = self.ctes[from_spec]
            self._register_table_alias(from_spec, cte)
            return cte

        # Regular table
        entity_name = parse_entity_name(from_spec)

        # Note: Table should be preloaded in executor before parsing
        # This ensures lazy loading happens before synchronous parsing
        table = await self._get_table_async(entity_name)

        # Register both by entity name and by from_spec (they might differ with namespace)
        self._register_table_alias(
            entity_name.entity,
            table,
            *([] if from_spec == entity_name.entity else [from_spec])
        )
        return table

    async def _get_table_async(self, entity_name: EntityName) -> Any:
        """
        Get table via metadata provider (lazy loading).

        Args:
            entity_name: Entity name

        Returns:
            SQLAlchemy Table object

        Raises:
            JSQLSyntaxError: If table not found
        """
        try:
            return await get_table(self.context, entity_name)
        except Exception as e:
            raise JSQLSyntaxError(f'Table "{entity_name}" not found: {e}') from e

    def _apply_alias(self, expression: ColumnElement, alias_name: str | None) -> ColumnElement:
        """
        Apply alias to expression and register it.

        Args:
            expression: SQLAlchemy expression
            alias_name: Alias name (if provided)

        Returns:
            Expression with alias applied (if provided)
        """
        if alias_name:
            labeled_expr = expression.label(alias_name)
            # Store alias for ORDER BY resolution
            self.select_aliases[alias_name] = labeled_expr
            return labeled_expr
        return expression

    async def _build_select(self, select_spec: list[str | dict[str, Any]], from_clause: Any) -> list[ColumnElement]:
        """
        Build SELECT clause items.

        Args:
            select_spec: List of select specifications
            from_clause: FROM clause for column resolution

        Returns:
            List of SQLAlchemy column elements

        Raises:
            JSQLSyntaxError: If SELECT syntax is invalid
        """
        items: list[ColumnElement] = []

        for i, item_spec in enumerate(select_spec):
            path = f'{JSQLField.SELECT.value}[{i}]'

            # Wildcard: SELECT *
            if item_spec == '*':
                # Add all columns from the FROM clause
                if hasattr(from_clause, 'columns'):
                    items.extend(from_clause.columns)
                continue

            # Simple string field name
            if isinstance(item_spec, str):
                column = await self._resolve_column(item_spec, from_clause)
                items.append(column)
                continue

            # Dictionary specification
            if not isinstance(item_spec, dict):
                raise JSQLSyntaxError(f'Invalid SELECT item type: {type(item_spec)}', path)

            # Extract alias once
            alias_name = item_spec.get(JSQLField.ALIAS.value)

            # Field with optional alias
            if field_name := item_spec.get(JSQLField.FIELD.value):
                column = await self._resolve_column(field_name, from_clause)
                items.append(self._apply_alias(column, alias_name))
                continue

            # Function call
            if JSQLField.FUNC.value in item_spec:
                func_expr = await self._build_function(item_spec, path)
                items.append(self._apply_alias(func_expr, alias_name))
                continue

            # Expression
            if expr_spec := item_spec.get(JSQLField.EXPR.value):
                expr = await self._build_expression(expr_spec)
                items.append(self._apply_alias(expr, alias_name))
                continue

            # Window function
            if window_spec := item_spec.get(JSQLField.WINDOW_FUNC.value):
                window_expr = await self._build_window_function(window_spec, path)
                items.append(self._apply_alias(window_expr, alias_name))
                continue

            # Literal value
            if (value := item_spec.get(JSQLField.VALUE.value)) is not None:
                value_expr = literal(value)
                items.append(self._apply_alias(value_expr, alias_name))
                continue

            raise JSQLSyntaxError(
                f'SELECT item must have one of: {JSQLField.FIELD.value}, {JSQLField.FUNC.value}, '
                f'{JSQLField.EXPR.value}, {JSQLField.WINDOW_FUNC.value}, {JSQLField.VALUE.value}',
                path
            )

        return items

    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """
        Resolve column reference (e.g., 'users.id' or 'id').

        Args:
            field_spec: Field specification
            from_clause: FROM clause for column resolution (can be None)

        Returns:
            SQLAlchemy column

        Raises:
            JSQLSyntaxError: If column not found
        """
        # Try to resolve through AliasManager first
        try:
            return self.alias_manager.resolve_column(field_spec, from_clause)
        except JSQLSyntaxError:
            # If qualified column not found in aliases, try lazy loading
            if '.' in field_spec:
                table_name, column_name = field_spec.split('.', 1)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                    if column_name in table.columns:
                        return table.columns[column_name]
                except Exception as e:
                    raise JSQLSyntaxError(f'Column "{field_spec}" not found: {e}') from e
            
            # Re-raise original error if lazy loading also fails
            raise

    async def _process_joins_for_aliases(self, joins_spec: list[dict[str, Any]], base_table: Any) -> Any:
        """
        Process JOINs to register aliases and build joined FROM clause.

        Args:
            joins_spec: List of join specifications
            base_table: Base table for joins

        Returns:
            FROM clause with joins applied

        Raises:
            JSQLSyntaxError: If JOIN syntax is invalid
        """
        current_from = base_table

        for i, join_spec in enumerate(joins_spec):
            path = f'{JSQLField.JOINS.value}[{i}]'

            if JSQLField.TABLE.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.TABLE.value}" field', path)

            # Get join type (default INNER) and validate
            join_type_str = join_spec.get(JSQLField.TYPE.value, JoinType.INNER.value).upper()
            try:
                join_type = JoinType(join_type_str)
            except ValueError:
                raise JSQLSyntaxError(f'Invalid join type: {join_type_str}', path)

            # CROSS JOIN doesn't require ON clause
            if join_type != JoinType.CROSS and JSQLField.ON.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.ON.value}" field', path)

            # Get table
            table_name = join_spec[JSQLField.TABLE.value]

            # Check if it's a CTE or regular table
            if table_name in self.ctes:
                table = self.ctes[table_name]
            else:
                # Load table via metadata provider (lazy loading)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                except Exception as e:
                    raise JSQLSyntaxError(f'Table "{table_name}" not found: {e}', path) from e

            # Handle alias
            if alias_name := join_spec.get(JSQLField.ALIAS.value):
                table = table.alias(alias_name)
            else:
                alias_name = table_name

            # Register alias
            self._register_table_alias(alias_name, table)

            # Apply join based on type - use pattern matching
            match join_type:
                case JoinType.CROSS:
                    # CROSS JOIN - no ON clause
                    current_from = current_from.join(table, isouter=False, full=False)
                case JoinType.LEFT:
                    # LEFT OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True)
                case JoinType.RIGHT:
                    # RIGHT OUTER JOIN - reverse the order
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = table.join(current_from, on_condition, isouter=True)
                case JoinType.FULL:
                    # FULL OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True, full=True)
                case JoinType.INNER:
                    # INNER JOIN (default)
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=False)

        return current_from

    async def _handle_and(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle AND operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.AND.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return and_(*conditions)

    async def _handle_or(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle OR operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.OR.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return or_(*conditions)

    async def _handle_not(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle NOT operator."""
        if JSQLField.CONDITION.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.NOT.value} must have "{JSQLField.CONDITION.value}" field')
        condition = await self._build_condition(condition_spec[JSQLField.CONDITION.value])
        return not_(condition)

    async def _handle_comparison(self, op: JSQLOperator, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle comparison operators (=, !=, <, <=, >, >=)."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)

        # Use match-case for operator dispatch
        match op:
            case JSQLOperator.EQ:
                return left == right
            case JSQLOperator.NE:
                return left != right
            case JSQLOperator.LT:
                return left < right
            case JSQLOperator.LE:
                return left <= right
            case JSQLOperator.GT:
                return left > right
            case JSQLOperator.GE:
                return left >= right
            case _:
                raise JSQLSyntaxError(f'Unknown comparison operator: {op.value}')

    async def _handle_in(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IN operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        right_spec = condition_spec[JSQLField.RIGHT.value]

        # Subquery
        if isinstance(right_spec, dict) and JSQLField.SUBQUERY.value in right_spec:
            subquery = await self._build_query(right_spec[JSQLField.SUBQUERY.value])
            return left.in_(subquery)

        # List of values
        if isinstance(right_spec, list):
            return left.in_(right_spec)

        # Expression
        right = await self._build_expression(right_spec)
        return left.in_(right)

    async def _handle_exists(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle EXISTS operator."""
        if JSQLField.SUBQUERY.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.EXISTS.value} must have "{JSQLField.SUBQUERY.value}" field')
        subquery = await self._build_query(condition_spec[JSQLField.SUBQUERY.value])
        return exists(subquery)

    async def _handle_is_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.is_(None)

    async def _handle_is_not_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NOT NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NOT_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.isnot(None)

    async def _handle_like(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle LIKE operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)
        return left.like(right)

    async def _handle_between(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Handle BETWEEN operator.
        
        JSQL format: {"op": "BETWEEN", "expr": {...}, "low": {...}, "high": {...}}
        SQL equivalent: expr BETWEEN low AND high
        """
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "{JSQLField.EXPR.value}" field')
        if 'low' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "low" field')
        if 'high' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "high" field')

        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        # Extract type from expression to use for low/high bounds
        expr_type = getattr(expr, 'type', None) if hasattr(expr, 'type') else None
        low = await self._build_expression(condition_spec['low'], expected_type=expr_type)
        high = await self._build_expression(condition_spec['high'], expected_type=expr_type)
        
        return expr.between(low, high)

    async def _build_condition(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Build WHERE/HAVING condition.

        Args:
            condition_spec: Condition specification

        Returns:
            SQLAlchemy condition

        Raises:
            JSQLSyntaxError: If condition syntax is invalid
        """
        if JSQLField.OP.value not in condition_spec:
            raise JSQLSyntaxError(f'Condition must have "{JSQLField.OP.value}" field')

        op_str = condition_spec[JSQLField.OP.value].upper()

        # Try to convert to JSQLOperator enum
        try:
            op = JSQLOperator(op_str)
        except ValueError:
            raise JSQLSyntaxError(f'Unknown operator: {op_str}')

        # Use dispatch table for special operators
        if handler := self._condition_handlers.get(op):
            return await handler(condition_spec)

        # Handle comparison operators
        if op in COMPARISON_OPERATORS:
            return await self._handle_comparison(op, condition_spec)

        raise JSQLSyntaxError(f'Unsupported operator: {op_str}')

    async def _build_expression(
        self,
        expr_spec: JSQLExpression,
        expected_type: Any | None = None
    ) -> ColumnElement:
        """
        Build expression (arithmetic, logical, etc.).

        Args:
            expr_spec: Expression specification
            expected_type: Expected SQLAlchemy type for literals/parameters (optional)

        Returns:
            SQLAlchemy expression

        Raises:
            JSQLSyntaxError: If expression syntax is invalid
        """
        # Field reference
        if field_name := expr_spec.get(JSQLField.FIELD.value):
            return await self._resolve_column(field_name, None)

        # Literal value
        if (value := expr_spec.get(JSQLField.VALUE.value)) is not None:
            if expected_type is not None:
                # Use cast() for explicit type conversion to avoid VARCHAR casting issues
                return cast(literal(value), expected_type)
            return literal(value)

        # Parameter - use walrus operator
        if param_name := expr_spec.get(JSQLField.PARAM.value):
            if param_name not in self.params:
                raise JSQLSyntaxError(f'Parameter "{param_name}" not provided')
            # Use cast() for explicit type conversion when expected_type is available
            if expected_type is not None:
                return cast(literal(self.params[param_name]), expected_type)
            return literal(self.params[param_name])

        # Function call
        if JSQLField.FUNC.value in expr_spec:
            return await self._build_function(expr_spec)

        # Operator expression
        if JSQLField.OP.value in expr_spec:
            op_str = expr_spec[JSQLField.OP.value].upper()

            # Try to convert to JSQLOperator enum
            try:
                op = JSQLOperator(op_str)
            except ValueError:
                # Unknown operator - might be condition
                return await self._build_condition(expr_spec)

            # Binary arithmetic operators - use pattern matching
            if op in ARITHMETIC_OPERATORS:
                # Validate required fields
                if JSQLField.LEFT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
                if JSQLField.RIGHT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

                left = await self._build_expression(expr_spec[JSQLField.LEFT.value])
                right = await self._build_expression(expr_spec[JSQLField.RIGHT.value])

                match op:
                    case JSQLOperator.ADD:
                        return left + right
                    case JSQLOperator.SUB:
                        return left - right
                    case JSQLOperator.MUL:
                        return left * right
                    case JSQLOperator.DIV:
                        return left / right
                    case JSQLOperator.MOD:
                        return left % right

            # This might be a condition (for CASE WHEN)
            return await self._build_condition(expr_spec)

        # Subquery
        if subquery_spec := expr_spec.get(JSQLField.SUBQUERY.value):
            return await self._build_query(subquery_spec)

        raise JSQLSyntaxError(
            f'Invalid expression: must have {JSQLField.FIELD.value}, {JSQLField.VALUE.value}, '
            f'{JSQLField.PARAM.value}, {JSQLField.FUNC.value}, or {JSQLField.OP.value}'
        )

    async def _build_function(self, func_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build function call.

        Args:
            func_spec: Function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy function call

        Raises:
            JSQLSyntaxError: If function syntax is invalid
        """
        if JSQLField.FUNC.value not in func_spec:
            raise JSQLSyntaxError(f'Function must have "{JSQLField.FUNC.value}" field', path)

        func_name = func_spec[JSQLField.FUNC.value].upper()
        args_spec = func_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Handle DISTINCT
        if func_spec.get(JSQLField.DISTINCT.value, False) and args:
            args[0] = args[0].distinct()

        # Call function
        return sql_func(*args)

    async def _build_window_function(self, window_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build window function.

        Args:
            window_spec: Window function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy window function

        Raises:
            JSQLSyntaxError: If window function syntax is invalid
        """
        if JSQLField.FUNC.value not in window_spec:
            raise JSQLSyntaxError(f'Window function must have "{JSQLField.FUNC.value}" field', path)

        func_name = window_spec[JSQLField.FUNC.value].upper()
        args_spec = window_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Build function call
        func_call = sql_func(*args) if args else sql_func()

        # Build OVER clause - use walrus operator for partition_by
        partition_by = None
        if partition_by_spec := window_spec.get(JSQLField.PARTITION_BY.value):
            partition_by = []
            for part in partition_by_spec:
                if isinstance(part, dict) and JSQLField.FIELD.value in part:
                    partition_by.append(await self._resolve_column(part[JSQLField.FIELD.value], None))
                else:
                    raise JSQLSyntaxError(f'{JSQLField.PARTITION_BY.value} must contain field references', path)

        # Use walrus operator for order_by
        order_by = (
            await self._build_order_by(order_by_spec)
            if (order_by_spec := window_spec.get(JSQLField.ORDER_BY.value))
            else None
        )

        # Apply OVER
        return func_call.over(partition_by=partition_by, order_by=order_by)

    async def _build_group_by(self, group_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build GROUP BY clause.

        Args:
            group_by_spec: List of group by specifications

        Returns:
            List of SQLAlchemy expressions

        Raises:
            JSQLSyntaxError: If GROUP BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in group_by_spec:
            if isinstance(item, str):
                result.append(await self._resolve_column(item, None))
            elif isinstance(item, dict) and JSQLField.FIELD.value in item:
                result.append(await self._resolve_column(item[JSQLField.FIELD.value], None))
            else:
                raise JSQLSyntaxError(f'GROUP BY item must be field name or {{{JSQLField.FIELD.value}: ...}}')

        return result

    async def _resolve_field_or_alias(self, field_name: str) -> ColumnElement:
        """
        Resolve field name or SELECT alias.

        Args:
            field_name: Field name or alias

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If field/alias not found
        """
        # Check if it's a SELECT alias first
        if field_name in self.select_aliases:
            return self.select_aliases[field_name]
        # Otherwise resolve as column
        return await self._resolve_column(field_name, None)

    async def _build_order_by(self, order_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build ORDER BY clause.

        Args:
            order_by_spec: List of order by specifications

        Returns:
            List of SQLAlchemy order expressions

        Raises:
            JSQLSyntaxError: If ORDER BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in order_by_spec:
            if isinstance(item, str):
                column = await self._resolve_field_or_alias(item)
                result.append(column.asc())
            elif isinstance(item, dict):
                if JSQLField.FIELD.value not in item:
                    raise JSQLSyntaxError(f'ORDER BY item must have "{JSQLField.FIELD.value}"')

                field_name = item[JSQLField.FIELD.value]
                column = await self._resolve_field_or_alias(field_name)

                direction = item.get(JSQLField.DIRECTION.value, OrderDirection.ASC.value).lower()

                # Use pattern matching for direction
                match direction:
                    case OrderDirection.ASC.value:
                        result.append(column.asc())
                    case OrderDirection.DESC.value:
                        result.append(column.desc())
                    case _:
                        raise JSQLSyntaxError(f'Invalid ORDER BY direction: {direction}')
            else:
                raise JSQLSyntaxError(
                    f'ORDER BY item must be field name or '
                    f'{{{JSQLField.FIELD.value}: ..., {JSQLField.DIRECTION.value}: ...}}'
                )

        return result

```

```python
"""JSQL parser - converts JSQL (JSON-SQL) to SQLAlchemy queries."""

from collections.abc import Callable
from typing import Any

from sqlalchemy import Column
from sqlalchemy import Select
from sqlalchemy import and_
from sqlalchemy import bindparam
from sqlalchemy import cast
from sqlalchemy import exists
from sqlalchemy import func
from sqlalchemy import literal
from sqlalchemy import not_
from sqlalchemy import or_
from sqlalchemy import select
from sqlalchemy.sql import ColumnElement
from sqlalchemy.sql.expression import ClauseElement

from collections.abc import Mapping

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityName
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.jsql.alias_manager import AliasManager
from namerec.uma.jsql.constants import ARITHMETIC_OPERATORS
from namerec.uma.jsql.constants import COMPARISON_OPERATORS
from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import JSQLField
from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLExpression
from namerec.uma.jsql.types import JSQLQuery


class JSQLParser:
    """
    Parser for JSQL (JSON-SQL) queries.
    Converts JSQL dict to SQLAlchemy Select statement.
    """

    def __init__(self, namespace_configs: Mapping[str, NamespaceConfig]) -> None:
        """
        Initialize JSQL parser.

        Args:
            namespace_configs: Mapping of namespace names to configurations
        """
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}  # CTEs by name (for SQLAlchemy queries)
        self.alias_manager = AliasManager()  # Manages table/column aliases
        self.select_aliases: dict[str, ColumnElement] = {}  # SELECT column aliases

        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            JSQLOperator.NOT: self._handle_not,
            JSQLOperator.IN: self._handle_in,
            JSQLOperator.BETWEEN: self._handle_between,
            JSQLOperator.EXISTS: self._handle_exists,
            JSQLOperator.IS_NULL: self._handle_is_null,
            JSQLOperator.IS_NOT_NULL: self._handle_is_not_null,
            JSQLOperator.LIKE: self._handle_like,
        }

    async def parse(self, jsql: JSQLQuery, params: dict[str, Any] | None = None) -> tuple[Select, NamespaceConfig]:
        """
        Parse JSQL query into SQLAlchemy Select statement and namespace config.

        Args:
            jsql: JSQL query dictionary
            params: Query parameters

        Returns:
            Tuple of (SQLAlchemy Select statement, NamespaceConfig)

        Raises:
            JSQLSyntaxError: If JSQL syntax is invalid
            ValueError: If namespace not found or no default available
        """
        self.params = params or {}

        # Parse CTEs if present
        if with_spec := jsql.get(JSQLField.WITH.value):
            await self._parse_ctes(with_spec)

        # Build main query
        query = await self._build_query(jsql)

        # Determine namespace from parsed query
        namespace = self._determine_namespace_from_parsed_query(jsql)

        # Get namespace config (already validated in get_namespace_config)
        config = self.get_namespace_config(namespace)

        return query, config

    async def _parse_ctes(self, ctes: list[dict[str, Any]]) -> None:
        """
        Parse CTEs (Common Table Expressions).

        Args:
            ctes: List of CTE definitions

        Raises:
            JSQLSyntaxError: If CTE syntax is invalid
        """
        for i, cte_def in enumerate(ctes):
            path = f'{JSQLField.WITH.value}[{i}]'

            if JSQLField.NAME.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.NAME.value}" field', path)

            if JSQLField.QUERY.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.QUERY.value}" field', path)

            cte_name = cte_def[JSQLField.NAME.value]
            cte_query = await self._build_query(cte_def[JSQLField.QUERY.value])

            # Register CTE for later use
            cte = cte_query.cte(name=cte_name)
            self.ctes[cte_name] = cte
            
            # Register CTE in AliasManager for column resolution
            self.alias_manager.register_cte(cte_name, cte)

    async def _build_query(self, jsql: JSQLQuery) -> Select:
        """
        Build SELECT query from JSQL.

        Args:
            jsql: JSQL query dictionary

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If query syntax is invalid
        """
        if JSQLField.FROM.value not in jsql:
            raise JSQLSyntaxError(f'Query must have "{JSQLField.FROM.value}" field')

        # Get FROM clause
        from_clause = await self._build_from(jsql[JSQLField.FROM.value])

        # Process JOINs first to register all table aliases
        if joins_spec := jsql.get(JSQLField.JOINS.value):
            from_clause = await self._process_joins_for_aliases(joins_spec, from_clause)

        # Build SELECT clause (now all aliases are registered)
        select_items = await self._build_select(
            jsql.get(JSQLField.SELECT.value, ['*']), from_clause
        )

        # Start building query
        query = select(*select_items).select_from(from_clause)

        # Add WHERE
        if where_spec := jsql.get(JSQLField.WHERE.value):
            where_clause = await self._build_condition(where_spec)
            query = query.where(where_clause)

        # Add GROUP BY
        if group_by_spec := jsql.get(JSQLField.GROUP_BY.value):
            group_by_clauses = await self._build_group_by(group_by_spec)
            query = query.group_by(*group_by_clauses)

        # Add HAVING
        if having_spec := jsql.get(JSQLField.HAVING.value):
            having_clause = await self._build_condition(having_spec)
            query = query.having(having_clause)

        # Add ORDER BY
        if order_by_spec := jsql.get(JSQLField.ORDER_BY.value):
            order_by_clauses = await self._build_order_by(order_by_spec)
            query = query.order_by(*order_by_clauses)

        # Add LIMIT (check 'is not None' to allow 0)
        if (limit_value := jsql.get(JSQLField.LIMIT.value)) is not None:
            query = query.limit(limit_value)

        # Add OFFSET (check 'is not None' to allow 0)
        if (offset_value := jsql.get(JSQLField.OFFSET.value)) is not None:
            query = query.offset(offset_value)

        return query

    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """
        Register table alias and index its columns for fast lookup.

        Args:
            alias_name: Primary alias name
            table: Table object
            additional_aliases: Additional alias names for the same table
        """
        # Delegate to AliasManager
        self.alias_manager.register_table(alias_name, table, *additional_aliases)

    async def _build_from(self, from_spec: str) -> Any:
        """
        Build FROM clause.

        Args:
            from_spec: Table name (string)

        Returns:
            SQLAlchemy table or CTE reference

        Raises:
            JSQLSyntaxError: If FROM syntax is invalid or table not found
        """
        if not isinstance(from_spec, str):
            raise JSQLSyntaxError(
                f'FROM clause must be a string (table name), got {type(from_spec).__name__}. '
                'Subqueries and complex FROM specifications are not yet supported.'
            )

        # Check if it's a CTE
        if from_spec in self.ctes:
            cte = self.ctes[from_spec]
            self._register_table_alias(from_spec, cte)
            return cte

        # Regular table
        entity_name = parse_entity_name(from_spec)

        # Note: Table should be preloaded in executor before parsing
        # This ensures lazy loading happens before synchronous parsing
        table = await self._get_table_async(entity_name)

        # Register both by entity name and by from_spec (they might differ with namespace)
        self._register_table_alias(
            entity_name.entity,
            table,
            *([] if from_spec == entity_name.entity else [from_spec])
        )
        return table

    def get_namespace_config(self, namespace: str) -> NamespaceConfig:
        """
        Get namespace config by name.

        Args:
            namespace: Namespace name

        Returns:
            NamespaceConfig for the namespace

        Raises:
            ValueError: If namespace not found
        """
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')

        return self.namespace_configs[namespace]

    def _determine_namespace_from_parsed_query(self, jsql: dict) -> str:
        """
        Determine namespace from parsed query.

        Namespace comes from:
        - FROM clause entity name
        - Or default namespace if single namespace configured

        Args:
            jsql: JSQL query dictionary

        Returns:
            Namespace name

        Raises:
            ValueError: If namespace cannot be determined
        """
        from_entity = jsql.get('from')
        if not from_entity:
            # No FROM - use default
            if len(self.namespace_configs) == 1:
                return next(iter(self.namespace_configs.keys()))
            raise ValueError("JSQL must contain 'from' field")

        entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')

        # Use entity namespace or default
        if entity.namespace:
            return entity.namespace

        if len(self.namespace_configs) == 1:
            return next(iter(self.namespace_configs.keys()))

        raise ValueError(
            'Namespace not specified and no default available. '
            'Use explicit namespace or configure single namespace.'
        )

    async def _get_table_async(self, entity_name: EntityName) -> Table:
        """
        Get table from metadata provider.

        Uses entity_name.namespace to determine which metadata provider to use.

        Args:
            entity_name: Entity name

        Returns:
            SQLAlchemy Table object

        Raises:
            JSQLSyntaxError: If table not found
        """
        namespace = entity_name.namespace
        if not namespace:
            # Resolve default namespace
            if len(self.namespace_configs) == 1:
                namespace = next(iter(self.namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )

        config = self.get_namespace_config(namespace)

        try:
            return await config.metadata_provider.get_table(
                entity_name,
                config.engine,
                None,
            )
        except Exception as e:
            raise JSQLSyntaxError(f'Table "{entity_name}" not found: {e}') from e

    def _apply_alias(self, expression: ColumnElement, alias_name: str | None) -> ColumnElement:
        """
        Apply alias to expression and register it.

        Args:
            expression: SQLAlchemy expression
            alias_name: Alias name (if provided)

        Returns:
            Expression with alias applied (if provided)
        """
        if alias_name:
            labeled_expr = expression.label(alias_name)
            # Store alias for ORDER BY resolution
            self.select_aliases[alias_name] = labeled_expr
            return labeled_expr
        return expression

    async def _build_select(self, select_spec: list[str | dict[str, Any]], from_clause: Any) -> list[ColumnElement]:
        """
        Build SELECT clause items.

        Args:
            select_spec: List of select specifications
            from_clause: FROM clause for column resolution

        Returns:
            List of SQLAlchemy column elements

        Raises:
            JSQLSyntaxError: If SELECT syntax is invalid
        """
        items: list[ColumnElement] = []

        for i, item_spec in enumerate(select_spec):
            path = f'{JSQLField.SELECT.value}[{i}]'

            # Wildcard: SELECT *
            if item_spec == '*':
                # Add all columns from the FROM clause
                if hasattr(from_clause, 'columns'):
                    items.extend(from_clause.columns)
                continue

            # Simple string field name
            if isinstance(item_spec, str):
                column = await self._resolve_column(item_spec, from_clause)
                items.append(column)
                continue

            # Dictionary specification
            if not isinstance(item_spec, dict):
                raise JSQLSyntaxError(f'Invalid SELECT item type: {type(item_spec)}', path)

            # Extract alias once
            alias_name = item_spec.get(JSQLField.ALIAS.value)

            # Field with optional alias
            if field_name := item_spec.get(JSQLField.FIELD.value):
                column = await self._resolve_column(field_name, from_clause)
                items.append(self._apply_alias(column, alias_name))
                continue

            # Function call
            if JSQLField.FUNC.value in item_spec:
                func_expr = await self._build_function(item_spec, path)
                items.append(self._apply_alias(func_expr, alias_name))
                continue

            # Expression
            if expr_spec := item_spec.get(JSQLField.EXPR.value):
                expr = await self._build_expression(expr_spec)
                items.append(self._apply_alias(expr, alias_name))
                continue

            # Window function
            if window_spec := item_spec.get(JSQLField.WINDOW_FUNC.value):
                window_expr = await self._build_window_function(window_spec, path)
                items.append(self._apply_alias(window_expr, alias_name))
                continue

            # Literal value
            if (value := item_spec.get(JSQLField.VALUE.value)) is not None:
                value_expr = literal(value)
                items.append(self._apply_alias(value_expr, alias_name))
                continue

            raise JSQLSyntaxError(
                f'SELECT item must have one of: {JSQLField.FIELD.value}, {JSQLField.FUNC.value}, '
                f'{JSQLField.EXPR.value}, {JSQLField.WINDOW_FUNC.value}, {JSQLField.VALUE.value}',
                path
            )

        return items

    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """
        Resolve column reference (e.g., 'users.id' or 'id').

        Args:
            field_spec: Field specification
            from_clause: FROM clause for column resolution (can be None)

        Returns:
            SQLAlchemy column

        Raises:
            JSQLSyntaxError: If column not found
        """
        # Try to resolve through AliasManager first
        try:
            return self.alias_manager.resolve_column(field_spec, from_clause)
        except JSQLSyntaxError:
            # If qualified column not found in aliases, try lazy loading
            if '.' in field_spec:
                table_name, column_name = field_spec.split('.', 1)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                    if column_name in table.columns:
                        return table.columns[column_name]
                except Exception as e:
                    raise JSQLSyntaxError(f'Column "{field_spec}" not found: {e}') from e
            
            # Re-raise original error if lazy loading also fails
            raise

    async def _process_joins_for_aliases(self, joins_spec: list[dict[str, Any]], base_table: Any) -> Any:
        """
        Process JOINs to register aliases and build joined FROM clause.

        Args:
            joins_spec: List of join specifications
            base_table: Base table for joins

        Returns:
            FROM clause with joins applied

        Raises:
            JSQLSyntaxError: If JOIN syntax is invalid
        """
        current_from = base_table

        for i, join_spec in enumerate(joins_spec):
            path = f'{JSQLField.JOINS.value}[{i}]'

            if JSQLField.TABLE.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.TABLE.value}" field', path)

            # Get join type (default INNER) and validate
            join_type_str = join_spec.get(JSQLField.TYPE.value, JoinType.INNER.value).upper()
            try:
                join_type = JoinType(join_type_str)
            except ValueError:
                raise JSQLSyntaxError(f'Invalid join type: {join_type_str}', path)

            # CROSS JOIN doesn't require ON clause
            if join_type != JoinType.CROSS and JSQLField.ON.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.ON.value}" field', path)

            # Get table
            table_name = join_spec[JSQLField.TABLE.value]

            # Check if it's a CTE or regular table
            if table_name in self.ctes:
                table = self.ctes[table_name]
            else:
                # Load table via metadata provider (lazy loading)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                except Exception as e:
                    raise JSQLSyntaxError(f'Table "{table_name}" not found: {e}', path) from e

            # Handle alias
            if alias_name := join_spec.get(JSQLField.ALIAS.value):
                table = table.alias(alias_name)
            else:
                alias_name = table_name

            # Register alias
            self._register_table_alias(alias_name, table)

            # Apply join based on type - use pattern matching
            match join_type:
                case JoinType.CROSS:
                    # CROSS JOIN - no ON clause
                    current_from = current_from.join(table, isouter=False, full=False)
                case JoinType.LEFT:
                    # LEFT OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True)
                case JoinType.RIGHT:
                    # RIGHT OUTER JOIN - reverse the order
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = table.join(current_from, on_condition, isouter=True)
                case JoinType.FULL:
                    # FULL OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True, full=True)
                case JoinType.INNER:
                    # INNER JOIN (default)
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=False)

        return current_from

    async def _handle_and(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle AND operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.AND.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return and_(*conditions)

    async def _handle_or(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle OR operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.OR.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return or_(*conditions)

    async def _handle_not(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle NOT operator."""
        if JSQLField.CONDITION.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.NOT.value} must have "{JSQLField.CONDITION.value}" field')
        condition = await self._build_condition(condition_spec[JSQLField.CONDITION.value])
        return not_(condition)

    async def _handle_comparison(self, op: JSQLOperator, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle comparison operators (=, !=, <, <=, >, >=)."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)

        # Use match-case for operator dispatch
        match op:
            case JSQLOperator.EQ:
                return left == right
            case JSQLOperator.NE:
                return left != right
            case JSQLOperator.LT:
                return left < right
            case JSQLOperator.LE:
                return left <= right
            case JSQLOperator.GT:
                return left > right
            case JSQLOperator.GE:
                return left >= right
            case _:
                raise JSQLSyntaxError(f'Unknown comparison operator: {op.value}')

    async def _handle_in(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IN operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        right_spec = condition_spec[JSQLField.RIGHT.value]

        # Subquery
        if isinstance(right_spec, dict) and JSQLField.SUBQUERY.value in right_spec:
            subquery = await self._build_query(right_spec[JSQLField.SUBQUERY.value])
            return left.in_(subquery)

        # List of values
        if isinstance(right_spec, list):
            return left.in_(right_spec)

        # Expression
        right = await self._build_expression(right_spec)
        return left.in_(right)

    async def _handle_exists(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle EXISTS operator."""
        if JSQLField.SUBQUERY.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.EXISTS.value} must have "{JSQLField.SUBQUERY.value}" field')
        subquery = await self._build_query(condition_spec[JSQLField.SUBQUERY.value])
        return exists(subquery)

    async def _handle_is_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.is_(None)

    async def _handle_is_not_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NOT NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NOT_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.isnot(None)

    async def _handle_like(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle LIKE operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)
        return left.like(right)

    async def _handle_between(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Handle BETWEEN operator.
        
        JSQL format: {"op": "BETWEEN", "expr": {...}, "low": {...}, "high": {...}}
        SQL equivalent: expr BETWEEN low AND high
        """
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "{JSQLField.EXPR.value}" field')
        if 'low' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "low" field')
        if 'high' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "high" field')

        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        # Extract type from expression to use for low/high bounds
        expr_type = getattr(expr, 'type', None) if hasattr(expr, 'type') else None
        low = await self._build_expression(condition_spec['low'], expected_type=expr_type)
        high = await self._build_expression(condition_spec['high'], expected_type=expr_type)
        
        return expr.between(low, high)

    async def _build_condition(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Build WHERE/HAVING condition.

        Args:
            condition_spec: Condition specification

        Returns:
            SQLAlchemy condition

        Raises:
            JSQLSyntaxError: If condition syntax is invalid
        """
        if JSQLField.OP.value not in condition_spec:
            raise JSQLSyntaxError(f'Condition must have "{JSQLField.OP.value}" field')

        op_str = condition_spec[JSQLField.OP.value].upper()

        # Try to convert to JSQLOperator enum
        try:
            op = JSQLOperator(op_str)
        except ValueError:
            raise JSQLSyntaxError(f'Unknown operator: {op_str}')

        # Use dispatch table for special operators
        if handler := self._condition_handlers.get(op):
            return await handler(condition_spec)

        # Handle comparison operators
        if op in COMPARISON_OPERATORS:
            return await self._handle_comparison(op, condition_spec)

        raise JSQLSyntaxError(f'Unsupported operator: {op_str}')

    async def _build_expression(
        self,
        expr_spec: JSQLExpression,
        expected_type: Any | None = None
    ) -> ColumnElement:
        """
        Build expression (arithmetic, logical, etc.).

        Args:
            expr_spec: Expression specification
            expected_type: Expected SQLAlchemy type for literals/parameters (optional)

        Returns:
            SQLAlchemy expression

        Raises:
            JSQLSyntaxError: If expression syntax is invalid
        """
        # Field reference
        if field_name := expr_spec.get(JSQLField.FIELD.value):
            return await self._resolve_column(field_name, None)

        # Literal value
        if (value := expr_spec.get(JSQLField.VALUE.value)) is not None:
            if expected_type is not None:
                # Use cast() for explicit type conversion to avoid VARCHAR casting issues
                return cast(literal(value), expected_type)
            return literal(value)

        # Parameter - use walrus operator
        if param_name := expr_spec.get(JSQLField.PARAM.value):
            if param_name not in self.params:
                raise JSQLSyntaxError(f'Parameter "{param_name}" not provided')
            # Use cast() for explicit type conversion when expected_type is available
            if expected_type is not None:
                return cast(literal(self.params[param_name]), expected_type)
            return literal(self.params[param_name])

        # Function call
        if JSQLField.FUNC.value in expr_spec:
            return await self._build_function(expr_spec)

        # Operator expression
        if JSQLField.OP.value in expr_spec:
            op_str = expr_spec[JSQLField.OP.value].upper()

            # Try to convert to JSQLOperator enum
            try:
                op = JSQLOperator(op_str)
            except ValueError:
                # Unknown operator - might be condition
                return await self._build_condition(expr_spec)

            # Binary arithmetic operators - use pattern matching
            if op in ARITHMETIC_OPERATORS:
                # Validate required fields
                if JSQLField.LEFT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
                if JSQLField.RIGHT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

                left = await self._build_expression(expr_spec[JSQLField.LEFT.value])
                right = await self._build_expression(expr_spec[JSQLField.RIGHT.value])

                match op:
                    case JSQLOperator.ADD:
                        return left + right
                    case JSQLOperator.SUB:
                        return left - right
                    case JSQLOperator.MUL:
                        return left * right
                    case JSQLOperator.DIV:
                        return left / right
                    case JSQLOperator.MOD:
                        return left % right

            # This might be a condition (for CASE WHEN)
            return await self._build_condition(expr_spec)

        # Subquery
        if subquery_spec := expr_spec.get(JSQLField.SUBQUERY.value):
            return await self._build_query(subquery_spec)

        raise JSQLSyntaxError(
            f'Invalid expression: must have {JSQLField.FIELD.value}, {JSQLField.VALUE.value}, '
            f'{JSQLField.PARAM.value}, {JSQLField.FUNC.value}, or {JSQLField.OP.value}'
        )

    async def _build_function(self, func_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build function call.

        Args:
            func_spec: Function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy function call

        Raises:
            JSQLSyntaxError: If function syntax is invalid
        """
        if JSQLField.FUNC.value not in func_spec:
            raise JSQLSyntaxError(f'Function must have "{JSQLField.FUNC.value}" field', path)

        func_name = func_spec[JSQLField.FUNC.value].upper()
        args_spec = func_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Handle DISTINCT
        if func_spec.get(JSQLField.DISTINCT.value, False) and args:
            args[0] = args[0].distinct()

        # Call function
        return sql_func(*args)

    async def _build_window_function(self, window_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build window function.

        Args:
            window_spec: Window function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy window function

        Raises:
            JSQLSyntaxError: If window function syntax is invalid
        """
        if JSQLField.FUNC.value not in window_spec:
            raise JSQLSyntaxError(f'Window function must have "{JSQLField.FUNC.value}" field', path)

        func_name = window_spec[JSQLField.FUNC.value].upper()
        args_spec = window_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Build function call
        func_call = sql_func(*args) if args else sql_func()

        # Build OVER clause - use walrus operator for partition_by
        partition_by = None
        if partition_by_spec := window_spec.get(JSQLField.PARTITION_BY.value):
            partition_by = []
            for part in partition_by_spec:
                if isinstance(part, dict) and JSQLField.FIELD.value in part:
                    partition_by.append(await self._resolve_column(part[JSQLField.FIELD.value], None))
                else:
                    raise JSQLSyntaxError(f'{JSQLField.PARTITION_BY.value} must contain field references', path)

        # Use walrus operator for order_by
        order_by = (
            await self._build_order_by(order_by_spec)
            if (order_by_spec := window_spec.get(JSQLField.ORDER_BY.value))
            else None
        )

        # Apply OVER
        return func_call.over(partition_by=partition_by, order_by=order_by)

    async def _build_group_by(self, group_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build GROUP BY clause.

        Args:
            group_by_spec: List of group by specifications

        Returns:
            List of SQLAlchemy expressions

        Raises:
            JSQLSyntaxError: If GROUP BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in group_by_spec:
            if isinstance(item, str):
                result.append(await self._resolve_column(item, None))
            elif isinstance(item, dict) and JSQLField.FIELD.value in item:
                result.append(await self._resolve_column(item[JSQLField.FIELD.value], None))
            else:
                raise JSQLSyntaxError(f'GROUP BY item must be field name or {{{JSQLField.FIELD.value}: ...}}')

        return result

    async def _resolve_field_or_alias(self, field_name: str) -> ColumnElement:
        """
        Resolve field name or SELECT alias.

        Args:
            field_name: Field name or alias

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If field/alias not found
        """
        # Check if it's a SELECT alias first
        if field_name in self.select_aliases:
            return self.select_aliases[field_name]
        # Otherwise resolve as column
        return await self._resolve_column(field_name, None)

    async def _build_order_by(self, order_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build ORDER BY clause.

        Args:
            order_by_spec: List of order by specifications

        Returns:
            List of SQLAlchemy order expressions

        Raises:
            JSQLSyntaxError: If ORDER BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in order_by_spec:
            if isinstance(item, str):
                column = await self._resolve_field_or_alias(item)
                result.append(column.asc())
            elif isinstance(item, dict):
                if JSQLField.FIELD.value not in item:
                    raise JSQLSyntaxError(f'ORDER BY item must have "{JSQLField.FIELD.value}"')

                field_name = item[JSQLField.FIELD.value]
                column = await self._resolve_field_or_alias(field_name)

                direction = item.get(JSQLField.DIRECTION.value, OrderDirection.ASC.value).lower()

                # Use pattern matching for direction
                match direction:
                    case OrderDirection.ASC.value:
                        result.append(column.asc())
                    case OrderDirection.DESC.value:
                        result.append(column.desc())
                    case _:
                        raise JSQLSyntaxError(f'Invalid ORDER BY direction: {direction}')
            else:
                raise JSQLSyntaxError(
                    f'ORDER BY item must be field name or '
                    f'{{{JSQLField.FIELD.value}: ..., {JSQLField.DIRECTION.value}: ...}}'
                )

        return result

```


–î–æ–±–∞–≤–ª—è—é –∏–º–ø–æ—Ä—Ç `Table` –≤ `parser.py`:


```python
"""JSQL parser - converts JSQL (JSON-SQL) to SQLAlchemy queries."""

from collections.abc import Callable
from typing import Any

from sqlalchemy import Column
from sqlalchemy import Select
from sqlalchemy import Table
from sqlalchemy import and_
from sqlalchemy import bindparam
from sqlalchemy import cast
from sqlalchemy import exists
from sqlalchemy import func
from sqlalchemy import literal
from sqlalchemy import not_
from sqlalchemy import or_
from sqlalchemy import select
from sqlalchemy.sql import ColumnElement
from sqlalchemy.sql.expression import ClauseElement

from collections.abc import Mapping

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityName
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.jsql.alias_manager import AliasManager
from namerec.uma.jsql.constants import ARITHMETIC_OPERATORS
from namerec.uma.jsql.constants import COMPARISON_OPERATORS
from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import JSQLField
from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLExpression
from namerec.uma.jsql.types import JSQLQuery


class JSQLParser:
    """
    Parser for JSQL (JSON-SQL) queries.
    Converts JSQL dict to SQLAlchemy Select statement.
    """

    def __init__(self, namespace_configs: Mapping[str, NamespaceConfig]) -> None:
        """
        Initialize JSQL parser.

        Args:
            namespace_configs: Mapping of namespace names to configurations
        """
        self.namespace_configs = namespace_configs
        self.ctes: dict[str, Select] = {}  # CTEs by name (for SQLAlchemy queries)
        self.alias_manager = AliasManager()  # Manages table/column aliases
        self.select_aliases: dict[str, ColumnElement] = {}  # SELECT column aliases

        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = {
            JSQLOperator.AND: self._handle_and,
            JSQLOperator.OR: self._handle_or,
            JSQLOperator.NOT: self._handle_not,
            JSQLOperator.IN: self._handle_in,
            JSQLOperator.BETWEEN: self._handle_between,
            JSQLOperator.EXISTS: self._handle_exists,
            JSQLOperator.IS_NULL: self._handle_is_null,
            JSQLOperator.IS_NOT_NULL: self._handle_is_not_null,
            JSQLOperator.LIKE: self._handle_like,
        }

    async def parse(self, jsql: JSQLQuery, params: dict[str, Any] | None = None) -> tuple[Select, NamespaceConfig]:
        """
        Parse JSQL query into SQLAlchemy Select statement and namespace config.

        Args:
            jsql: JSQL query dictionary
            params: Query parameters

        Returns:
            Tuple of (SQLAlchemy Select statement, NamespaceConfig)

        Raises:
            JSQLSyntaxError: If JSQL syntax is invalid
            ValueError: If namespace not found or no default available
        """
        self.params = params or {}

        # Parse CTEs if present
        if with_spec := jsql.get(JSQLField.WITH.value):
            await self._parse_ctes(with_spec)

        # Build main query
        query = await self._build_query(jsql)

        # Determine namespace from parsed query
        namespace = self._determine_namespace_from_parsed_query(jsql)

        # Get namespace config (already validated in get_namespace_config)
        config = self.get_namespace_config(namespace)

        return query, config

    async def _parse_ctes(self, ctes: list[dict[str, Any]]) -> None:
        """
        Parse CTEs (Common Table Expressions).

        Args:
            ctes: List of CTE definitions

        Raises:
            JSQLSyntaxError: If CTE syntax is invalid
        """
        for i, cte_def in enumerate(ctes):
            path = f'{JSQLField.WITH.value}[{i}]'

            if JSQLField.NAME.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.NAME.value}" field', path)

            if JSQLField.QUERY.value not in cte_def:
                raise JSQLSyntaxError(f'CTE must have "{JSQLField.QUERY.value}" field', path)

            cte_name = cte_def[JSQLField.NAME.value]
            cte_query = await self._build_query(cte_def[JSQLField.QUERY.value])

            # Register CTE for later use
            cte = cte_query.cte(name=cte_name)
            self.ctes[cte_name] = cte
            
            # Register CTE in AliasManager for column resolution
            self.alias_manager.register_cte(cte_name, cte)

    async def _build_query(self, jsql: JSQLQuery) -> Select:
        """
        Build SELECT query from JSQL.

        Args:
            jsql: JSQL query dictionary

        Returns:
            SQLAlchemy Select statement

        Raises:
            JSQLSyntaxError: If query syntax is invalid
        """
        if JSQLField.FROM.value not in jsql:
            raise JSQLSyntaxError(f'Query must have "{JSQLField.FROM.value}" field')

        # Get FROM clause
        from_clause = await self._build_from(jsql[JSQLField.FROM.value])

        # Process JOINs first to register all table aliases
        if joins_spec := jsql.get(JSQLField.JOINS.value):
            from_clause = await self._process_joins_for_aliases(joins_spec, from_clause)

        # Build SELECT clause (now all aliases are registered)
        select_items = await self._build_select(
            jsql.get(JSQLField.SELECT.value, ['*']), from_clause
        )

        # Start building query
        query = select(*select_items).select_from(from_clause)

        # Add WHERE
        if where_spec := jsql.get(JSQLField.WHERE.value):
            where_clause = await self._build_condition(where_spec)
            query = query.where(where_clause)

        # Add GROUP BY
        if group_by_spec := jsql.get(JSQLField.GROUP_BY.value):
            group_by_clauses = await self._build_group_by(group_by_spec)
            query = query.group_by(*group_by_clauses)

        # Add HAVING
        if having_spec := jsql.get(JSQLField.HAVING.value):
            having_clause = await self._build_condition(having_spec)
            query = query.having(having_clause)

        # Add ORDER BY
        if order_by_spec := jsql.get(JSQLField.ORDER_BY.value):
            order_by_clauses = await self._build_order_by(order_by_spec)
            query = query.order_by(*order_by_clauses)

        # Add LIMIT (check 'is not None' to allow 0)
        if (limit_value := jsql.get(JSQLField.LIMIT.value)) is not None:
            query = query.limit(limit_value)

        # Add OFFSET (check 'is not None' to allow 0)
        if (offset_value := jsql.get(JSQLField.OFFSET.value)) is not None:
            query = query.offset(offset_value)

        return query

    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """
        Register table alias and index its columns for fast lookup.

        Args:
            alias_name: Primary alias name
            table: Table object
            additional_aliases: Additional alias names for the same table
        """
        # Delegate to AliasManager
        self.alias_manager.register_table(alias_name, table, *additional_aliases)

    async def _build_from(self, from_spec: str) -> Any:
        """
        Build FROM clause.

        Args:
            from_spec: Table name (string)

        Returns:
            SQLAlchemy table or CTE reference

        Raises:
            JSQLSyntaxError: If FROM syntax is invalid or table not found
        """
        if not isinstance(from_spec, str):
            raise JSQLSyntaxError(
                f'FROM clause must be a string (table name), got {type(from_spec).__name__}. '
                'Subqueries and complex FROM specifications are not yet supported.'
            )

        # Check if it's a CTE
        if from_spec in self.ctes:
            cte = self.ctes[from_spec]
            self._register_table_alias(from_spec, cte)
            return cte

        # Regular table
        entity_name = parse_entity_name(from_spec)

        # Note: Table should be preloaded in executor before parsing
        # This ensures lazy loading happens before synchronous parsing
        table = await self._get_table_async(entity_name)

        # Register both by entity name and by from_spec (they might differ with namespace)
        self._register_table_alias(
            entity_name.entity,
            table,
            *([] if from_spec == entity_name.entity else [from_spec])
        )
        return table

    def get_namespace_config(self, namespace: str) -> NamespaceConfig:
        """
        Get namespace config by name.

        Args:
            namespace: Namespace name

        Returns:
            NamespaceConfig for the namespace

        Raises:
            ValueError: If namespace not found
        """
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            raise ValueError(f'Namespace "{namespace}" not found. Available: {available}')

        return self.namespace_configs[namespace]

    def _determine_namespace_from_parsed_query(self, jsql: dict) -> str:
        """
        Determine namespace from parsed query.

        Namespace comes from:
        - FROM clause entity name
        - Or default namespace if single namespace configured

        Args:
            jsql: JSQL query dictionary

        Returns:
            Namespace name

        Raises:
            ValueError: If namespace cannot be determined
        """
        from_entity = jsql.get('from')
        if not from_entity:
            # No FROM - use default
            if len(self.namespace_configs) == 1:
                return next(iter(self.namespace_configs.keys()))
            raise ValueError("JSQL must contain 'from' field")

        entity = parse_entity_name(from_entity if isinstance(from_entity, str) else '')

        # Use entity namespace or default
        if entity.namespace:
            return entity.namespace

        if len(self.namespace_configs) == 1:
            return next(iter(self.namespace_configs.keys()))

        raise ValueError(
            'Namespace not specified and no default available. '
            'Use explicit namespace or configure single namespace.'
        )

    async def _get_table_async(self, entity_name: EntityName) -> Table:
        """
        Get table from metadata provider.

        Uses entity_name.namespace to determine which metadata provider to use.

        Args:
            entity_name: Entity name

        Returns:
            SQLAlchemy Table object

        Raises:
            JSQLSyntaxError: If table not found
        """
        namespace = entity_name.namespace
        if not namespace:
            # Resolve default namespace
            if len(self.namespace_configs) == 1:
                namespace = next(iter(self.namespace_configs.keys()))
            else:
                raise ValueError(
                    'Namespace not specified and no default available. '
                    'Use explicit namespace or configure single namespace.'
                )

        config = self.get_namespace_config(namespace)

        try:
            return await config.metadata_provider.get_table(
                entity_name,
                config.engine,
                None,
            )
        except Exception as e:
            raise JSQLSyntaxError(f'Table "{entity_name}" not found: {e}') from e

    def _apply_alias(self, expression: ColumnElement, alias_name: str | None) -> ColumnElement:
        """
        Apply alias to expression and register it.

        Args:
            expression: SQLAlchemy expression
            alias_name: Alias name (if provided)

        Returns:
            Expression with alias applied (if provided)
        """
        if alias_name:
            labeled_expr = expression.label(alias_name)
            # Store alias for ORDER BY resolution
            self.select_aliases[alias_name] = labeled_expr
            return labeled_expr
        return expression

    async def _build_select(self, select_spec: list[str | dict[str, Any]], from_clause: Any) -> list[ColumnElement]:
        """
        Build SELECT clause items.

        Args:
            select_spec: List of select specifications
            from_clause: FROM clause for column resolution

        Returns:
            List of SQLAlchemy column elements

        Raises:
            JSQLSyntaxError: If SELECT syntax is invalid
        """
        items: list[ColumnElement] = []

        for i, item_spec in enumerate(select_spec):
            path = f'{JSQLField.SELECT.value}[{i}]'

            # Wildcard: SELECT *
            if item_spec == '*':
                # Add all columns from the FROM clause
                if hasattr(from_clause, 'columns'):
                    items.extend(from_clause.columns)
                continue

            # Simple string field name
            if isinstance(item_spec, str):
                column = await self._resolve_column(item_spec, from_clause)
                items.append(column)
                continue

            # Dictionary specification
            if not isinstance(item_spec, dict):
                raise JSQLSyntaxError(f'Invalid SELECT item type: {type(item_spec)}', path)

            # Extract alias once
            alias_name = item_spec.get(JSQLField.ALIAS.value)

            # Field with optional alias
            if field_name := item_spec.get(JSQLField.FIELD.value):
                column = await self._resolve_column(field_name, from_clause)
                items.append(self._apply_alias(column, alias_name))
                continue

            # Function call
            if JSQLField.FUNC.value in item_spec:
                func_expr = await self._build_function(item_spec, path)
                items.append(self._apply_alias(func_expr, alias_name))
                continue

            # Expression
            if expr_spec := item_spec.get(JSQLField.EXPR.value):
                expr = await self._build_expression(expr_spec)
                items.append(self._apply_alias(expr, alias_name))
                continue

            # Window function
            if window_spec := item_spec.get(JSQLField.WINDOW_FUNC.value):
                window_expr = await self._build_window_function(window_spec, path)
                items.append(self._apply_alias(window_expr, alias_name))
                continue

            # Literal value
            if (value := item_spec.get(JSQLField.VALUE.value)) is not None:
                value_expr = literal(value)
                items.append(self._apply_alias(value_expr, alias_name))
                continue

            raise JSQLSyntaxError(
                f'SELECT item must have one of: {JSQLField.FIELD.value}, {JSQLField.FUNC.value}, '
                f'{JSQLField.EXPR.value}, {JSQLField.WINDOW_FUNC.value}, {JSQLField.VALUE.value}',
                path
            )

        return items

    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """
        Resolve column reference (e.g., 'users.id' or 'id').

        Args:
            field_spec: Field specification
            from_clause: FROM clause for column resolution (can be None)

        Returns:
            SQLAlchemy column

        Raises:
            JSQLSyntaxError: If column not found
        """
        # Try to resolve through AliasManager first
        try:
            return self.alias_manager.resolve_column(field_spec, from_clause)
        except JSQLSyntaxError:
            # If qualified column not found in aliases, try lazy loading
            if '.' in field_spec:
                table_name, column_name = field_spec.split('.', 1)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                    if column_name in table.columns:
                        return table.columns[column_name]
                except Exception as e:
                    raise JSQLSyntaxError(f'Column "{field_spec}" not found: {e}') from e
            
            # Re-raise original error if lazy loading also fails
            raise

    async def _process_joins_for_aliases(self, joins_spec: list[dict[str, Any]], base_table: Any) -> Any:
        """
        Process JOINs to register aliases and build joined FROM clause.

        Args:
            joins_spec: List of join specifications
            base_table: Base table for joins

        Returns:
            FROM clause with joins applied

        Raises:
            JSQLSyntaxError: If JOIN syntax is invalid
        """
        current_from = base_table

        for i, join_spec in enumerate(joins_spec):
            path = f'{JSQLField.JOINS.value}[{i}]'

            if JSQLField.TABLE.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.TABLE.value}" field', path)

            # Get join type (default INNER) and validate
            join_type_str = join_spec.get(JSQLField.TYPE.value, JoinType.INNER.value).upper()
            try:
                join_type = JoinType(join_type_str)
            except ValueError:
                raise JSQLSyntaxError(f'Invalid join type: {join_type_str}', path)

            # CROSS JOIN doesn't require ON clause
            if join_type != JoinType.CROSS and JSQLField.ON.value not in join_spec:
                raise JSQLSyntaxError(f'JOIN must have "{JSQLField.ON.value}" field', path)

            # Get table
            table_name = join_spec[JSQLField.TABLE.value]

            # Check if it's a CTE or regular table
            if table_name in self.ctes:
                table = self.ctes[table_name]
            else:
                # Load table via metadata provider (lazy loading)
                entity_name = parse_entity_name(table_name)
                try:
                    table = await self._get_table_async(entity_name)
                except Exception as e:
                    raise JSQLSyntaxError(f'Table "{table_name}" not found: {e}', path) from e

            # Handle alias
            if alias_name := join_spec.get(JSQLField.ALIAS.value):
                table = table.alias(alias_name)
            else:
                alias_name = table_name

            # Register alias
            self._register_table_alias(alias_name, table)

            # Apply join based on type - use pattern matching
            match join_type:
                case JoinType.CROSS:
                    # CROSS JOIN - no ON clause
                    current_from = current_from.join(table, isouter=False, full=False)
                case JoinType.LEFT:
                    # LEFT OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True)
                case JoinType.RIGHT:
                    # RIGHT OUTER JOIN - reverse the order
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = table.join(current_from, on_condition, isouter=True)
                case JoinType.FULL:
                    # FULL OUTER JOIN
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=True, full=True)
                case JoinType.INNER:
                    # INNER JOIN (default)
                    on_condition = await self._build_condition(join_spec[JSQLField.ON.value])
                    current_from = current_from.join(table, on_condition, isouter=False)

        return current_from

    async def _handle_and(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle AND operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.AND.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return and_(*conditions)

    async def _handle_or(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle OR operator."""
        if JSQLField.CONDITIONS.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.OR.value} must have "{JSQLField.CONDITIONS.value}" field')
        conditions = [await self._build_condition(c) for c in condition_spec[JSQLField.CONDITIONS.value]]
        return or_(*conditions)

    async def _handle_not(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle NOT operator."""
        if JSQLField.CONDITION.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.NOT.value} must have "{JSQLField.CONDITION.value}" field')
        condition = await self._build_condition(condition_spec[JSQLField.CONDITION.value])
        return not_(condition)

    async def _handle_comparison(self, op: JSQLOperator, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle comparison operators (=, !=, <, <=, >, >=)."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)

        # Use match-case for operator dispatch
        match op:
            case JSQLOperator.EQ:
                return left == right
            case JSQLOperator.NE:
                return left != right
            case JSQLOperator.LT:
                return left < right
            case JSQLOperator.LE:
                return left <= right
            case JSQLOperator.GT:
                return left > right
            case JSQLOperator.GE:
                return left >= right
            case _:
                raise JSQLSyntaxError(f'Unknown comparison operator: {op.value}')

    async def _handle_in(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IN operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IN.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        right_spec = condition_spec[JSQLField.RIGHT.value]

        # Subquery
        if isinstance(right_spec, dict) and JSQLField.SUBQUERY.value in right_spec:
            subquery = await self._build_query(right_spec[JSQLField.SUBQUERY.value])
            return left.in_(subquery)

        # List of values
        if isinstance(right_spec, list):
            return left.in_(right_spec)

        # Expression
        right = await self._build_expression(right_spec)
        return left.in_(right)

    async def _handle_exists(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle EXISTS operator."""
        if JSQLField.SUBQUERY.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.EXISTS.value} must have "{JSQLField.SUBQUERY.value}" field')
        subquery = await self._build_query(condition_spec[JSQLField.SUBQUERY.value])
        return exists(subquery)

    async def _handle_is_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.is_(None)

    async def _handle_is_not_null(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle IS NOT NULL operator."""
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.IS_NOT_NULL.value} must have "{JSQLField.EXPR.value}" field')
        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        return expr.isnot(None)

    async def _handle_like(self, condition_spec: JSQLExpression) -> ClauseElement:
        """Handle LIKE operator."""
        if JSQLField.LEFT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.LEFT.value}" field')
        if JSQLField.RIGHT.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.LIKE.value} operator must have "{JSQLField.RIGHT.value}" field')

        left = await self._build_expression(condition_spec[JSQLField.LEFT.value])
        # Extract type from left expression to use for right expression
        left_type = getattr(left, 'type', None) if hasattr(left, 'type') else None
        right = await self._build_expression(condition_spec[JSQLField.RIGHT.value], expected_type=left_type)
        return left.like(right)

    async def _handle_between(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Handle BETWEEN operator.
        
        JSQL format: {"op": "BETWEEN", "expr": {...}, "low": {...}, "high": {...}}
        SQL equivalent: expr BETWEEN low AND high
        """
        if JSQLField.EXPR.value not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "{JSQLField.EXPR.value}" field')
        if 'low' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "low" field')
        if 'high' not in condition_spec:
            raise JSQLSyntaxError(f'{JSQLOperator.BETWEEN.value} must have "high" field')

        expr = await self._build_expression(condition_spec[JSQLField.EXPR.value])
        # Extract type from expression to use for low/high bounds
        expr_type = getattr(expr, 'type', None) if hasattr(expr, 'type') else None
        low = await self._build_expression(condition_spec['low'], expected_type=expr_type)
        high = await self._build_expression(condition_spec['high'], expected_type=expr_type)
        
        return expr.between(low, high)

    async def _build_condition(self, condition_spec: JSQLExpression) -> ClauseElement:
        """
        Build WHERE/HAVING condition.

        Args:
            condition_spec: Condition specification

        Returns:
            SQLAlchemy condition

        Raises:
            JSQLSyntaxError: If condition syntax is invalid
        """
        if JSQLField.OP.value not in condition_spec:
            raise JSQLSyntaxError(f'Condition must have "{JSQLField.OP.value}" field')

        op_str = condition_spec[JSQLField.OP.value].upper()

        # Try to convert to JSQLOperator enum
        try:
            op = JSQLOperator(op_str)
        except ValueError:
            raise JSQLSyntaxError(f'Unknown operator: {op_str}')

        # Use dispatch table for special operators
        if handler := self._condition_handlers.get(op):
            return await handler(condition_spec)

        # Handle comparison operators
        if op in COMPARISON_OPERATORS:
            return await self._handle_comparison(op, condition_spec)

        raise JSQLSyntaxError(f'Unsupported operator: {op_str}')

    async def _build_expression(
        self,
        expr_spec: JSQLExpression,
        expected_type: Any | None = None
    ) -> ColumnElement:
        """
        Build expression (arithmetic, logical, etc.).

        Args:
            expr_spec: Expression specification
            expected_type: Expected SQLAlchemy type for literals/parameters (optional)

        Returns:
            SQLAlchemy expression

        Raises:
            JSQLSyntaxError: If expression syntax is invalid
        """
        # Field reference
        if field_name := expr_spec.get(JSQLField.FIELD.value):
            return await self._resolve_column(field_name, None)

        # Literal value
        if (value := expr_spec.get(JSQLField.VALUE.value)) is not None:
            if expected_type is not None:
                # Use cast() for explicit type conversion to avoid VARCHAR casting issues
                return cast(literal(value), expected_type)
            return literal(value)

        # Parameter - use walrus operator
        if param_name := expr_spec.get(JSQLField.PARAM.value):
            if param_name not in self.params:
                raise JSQLSyntaxError(f'Parameter "{param_name}" not provided')
            # Use cast() for explicit type conversion when expected_type is available
            if expected_type is not None:
                return cast(literal(self.params[param_name]), expected_type)
            return literal(self.params[param_name])

        # Function call
        if JSQLField.FUNC.value in expr_spec:
            return await self._build_function(expr_spec)

        # Operator expression
        if JSQLField.OP.value in expr_spec:
            op_str = expr_spec[JSQLField.OP.value].upper()

            # Try to convert to JSQLOperator enum
            try:
                op = JSQLOperator(op_str)
            except ValueError:
                # Unknown operator - might be condition
                return await self._build_condition(expr_spec)

            # Binary arithmetic operators - use pattern matching
            if op in ARITHMETIC_OPERATORS:
                # Validate required fields
                if JSQLField.LEFT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.LEFT.value}" field')
                if JSQLField.RIGHT.value not in expr_spec:
                    raise JSQLSyntaxError(f'{op.value} operator must have "{JSQLField.RIGHT.value}" field')

                left = await self._build_expression(expr_spec[JSQLField.LEFT.value])
                right = await self._build_expression(expr_spec[JSQLField.RIGHT.value])

                match op:
                    case JSQLOperator.ADD:
                        return left + right
                    case JSQLOperator.SUB:
                        return left - right
                    case JSQLOperator.MUL:
                        return left * right
                    case JSQLOperator.DIV:
                        return left / right
                    case JSQLOperator.MOD:
                        return left % right

            # This might be a condition (for CASE WHEN)
            return await self._build_condition(expr_spec)

        # Subquery
        if subquery_spec := expr_spec.get(JSQLField.SUBQUERY.value):
            return await self._build_query(subquery_spec)

        raise JSQLSyntaxError(
            f'Invalid expression: must have {JSQLField.FIELD.value}, {JSQLField.VALUE.value}, '
            f'{JSQLField.PARAM.value}, {JSQLField.FUNC.value}, or {JSQLField.OP.value}'
        )

    async def _build_function(self, func_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build function call.

        Args:
            func_spec: Function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy function call

        Raises:
            JSQLSyntaxError: If function syntax is invalid
        """
        if JSQLField.FUNC.value not in func_spec:
            raise JSQLSyntaxError(f'Function must have "{JSQLField.FUNC.value}" field', path)

        func_name = func_spec[JSQLField.FUNC.value].upper()
        args_spec = func_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Handle DISTINCT
        if func_spec.get(JSQLField.DISTINCT.value, False) and args:
            args[0] = args[0].distinct()

        # Call function
        return sql_func(*args)

    async def _build_window_function(self, window_spec: dict[str, Any], path: str = '') -> ColumnElement:
        """
        Build window function.

        Args:
            window_spec: Window function specification
            path: Path for error reporting

        Returns:
            SQLAlchemy window function

        Raises:
            JSQLSyntaxError: If window function syntax is invalid
        """
        if JSQLField.FUNC.value not in window_spec:
            raise JSQLSyntaxError(f'Window function must have "{JSQLField.FUNC.value}" field', path)

        func_name = window_spec[JSQLField.FUNC.value].upper()
        args_spec = window_spec.get(JSQLField.ARGS.value, [])

        # Build arguments
        args: list[ColumnElement] = []
        for arg in args_spec:
            if isinstance(arg, dict):
                args.append(await self._build_expression(arg))
            else:
                args.append(literal(arg))

        # Get SQLAlchemy function - use walrus operator
        if (sql_func := getattr(func, func_name.lower(), None)) is None:
            raise JSQLSyntaxError(f'Unknown function: {func_name}', path)

        # Build function call
        func_call = sql_func(*args) if args else sql_func()

        # Build OVER clause - use walrus operator for partition_by
        partition_by = None
        if partition_by_spec := window_spec.get(JSQLField.PARTITION_BY.value):
            partition_by = []
            for part in partition_by_spec:
                if isinstance(part, dict) and JSQLField.FIELD.value in part:
                    partition_by.append(await self._resolve_column(part[JSQLField.FIELD.value], None))
                else:
                    raise JSQLSyntaxError(f'{JSQLField.PARTITION_BY.value} must contain field references', path)

        # Use walrus operator for order_by
        order_by = (
            await self._build_order_by(order_by_spec)
            if (order_by_spec := window_spec.get(JSQLField.ORDER_BY.value))
            else None
        )

        # Apply OVER
        return func_call.over(partition_by=partition_by, order_by=order_by)

    async def _build_group_by(self, group_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build GROUP BY clause.

        Args:
            group_by_spec: List of group by specifications

        Returns:
            List of SQLAlchemy expressions

        Raises:
            JSQLSyntaxError: If GROUP BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in group_by_spec:
            if isinstance(item, str):
                result.append(await self._resolve_column(item, None))
            elif isinstance(item, dict) and JSQLField.FIELD.value in item:
                result.append(await self._resolve_column(item[JSQLField.FIELD.value], None))
            else:
                raise JSQLSyntaxError(f'GROUP BY item must be field name or {{{JSQLField.FIELD.value}: ...}}')

        return result

    async def _resolve_field_or_alias(self, field_name: str) -> ColumnElement:
        """
        Resolve field name or SELECT alias.

        Args:
            field_name: Field name or alias

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If field/alias not found
        """
        # Check if it's a SELECT alias first
        if field_name in self.select_aliases:
            return self.select_aliases[field_name]
        # Otherwise resolve as column
        return await self._resolve_column(field_name, None)

    async def _build_order_by(self, order_by_spec: list[dict[str, Any] | str]) -> list[ColumnElement]:
        """
        Build ORDER BY clause.

        Args:
            order_by_spec: List of order by specifications

        Returns:
            List of SQLAlchemy order expressions

        Raises:
            JSQLSyntaxError: If ORDER BY syntax is invalid
        """
        result: list[ColumnElement] = []

        for item in order_by_spec:
            if isinstance(item, str):
                column = await self._resolve_field_or_alias(item)
                result.append(column.asc())
            elif isinstance(item, dict):
                if JSQLField.FIELD.value not in item:
                    raise JSQLSyntaxError(f'ORDER BY item must have "{JSQLField.FIELD.value}"')

                field_name = item[JSQLField.FIELD.value]
                column = await self._resolve_field_or_alias(field_name)

                direction = item.get(JSQLField.DIRECTION.value, OrderDirection.ASC.value).lower()

                # Use pattern matching for direction
                match direction:
                    case OrderDirection.ASC.value:
                        result.append(column.asc())
                    case OrderDirection.DESC.value:
                        result.append(column.desc())
                    case _:
                        raise JSQLSyntaxError(f'Invalid ORDER BY direction: {direction}')
            else:
                raise JSQLSyntaxError(
                    f'ORDER BY item must be field name or '
                    f'{{{JSQLField.FIELD.value}: ..., {JSQLField.DIRECTION.value}: ...}}'
                )

        return result

```


–û–±–Ω–æ–≤–ª—è—é `JSQLExecutor`:



–ü–µ—Ä–µ–ø–∏—Å—ã–≤–∞—é `JSQLExecutor` –∫–∞–∫ stateless:


```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                return QueryResult.from_cached(cached, params)

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)

        # Cache result
        if cache_backend and cache_key:
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return QueryResult.from_db_result(result)
        finally:
            await conn.close()

```


–û–±–Ω–æ–≤–ª—è—é `UMA.select()` –∏ —É–¥–∞–ª—è—é –Ω–µ–Ω—É–∂–Ω—ã–µ –º–µ—Ç–æ–¥—ã:



–û–±–Ω–æ–≤–ª—è—é `UMA.select()` –∏ —É–¥–∞–ª—è—é –Ω–µ–Ω—É–∂–Ω—ã–µ –º–µ—Ç–æ–¥—ã:


```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        All logic (FROM parsing, namespace resolution, context creation,
        access control) is handled by stateless JSQLExecutor.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace (ignored - namespace from FROM clause is used)

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.jsql.executor import JSQLExecutor

        result = await JSQLExecutor.execute(
            jsql=jsql,
            params=params,
            namespace_configs=self.namespace_configs,
            user_context=user_context,
            cache_backend=self.cache_backend if self.cache_enabled else None,
        )

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _extract_entities_from_jsql(self, jsql: dict[str, Any]) -> set[str]:
        """
        Extract all entity names from JSQL query for access control.

        Recursively extracts entities from:
        - FROM clause
        - WITH clause (CTEs)
        - JOIN clauses
        - Subqueries

        Args:
            jsql: JSQL query dictionary

        Returns:
            Set of entity names (qualified with namespace if present)

        Note:
            This is a conservative extraction - it may include entities that
            are not directly queried (e.g., in expressions), but this is
            safer for access control.
        """
        entities: set[str] = set()

        # Extract FROM entity
        if from_entity := jsql.get('from'):
            if isinstance(from_entity, str):
                entities.add(from_entity)
            elif isinstance(from_entity, dict):
                # Handle subquery in FROM
                entities.update(self._extract_entities_from_jsql(from_entity))

        # Extract CTEs (WITH clause)
        # CTE can be either list of dicts [{'name': 'cte1', 'query': {...}}]
        # or dict of named CTEs {'cte1': {...}}
        # Note: CTEs themselves don't need access control (they're query definitions),
        # but we need to check access to entities used in CTE definitions
        if with_clauses := jsql.get('with'):
            if isinstance(with_clauses, list):
                for cte in with_clauses:
                    if isinstance(cte, dict):
                        # Extract from CTE definition
                        if cte_query := cte.get('query'):
                            if isinstance(cte_query, dict):
                                entities.update(self._extract_entities_from_jsql(cte_query))
            elif isinstance(with_clauses, dict):
                for cte_def in with_clauses.values():
                    if isinstance(cte_def, dict):
                        entities.update(self._extract_entities_from_jsql(cte_def))

        # Extract JOINs
        if joins := jsql.get('joins'):
            for join in joins:
                if isinstance(join, dict):
                    # Extract join table
                    if join_table := join.get('table'):
                        if isinstance(join_table, str):
                            entities.add(join_table)
                        elif isinstance(join_table, dict):
                            # Subquery in join
                            entities.update(self._extract_entities_from_jsql(join_table))

                    # Extract entities from ON clause
                    if on_clause := join.get('on'):
                        if isinstance(on_clause, dict):
                            entities.update(self._extract_entities_from_expression(on_clause))

        # Extract entities from WHERE, HAVING, GROUP_BY, ORDER_BY
        for clause in ['where', 'having', 'group_by', 'order_by']:
            if clause_data := jsql.get(clause):
                if isinstance(clause_data, dict):
                    entities.update(self._extract_entities_from_expression(clause_data))
                elif isinstance(clause_data, list):
                    for item in clause_data:
                        if isinstance(item, dict):
                            entities.update(self._extract_entities_from_expression(item))

        # Extract entities from SELECT clause
        if select_clause := jsql.get('select'):
            if isinstance(select_clause, list):
                for select_item in select_clause:
                    if isinstance(select_item, dict):
                        entities.update(self._extract_entities_from_expression(select_item))

        return entities

    def _extract_entities_from_expression(self, expr: dict[str, Any]) -> set[str]:
        """
        Extract entity names from JSQL expression.

        Recursively processes:
        - Field references
        - Function calls
        - Operators
        - Subqueries

        Args:
            expr: JSQL expression dictionary

        Returns:
            Set of entity names
        """
        entities: set[str] = set()

        # Field reference
        if field := expr.get('field'):
            if isinstance(field, str):
                # Extract entity from qualified field (table.column)
                if '.' in field:
                    entity_part = field.split('.', 1)[0]
                    # Skip if it's a function or special value
                    if not entity_part.isupper():
                        entities.add(entity_part)
            elif isinstance(field, dict):
                entities.update(self._extract_entities_from_expression(field))

        # Function call
        if 'func' in expr:
            if args := expr.get('args'):
                if isinstance(args, list):
                    for arg in args:
                        if isinstance(arg, dict):
                            entities.update(self._extract_entities_from_expression(arg))
                elif isinstance(args, dict):
                    entities.update(self._extract_entities_from_expression(args))

        # Binary operator
        if 'left' in expr and 'right' in expr:
            if isinstance(expr['left'], dict):
                entities.update(self._extract_entities_from_expression(expr['left']))
            if isinstance(expr['right'], dict):
                entities.update(self._extract_entities_from_expression(expr['right']))

        # Subquery
        if 'subquery' in expr:
            if isinstance(expr['subquery'], dict):
                entities.update(self._extract_entities_from_jsql(expr['subquery']))

        # Expression
        if 'expr' in expr:
            if isinstance(expr['expr'], dict):
                entities.update(self._extract_entities_from_expression(expr['expr']))

        return entities

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        All logic (FROM parsing, namespace resolution, context creation,
        access control) is handled by stateless JSQLExecutor.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace (ignored - namespace from FROM clause is used)

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.jsql.executor import JSQLExecutor

        result = await JSQLExecutor.execute(
            jsql=jsql,
            params=params,
            namespace_configs=self.namespace_configs,
            user_context=user_context,
            cache_backend=self.cache_backend if self.cache_enabled else None,
        )

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        if isinstance(operation, str):
            operation = Operation(operation)

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        All logic (FROM parsing, namespace resolution, context creation,
        access control) is handled by stateless JSQLExecutor.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace (ignored - namespace from FROM clause is used)

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.jsql.executor import JSQLExecutor

        result = await JSQLExecutor.execute(
            jsql=jsql,
            params=params,
            namespace_configs=self.namespace_configs,
            user_context=user_context,
            cache_backend=self.cache_backend if self.cache_enabled else None,
        )

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        from namerec.uma.core.access import check_access

        check_access(
            metadata_provider=context.metadata_provider,
            entity_name=entity_name,
            operation=operation,
            user_context=context.user_context,
        )

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

        # Check if metadata provider has can() method
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                raise UMAAccessDeniedError(entity_name, operation.value)

```

```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.jsql.executor import JSQLExecutor
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        All logic (FROM parsing, namespace resolution, context creation,
        access control) is handled by stateless JSQLExecutor.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace (ignored - namespace from FROM clause is used)

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.jsql.executor import JSQLExecutor

        result = await JSQLExecutor.execute(
            jsql=jsql,
            params=params,
            namespace_configs=self.namespace_configs,
            user_context=user_context,
            cache_backend=self.cache_backend if self.cache_enabled else None,
        )

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        from namerec.uma.core.access import check_access

        check_access(
            metadata_provider=context.metadata_provider,
            entity_name=entity_name,
            operation=operation,
            user_context=context.user_context,
        )

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

```


–ü—Ä–æ–≤–µ—Ä—è—é –Ω–∞–ª–∏—á–∏–µ –º–µ—Ç–æ–¥–∞ `QueryResult.from_cached()` –∏ –æ–±–Ω–æ–≤–ª—è—é –∏–º–ø–æ—Ä—Ç—ã:



–ü—Ä–æ–≤–µ—Ä—è—é, –∫–∞–∫ QueryResult –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Å—Ç–∞—Ä–æ–º –∫–æ–¥–µ, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, –∫–∞–∫–∏–µ –º–µ—Ç–æ–¥—ã –Ω—É–∂–Ω—ã:



–î–æ–±–∞–≤–ª—è—é –º–µ—Ç–æ–¥—ã `from_cached` –∏ `from_db_result` –≤ `QueryResult`:


```python
"""Type definitions for JSQL module."""

from dataclasses import dataclass
from typing import Any


@dataclass(slots=True)
class ColumnMetadata:
    """Metadata for a result column."""

    name: str
    type: str
    nullable: bool
    qualified_name: str | None = None
    source_entity: str | None = None
    source_field: str | None = None
    size: int | None = None
    precision: int | None = None
    scale: int | None = None

    def to_dict(self) -> dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary representation
        """
        return {
            'name': self.name,
            'type': self.type,
            'nullable': self.nullable,
            'qualified_name': self.qualified_name,
            'source_entity': self.source_entity,
            'source_field': self.source_field,
            'size': self.size,
            'precision': self.precision,
            'scale': self.scale,
        }


@dataclass(slots=True)
class QueryResult:
    """Result of JSQL query execution."""

    meta: list[ColumnMetadata]
    data: list[list[Any]]
    debug: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary with 'meta' and 'data' keys, optionally 'debug'
        """
        result: dict[str, Any] = {
            'meta': [col.to_dict() for col in self.meta],
            'data': self.data,
        }
        if self.debug is not None:
            result['debug'] = self.debug
        return result

    @classmethod
    def from_cached(cls, cached_query: Any, params: dict | None = None) -> 'QueryResult':
        """
        Create QueryResult from cached query.

        Args:
            cached_query: CachedQuery object
            params: Query parameters (unused, kept for API compatibility)

        Returns:
            QueryResult with empty metadata (not available from cached queries)
        """
        del params  # Not used for cached queries
        # For cached queries, we don't have metadata
        # Return empty metadata - data will be populated from execution
        return cls(meta=[], data=[])

    @classmethod
    def from_db_result(cls, result: Any) -> 'QueryResult':
        """
        Create QueryResult from database result.

        Args:
            result: SQLAlchemy CursorResult

        Returns:
            QueryResult with metadata and data
        """
        from namerec.uma.jsql.result import JSQLResultBuilder

        # Use JSQLResultBuilder to extract metadata and data
        # Note: query is not available here, so metadata will be limited
        meta = []
        data = []

        # Extract data rows
        for row in result:
            if hasattr(row, '__iter__'):
                data.append(list(row))
            else:
                data.append([row])

        # Try to extract basic metadata from result
        if hasattr(result, 'keys'):
            for key in result.keys():
                from namerec.uma.jsql.types import ColumnMetadata
                meta.append(ColumnMetadata(
                    name=key,
                    type='UNKNOWN',
                    nullable=True,
                ))

        return cls(meta=meta, data=data)


# Type aliases for JSQL structure
JSQLQuery = dict[str, Any]
JSQLExpression = dict[str, Any]
JSQLCondition = dict[str, Any]

```


–ò—Å–ø—Ä–∞–≤–ª—è—é `executor.py`: `from_cached` –¥–æ–ª–∂–µ–Ω –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–ø—Ä–æ—Å –∏–∑ –∫—ç—à–∞:


```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)

        # Cache result
        if cache_backend and cache_key:
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return QueryResult.from_db_result(result)
        finally:
            await conn.close()

```

```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)

        # Cache result
        if cache_backend and cache_key:
            cached_query = CachedQuery(
                sql=str(sql_query),
                params_mapping={},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data)
        finally:
            await conn.close()

```


–ò—Å–ø—Ä–∞–≤–ª—è—é `executor.py`: `from_cached` –¥–æ–ª–∂–µ–Ω –≤—ã–ø–æ–ª–Ω—è—Ç—å SQL –∏–∑ –∫—ç—à–∞:


```python
            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result
```

```python
    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data)
        finally:
            await conn.close()
```


–ü–µ—Ä–µ—á–∏—Ç—ã–≤–∞—é —Ñ–∞–π–ª:



–£–¥–∞–ª—è—é –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –º–µ—Ç–æ–¥—ã –∏–∑ `types.py` –∏ –ø—Ä–æ–≤–µ—Ä—è—é –ª–∏–Ω—Ç–µ—Ä:


```python
"""Type definitions for JSQL module."""

from dataclasses import dataclass
from typing import Any


@dataclass(slots=True)
class ColumnMetadata:
    """Metadata for a result column."""

    name: str
    type: str
    nullable: bool
    qualified_name: str | None = None
    source_entity: str | None = None
    source_field: str | None = None
    size: int | None = None
    precision: int | None = None
    scale: int | None = None

    def to_dict(self) -> dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary representation
        """
        return {
            'name': self.name,
            'type': self.type,
            'nullable': self.nullable,
            'qualified_name': self.qualified_name,
            'source_entity': self.source_entity,
            'source_field': self.source_field,
            'size': self.size,
            'precision': self.precision,
            'scale': self.scale,
        }


@dataclass(slots=True)
class QueryResult:
    """Result of JSQL query execution."""

    meta: list[ColumnMetadata]
    data: list[list[Any]]
    debug: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary with 'meta' and 'data' keys, optionally 'debug'
        """
        result: dict[str, Any] = {
            'meta': [col.to_dict() for col in self.meta],
            'data': self.data,
        }
        if self.debug is not None:
            result['debug'] = self.debug
        return result


# Type aliases for JSQL structure
JSQLQuery = dict[str, Any]
JSQLExpression = dict[str, Any]
JSQLCondition = dict[str, Any]

```


–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –ª–∏–Ω—Ç–µ—Ä–∞ –æ–± –∏–º–ø–æ—Ä—Ç–∞—Ö sqlalchemy ‚Äî —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ. –ü—Ä–æ–≤–µ—Ä—è—é –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã –≤ `application.py`:



–ü—Ä–æ–≤–µ—Ä—è—é, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ `JSQLExecutor` –≥–¥–µ-—Ç–æ –µ—â–µ –≤ `application.py`:


```python
"""UMA application class - main entry point for UMA operations."""

from collections.abc import Mapping
from dataclasses import dataclass
from dataclasses import field
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMAAccessDeniedError
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.jsql.cache import CacheBackend
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.registry import EntityRegistry


@dataclass
class UMA:
    """
    UMA application instance with encapsulated state.

    Manages entity registry, namespace configurations, and provides
    high-level API for data operations with optional query caching.

    Example:
        # Create UMA instance with default memory cache
        uma = UMA.create({
            'main': NamespaceConfig(
                engine=engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        })

        # Create with Redis cache
        from namerec.uma.jsql.cache.redis import RedisCacheBackend
        uma = UMA.create(
            namespace_configs={'main': config},
            cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
        )

        # Use UMA
        user = await uma.read('users', id=1)
        await uma.save('users', {'name': 'John', 'email': 'john@example.com'})

        # Query with caching
        result = await uma.select({'from': 'users', 'select': ['*']})

        # Cache management
        stats = uma.cache_stats()
        uma.disable_cache()  # Temporarily disable for debugging
        uma.enable_cache()
        uma.clear_cache()
    """

    @dataclass
    class _EntityOperationParams:
        """Internal helper: parameters prepared for entity operation."""

        entity: EntityName
        context: UMAContext
        handler: EntityHandler

    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    cache_backend: CacheBackend | None = field(default=None)
    cache_enabled: bool = field(default=True)

    @classmethod
    def create(
        cls,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_handler: type[EntityHandler] | None = None,
        cache_backend: CacheBackend | None = None,
        cache_enabled: bool = True,
    ) -> 'UMA':
        """
        Create UMA application instance.

        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_handler: Default handler class for unregistered entities
            cache_backend: Optional cache backend (default: MemoryCacheBackend)
            cache_enabled: Enable caching by default (default: True)

        Returns:
            Initialized UMA instance

        Raises:
            ValueError: If namespace_configs is empty

        Behaviour:
        - If single namespace: it becomes default
        - If multiple namespaces: no default, explicit namespace required
        - Cache enabled by default with MemoryCacheBackend (128 queries)

        Example:
            # Single namespace with default memory cache
            uma = UMA.create({
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            })

            # With Redis cache for multi-process deployment
            from namerec.uma.jsql.cache_backend import RedisCacheBackend
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_backend=RedisCacheBackend('redis://localhost:6379/0'),
            )

            # Disable cache
            uma = UMA.create(
                namespace_configs={'main': config},
                cache_enabled=False,
            )
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)

        # Determine default namespace
        default_ns = next(iter(namespace_configs.keys())) if len(namespace_configs) == 1 else None

        # Create registry
        registry = EntityRegistry(default_handler or DefaultEntityHandler)

        # Create default cache backend if not provided
        if cache_backend is None and cache_enabled:
            cache_backend = MemoryCacheBackend(max_size=128)

        return cls(
            registry=registry,
            namespace_configs=namespace_configs,
            default_namespace=default_ns,
            cache_backend=cache_backend,
            cache_enabled=cache_enabled,
        )

    # ========== Public API Methods ==========

    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Read a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Record data as dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.READ, namespace, user_context
        )
        return await params.handler.read(params.entity, id_value, params.context)

    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """
        Save a record (create if id=None, otherwise update).

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            data: Record data
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            ID of saved record

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found (for update)
        """
        # Determine operation (create or update)
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE

        params = await self._prepare_operation(
            entity_name, operation, namespace, user_context
        )
        return await params.handler.save(params.entity, data, params.context)

    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """
        Delete a record by id.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            id_value: Record ID
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            True if deleted

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If record not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.DELETE, namespace, user_context
        )
        return await params.handler.delete(params.entity, id_value, params.context)

    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Get entity metadata.

        Args:
            entity_name: Entity name (can include namespace, e.g., 'virtual:users')
            user_context: User context for access control
            namespace: Optional namespace (if not in entity_name)

        Returns:
            Metadata dictionary

        Raises:
            UMAAccessDeniedError: If access denied
            UMANotFoundError: If entity not found
        """
        params = await self._prepare_operation(
            entity_name, Operation.META, namespace, user_context
        )
        return await params.handler.meta(params.entity, params.context)

    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """
        Get list of all available entities.

        Args:
            user_context: User context for access control
            namespace: Optional namespace filter (None = use default)

        Returns:
            List of entity names (with namespace prefix if not default)

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Create context for namespace
        context = self._create_context(namespace, user_context)

        # Check access (empty entity_name means "list entities" operation)
        self._check_access('', Operation.META, context)

        # Get list from MetadataProvider
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )

        # Format with namespace prefix (if not default)
        if context.namespace != self.default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]

        return entities

    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """
        Execute JSQL query.

        All logic (FROM parsing, namespace resolution, context creation,
        access control) is handled by stateless JSQLExecutor.

        Args:
            jsql: JSQL query dictionary (must contain 'from' field)
            params: Query parameters
            user_context: User context for access control
            namespace: Optional namespace (ignored - namespace from FROM clause is used)

        Returns:
            Dictionary with 'meta' and 'data' keys

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.jsql.executor import JSQLExecutor

        result = await JSQLExecutor.execute(
            jsql=jsql,
            params=params,
            namespace_configs=self.namespace_configs,
            user_context=user_context,
            cache_backend=self.cache_backend if self.cache_enabled else None,
        )

        return result.to_dict()

    # ========== Internal Helper Methods ==========

    async def _prepare_operation(
        self,
        entity_name: str,
        operation: Operation,
        namespace: str | None = None,
        user_context: Any = None,
    ) -> _EntityOperationParams:
        """
        Prepare common parameters for entity operation.

        Args:
            entity_name: Entity name (can include namespace)
            operation: Operation type for access control
            namespace: Optional namespace override
            user_context: User context for access control

        Returns:
            EntityOperationParams with entity, context, and handler

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If namespace not found
        """
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)

        # Create context for namespace
        context = self._create_context(entity.namespace, user_context)

        # Check access
        self._check_access(str(entity), operation, context)

        # Get handler
        handler = await self.registry.get_handler(entity, context)

        return self._EntityOperationParams(entity, context, handler)

    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """
        Create context for operation.

        Args:
            namespace: Namespace name (None = use default)
            user_context: User context for access control
            **extra: Additional context fields

        Returns:
            UMAContext instance

        Raises:
            ValueError: If namespace not found or default not set
            RuntimeError: If cannot determine namespace
        """
        # Get namespace config (resolves default if namespace is None)
        config = self._get_namespace_config(namespace)

        # Determine actual namespace name
        actual_namespace = namespace or self.default_namespace
        if actual_namespace is None:
            msg = 'Cannot determine namespace'
            raise RuntimeError(msg)

        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )

    def _get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.

        Args:
            namespace: Namespace name (None = use default)

        Returns:
            NamespaceConfig for the requested namespace

        Raises:
            ValueError: If namespace not found or default not set when required
        """
        # Resolve namespace
        if namespace is None:
            if self.default_namespace is None:
                msg = (
                    'No default namespace configured. '
                    'Explicit namespace required when multiple namespaces are configured.'
                )
                raise ValueError(msg)
            namespace = self.default_namespace

        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available namespaces: {available}'
            raise ValueError(msg)

        return self.namespace_configs[namespace]

    def _check_access(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> None:
        """
        Check access and raise exception if access denied.

        Args:
            entity_name: Entity name (empty string for "list entities" operation)
            operation: Operation name
            context: Execution context

        Raises:
            UMAAccessDeniedError: If access denied
        """
        from namerec.uma.core.access import check_access

        check_access(
            metadata_provider=context.metadata_provider,
            entity_name=entity_name,
            operation=operation,
            user_context=context.user_context,
        )

    # ========== Cache Management API ==========

    def enable_cache(self) -> None:
        """
        Enable query caching.

        Useful for re-enabling cache after temporary disabling for debugging.

        Example:
            uma.disable_cache()
            # ... debug without cache ...
            uma.enable_cache()
        """
        self.cache_enabled = True

    def disable_cache(self) -> None:
        """
        Disable query caching.

        Useful for debugging when you need to ensure queries hit the database.
        Cache contents are preserved - only lookup is disabled.

        Example:
            # Disable cache for debugging
            uma.disable_cache()
            result = await uma.select({'from': 'users', 'select': ['*']})
            uma.enable_cache()
        """
        self.cache_enabled = False

    def clear_cache(self) -> None:
        """
        Clear all cached queries.

        Use when you need to invalidate cache (e.g., after schema changes).

        Example:
            # After schema migration
            uma.clear_cache()
        """
        if self.cache_backend:
            self.cache_backend.clear()

    def cache_stats(self) -> dict[str, Any]:
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics:
            - backend: Backend type ('memory', 'redis', etc.)
            - size: Current number of cached queries
            - hits: Cache hit count
            - misses: Cache miss count
            - hit_rate: Hit rate (0.0-1.0)
            - Additional backend-specific stats

        Example:
            stats = uma.cache_stats()
            print(f"Cache hit rate: {stats['hit_rate']:.2%}")
            print(f"Cached queries: {stats['size']}")
        """
        if self.cache_backend:
            return self.cache_backend.stats()

        return {
            'backend': 'none',
            'size': 0,
            'hits': 0,
            'misses': 0,
            'hit_rate': 0.0,
        }

```


–ò—Å–ø—Ä–∞–≤–ª—è—é –∫–æ–º–ø–∏–ª—è—Ü–∏—é SQL –≤ `executor.py`:


```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data)
        finally:
            await conn.close()

```


–ò–º–ø–æ—Ä—Ç—ã —Ä–∞–±–æ—Ç–∞—é—Ç. –ü—Ä–æ–≤–µ—Ä—è—é, —á—Ç–æ –∫–æ–¥ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è:



–°–∏–Ω—Ç–∞–∫—Å–∏—Å –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω. –†–µ–∑—é–º–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π:

## –í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è

1. –°–æ–∑–¥–∞–Ω `src/namerec/uma/core/access.py` ‚Äî helper-—Ñ—É–Ω–∫—Ü–∏—è `check_access()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
2. –°–æ–∑–¥–∞–Ω `src/namerec/uma/jsql/entity_extractor.py` ‚Äî —Ñ—É–Ω–∫—Ü–∏—è `extract_select_entities_from_ast()` –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–∑ AST
3. –û–±–Ω–æ–≤–ª–µ–Ω `CachedQuery` ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–ª–µ `entities` –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π –∏–∑ SELECT
4. –û–±–Ω–æ–≤–ª–µ–Ω `make_cache_key()` ‚Äî —É–±—Ä–∞–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä `namespace` (–æ–Ω —É–∂–µ –≤ jsql)
5. –û–±–Ω–æ–≤–ª–µ–Ω `JSQLParser`:
   - –£–±—Ä–∞–Ω `context` –∏–∑ `__init__`
   - –î–æ–±–∞–≤–ª–µ–Ω `namespace_configs`
   - –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `get_namespace_config()`
   - –ú–µ—Ç–æ–¥ `parse()` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `(Select, NamespaceConfig)`
   - –ú–µ—Ç–æ–¥ `_get_table_async()` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `namespace_configs`
6. –û–±–Ω–æ–≤–ª–µ–Ω `JSQLExecutor`:
   - –°–¥–µ–ª–∞–Ω stateless —Å `@classmethod execute()`
   - –ò–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–µ –º–æ–¥—É–ª—è
   - –ò—Å–ø–æ–ª—å–∑—É–µ—Ç `extract_select_entities_from_ast()` –∏ `check_access()`
7. –û–±–Ω–æ–≤–ª–µ–Ω `UMA.select()` ‚Äî —É–ø—Ä–æ—â–µ–Ω, –≤—Å—è –ª–æ–≥–∏–∫–∞ –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∞ –≤ `JSQLExecutor`
8. –£–¥–∞–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã –∏–∑ `UMA`:
   - `_extract_entities_from_jsql()`
   - `_extract_entities_from_expression()`
9. –û–±–Ω–æ–≤–ª–µ–Ω `_check_access()` –≤ `UMA` ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç helper-—Ñ—É–Ω–∫—Ü–∏—é `check_access()`
10. –£–¥–∞–ª–µ–Ω –º–µ—Ä—Ç–≤—ã–π –∫–æ–¥ –≤ –∫–æ–Ω—Ü–µ `UMA.cache_stats()`

–í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–Ω–µ—Å–µ–Ω—ã, —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –ø—Ä–æ–≤–µ—Ä–µ–Ω. –ì–æ—Ç–æ–≤–æ –∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—é.

---

**User**

–ê –ø—Ä–æ—Ö–æ–¥—è—Ç –ª–∏ —É –Ω–∞—Å —Ç–µ—Å—Ç—ã?
–ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω –ª–∏ backend –≤ examples/backend?
–ê–∫—Ç—É–∞–ª—å–Ω–∞ –ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è?

---

**Cursor**


–ü—Ä–æ–≤–µ—Ä—è—é —Ç–µ—Å—Ç—ã, –∑–∞—Ç–µ–º backend –∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é:



–ò—Å–ø—Ä–∞–≤–ª—è—é –ø—Ä–æ–±–ª–µ–º—ã:



–ò—Å–ø—Ä–∞–≤–ª—è—é –ø—Ä–æ–±–ª–µ–º—ã:



–ò—Å–ø—Ä–∞–≤–ª—è—é –ø—Ä–æ–±–ª–µ–º—ã:


```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql, params)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        result = await cls._execute_query(sql_query, params, config.engine)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data)
        finally:
            await conn.close()

```

```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql, params)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        debug_sql = None
        if jsql.get('debug', False):
            debug_sql = cls._compile_query_to_sql(sql_query)

        result = await cls._execute_query(sql_query, params, config.engine, debug_sql)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data)
        finally:
            await conn.close()

```

```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql, params)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        debug_sql = None
        if jsql.get('debug', False):
            debug_sql = cls._compile_query_to_sql(sql_query)

        result = await cls._execute_query(sql_query, params, config.engine, debug_sql)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query, debug_sql)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data)
        finally:
            await conn.close()

```

```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql, params)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                from sqlalchemy import text
                result = await cls._execute_cached_query(cached.sql, params, config.engine)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        debug_sql = None
        if jsql.get('debug', False):
            debug_sql = cls._compile_query_to_sql(sql_query)

        result = await cls._execute_query(sql_query, params, config.engine, debug_sql)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query, debug_sql)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data, debug=debug_sql)
        finally:
            await conn.close()

    @staticmethod
    def _compile_query_to_sql(query: Select) -> str:
        """Compile SQLAlchemy query to SQL string for debug output."""
        import sqlparse

        try:
            # Try to compile with literal binds first (substitute parameters)
            try:
                compiled = query.compile(compile_kwargs={'literal_binds': True})
                sql_str = str(compiled)
            except Exception:
                # Fallback: compile without literal binds if it fails
                compiled = query.compile()
                sql_str = str(compiled)

            # Format SQL for readability
            return sqlparse.format(sql_str, reindent=True, keyword_case='upper')
        except Exception as e:
            # Debug mode should never break query execution
            return f'-- Failed to generate debug SQL: {e!s}'

```

```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql, params)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                debug_sql = None
                if jsql.get('debug', False):
                    # For cached queries, format the cached SQL
                    import sqlparse
                    debug_sql = sqlparse.format(cached.sql, reindent=True, keyword_case='upper')
                result = await cls._execute_cached_query(cached.sql, params, config.engine, debug_sql)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        debug_sql = None
        if jsql.get('debug', False):
            debug_sql = cls._compile_query_to_sql(sql_query)

        result = await cls._execute_query(sql_query, params, config.engine, debug_sql)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query, debug_sql)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data, debug=debug_sql)
        finally:
            await conn.close()

    @staticmethod
    def _compile_query_to_sql(query: Select) -> str:
        """Compile SQLAlchemy query to SQL string for debug output."""
        import sqlparse

        try:
            # Try to compile with literal binds first (substitute parameters)
            try:
                compiled = query.compile(compile_kwargs={'literal_binds': True})
                sql_str = str(compiled)
            except Exception:
                # Fallback: compile without literal binds if it fails
                compiled = query.compile()
                sql_str = str(compiled)

            # Format SQL for readability
            return sqlparse.format(sql_str, reindent=True, keyword_case='upper')
        except Exception as e:
            # Debug mode should never break query execution
            return f'-- Failed to generate debug SQL: {e!s}'

```

```python
"""JSQL executor - executes parsed JSQL queries."""

from collections.abc import Mapping
from typing import Any

from sqlalchemy import Engine
from sqlalchemy.sql.expression import Select

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import Operation
from namerec.uma.jsql.cache.keys import CachedQuery
from namerec.uma.jsql.cache.keys import make_cache_key
from namerec.uma.jsql.cache.protocol import CacheBackend
from namerec.uma.jsql.entity_extractor import extract_select_entities_from_ast
from namerec.uma.jsql.exceptions import JSQLExecutionError
from namerec.uma.jsql.parser import JSQLParser
from namerec.uma.jsql.types import QueryResult


class JSQLExecutor:
    """JSQL query executor - stateless namespace holder."""

    @classmethod
    async def execute(
        cls,
        jsql: dict,
        namespace_configs: Mapping[str, NamespaceConfig],
        user_context: Any = None,
        cache_backend: CacheBackend | None = None,
        params: dict | None = None,
    ) -> QueryResult:
        """
        Execute JSQL with full access control.

        Args:
            jsql: JSQL query dictionary
            namespace_configs: Mapping of namespace names to configurations
            user_context: User context for access control
            cache_backend: Optional cache backend (None = no caching)
            params: Query parameters

        Returns:
            QueryResult with metadata and data

        Raises:
            UMAAccessDeniedError: If access denied
            ValueError: If JSQL invalid or namespace not found
            JSQLSyntaxError: If JSQL syntax is invalid
            JSQLExecutionError: If query execution fails
        """
        from namerec.uma.core.access import check_access

        # Validate FROM field early (before parsing)
        if 'from' not in jsql:
            raise ValueError("JSQL must contain 'from' field")

        # Parse query - returns AST and config (namespace already validated)
        parser = JSQLParser(namespace_configs)
        sql_query, config = await parser.parse(jsql, params)

        # Try cache (namespace already in jsql, so cache key is unique)
        cache_key = None
        if cache_backend:
            cache_key = make_cache_key(jsql, user_context)
            cached = cache_backend.get(cache_key)

            if cached:
                # Check access to SELECT entities (even for cached queries!)
                for select_entity in cached.entities:
                    check_access(
                        metadata_provider=config.metadata_provider,
                        entity_name=select_entity,
                        operation=Operation.SELECT,
                        user_context=user_context,
                    )
                # Execute cached SQL
                debug_sql = None
                if jsql.get('debug', False):
                    # For cached queries, format the cached SQL
                    import sqlparse
                    debug_sql = sqlparse.format(cached.sql, reindent=True, keyword_case='upper')
                result = await cls._execute_cached_query(cached.sql, params, config.engine, debug_sql)
                return result

        # Cache miss - extract entities from AST
        from_entity = jsql.get('from', '')
        select_entities = extract_select_entities_from_ast(sql_query, from_entity)

        # Check access to all SELECT entities
        for select_entity in select_entities:
            check_access(
                metadata_provider=config.metadata_provider,
                entity_name=select_entity,
                operation=Operation.SELECT,
                user_context=user_context,
            )

        # Execute
        debug_sql = None
        if jsql.get('debug', False):
            debug_sql = cls._compile_query_to_sql(sql_query)

        result = await cls._execute_query(sql_query, params, config.engine, debug_sql)

        # Cache result
        if cache_backend and cache_key:
            # Compile query to SQL string with parameter placeholders
            compiled = sql_query.compile()
            cached_query = CachedQuery(
                sql=str(compiled),
                params_mapping={name: name for name in compiled.params.keys()},
                dialect=config.engine.dialect.name,
                entities=select_entities,
            )
            cache_backend.set(cache_key, cached_query)

        return result

    @staticmethod
    async def _execute_query(sql_query: Select, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute SQL query and return result."""
        from namerec.uma.jsql.result import JSQLResultBuilder

        conn = await engine.connect()
        try:
            result = await conn.execute(sql_query, params or {})
            return JSQLResultBuilder.build_result(result, sql_query, debug_sql)
        finally:
            await conn.close()

    @staticmethod
    async def _execute_cached_query(sql: str, params: dict | None, engine: Engine, debug_sql: str | None = None) -> QueryResult:
        """Execute cached SQL query and return result."""
        from sqlalchemy import text

        conn = await engine.connect()
        try:
            result = await conn.execute(text(sql), params or {})
            # For cached queries, metadata is not available
            data = [list(row) for row in result]
            return QueryResult(meta=[], data=data, debug=debug_sql)
        finally:
            await conn.close()

    @staticmethod
    def _compile_query_to_sql(query: Select) -> str:
        """Compile SQLAlchemy query to SQL string for debug output."""
        import sqlparse

        try:
            # Try to compile with literal binds first (substitute parameters)
            try:
                compiled = query.compile(compile_kwargs={'literal_binds': True})
                sql_str = str(compiled)
            except Exception:
                # Fallback: compile without literal binds if it fails
                compiled = query.compile()
                sql_str = str(compiled)

            # Format SQL for readability
            return sqlparse.format(sql_str, reindent=True, keyword_case='upper')
        except Exception as e:
            # Debug mode should never break query execution
            return f'-- Failed to generate debug SQL: {e!s}'

```

```python
"""Alias manager for JSQL/SQL table and column aliases."""

from dataclasses import dataclass
from dataclasses import field
from typing import Any

from sqlalchemy.sql import ColumnElement

from namerec.uma.jsql.exceptions import JSQLSyntaxError


@dataclass
class AliasManager:
    """
    Manages table aliases and column index for JSQL/SQL conversion.

    Provides O(1) column lookup through indexing and consistent
    alias management across parser and converter modules.

    Attributes:
        _table_aliases: Maps alias -> table/CTE object
        _column_index: Maps column_name -> [(source_alias, column), ...]
        _cte_aliases: Maps CTE name -> CTE object
    """

    _table_aliases: dict[str, Any] = field(default_factory=dict, init=False)
    _column_index: dict[str, list[tuple[str, ColumnElement]]] = field(
        default_factory=dict, init=False
    )
    _cte_aliases: dict[str, Any] = field(default_factory=dict, init=False)

    def register_table(
        self,
        alias: str,
        table: Any,
        *additional_aliases: str,
    ) -> None:
        """
        Register table with alias and index its columns.

        Args:
            alias: Primary alias for the table
            table: Table or CTE object
            additional_aliases: Additional aliases for the same table
        """
        # Register primary and additional aliases
        self._table_aliases[alias] = table
        for add_alias in additional_aliases:
            self._table_aliases[add_alias] = table

        # Index columns for fast unqualified lookup
        if hasattr(table, 'columns'):
            for col in table.columns:
                self._index_column(alias, col)

    def register_cte(self, name: str, cte: Any) -> None:
        """
        Register CTE and index its columns.

        Args:
            name: CTE name
            cte: CTE object
        """
        self._cte_aliases[name] = cte

        # Index CTE columns
        if hasattr(cte, 'columns'):
            for col in cte.columns:
                self._index_column(name, col)

    def _index_column(self, source_alias: str, column: ColumnElement) -> None:
        """
        Add column to index for fast lookup.

        Args:
            source_alias: Table/CTE alias
            column: Column object
        """
        col_name = column.name
        if col_name not in self._column_index:
            self._column_index[col_name] = []
        self._column_index[col_name].append((source_alias, column))

    def resolve_column(
        self,
        field_spec: str,
        from_clause: Any | None = None,
    ) -> ColumnElement:
        """
        Resolve column reference with O(1) lookup.

        Handles both qualified (table.column) and unqualified (column) references.

        Args:
            field_spec: Column name or qualified name (table.column)
            from_clause: Optional FROM clause for fallback lookup

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If column not found or ambiguous
        """
        # Qualified column (table.column)
        if '.' in field_spec:
            return self._resolve_qualified_column(field_spec)

        # Unqualified column - use index for O(1) lookup
        return self._resolve_unqualified_column(field_spec, from_clause)

    def _resolve_qualified_column(self, field_spec: str) -> ColumnElement:
        """
        Resolve qualified column reference (table.column).

        Args:
            field_spec: Qualified column name (table.column)

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If column not found
        """
        table_name, col_name = field_spec.split('.', 1)

        # Check table aliases
        if table_name in self._table_aliases:
            table = self._table_aliases[table_name]
            if hasattr(table, 'columns') and col_name in table.columns:
                return table.columns[col_name]

        # Check CTEs
        if table_name in self._cte_aliases:
            cte = self._cte_aliases[table_name]
            if hasattr(cte, 'columns') and col_name in cte.columns:
                return cte.columns[col_name]

        raise JSQLSyntaxError(
            f'Column "{col_name}" not found in table "{table_name}"'
        )

    def _resolve_unqualified_column(
        self,
        field_spec: str,
        from_clause: Any | None,
    ) -> ColumnElement:
        """
        Resolve unqualified column reference using index.

        Args:
            field_spec: Column name (unqualified)
            from_clause: Optional FROM clause for fallback

        Returns:
            Resolved column element

        Raises:
            JSQLSyntaxError: If column not found or ambiguous
        """
        # Check column index
        if field_spec in self._column_index:
            candidates = self._column_index[field_spec]

            # Unambiguous - single source
            if len(candidates) == 1:
                return candidates[0][1]

            # Ambiguous - multiple sources
            sources = [alias for alias, _ in candidates]
            raise JSQLSyntaxError(
                f'Ambiguous column "{field_spec}" found in: {", ".join(sources)}. '
                f'Use qualified name (e.g., {sources[0]}.{field_spec})'
            )

        # Fallback to FROM clause
        if from_clause is not None:
            try:
                if hasattr(from_clause, 'columns') and field_spec in from_clause.columns:
                    return from_clause.columns[field_spec]
            except (TypeError, AttributeError):
                # SQLAlchemy ClauseElement doesn't support bool() or columns access
                pass

        raise JSQLSyntaxError(f'Column "{field_spec}" not found')

    def get_table(self, alias: str) -> Any | None:
        """
        Get table by alias.

        Args:
            alias: Table or CTE alias

        Returns:
            Table/CTE object or None if not found
        """
        return self._table_aliases.get(alias) or self._cte_aliases.get(alias)

    def has_alias(self, alias: str) -> bool:
        """
        Check if alias is registered.

        Args:
            alias: Alias to check

        Returns:
            True if alias exists, False otherwise
        """
        return alias in self._table_aliases or alias in self._cte_aliases

    def clear(self) -> None:
        """Clear all aliases and indexes."""
        self._table_aliases.clear()
        self._column_index.clear()
        self._cte_aliases.clear()

```

```python
"""Tests for JSQL query caching."""

import pytest
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import MetaData
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy import create_engine

from namerec.uma.application import UMA
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.jsql.cache import CachedQuery
from namerec.uma.jsql.cache import make_cache_key
from namerec.uma.jsql.cache import MemoryCacheBackend
from namerec.uma.metadata.provider import DefaultMetadataProvider


@pytest.fixture
def test_engine():
    """Create in-memory SQLite engine for testing."""
    from sqlalchemy.ext.asyncio import create_async_engine

    engine = create_async_engine('sqlite+aiosqlite:///:memory:', future=True)

    # Create test table synchronously
    from sqlalchemy import create_engine as create_sync_engine

    sync_engine = create_sync_engine('sqlite:///:memory:', future=True)
    metadata = MetaData()
    users_table = Table(
        'users',
        metadata,
        Column('id', Integer, primary_key=True),
        Column('name', String(50)),
        Column('email', String(100)),
    )
    metadata.create_all(sync_engine)

    # Insert test data
    with sync_engine.connect() as conn:
        conn.execute(
            users_table.insert(),
            [
                {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'},
                {'id': 2, 'name': 'Bob', 'email': 'bob@example.com'},
            ],
        )
        conn.commit()

    # Copy database to async engine
    # For SQLite in-memory, we need to use a file-based DB for async
    import tempfile
    import shutil

    # Create temp file
    temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
    temp_db.close()

    # Create schema and data in temp file
    file_engine = create_sync_engine(f'sqlite:///{temp_db.name}', future=True)
    metadata.create_all(file_engine)
    with file_engine.connect() as conn:
        conn.execute(
            users_table.insert(),
            [
                {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'},
                {'id': 2, 'name': 'Bob', 'email': 'bob@example.com'},
            ],
        )
        conn.commit()

    # Create async engine for temp file
    async_engine = create_async_engine(f'sqlite+aiosqlite:///{temp_db.name}', future=True)

    yield async_engine

    # Cleanup
    import os
    import asyncio

    asyncio.run(async_engine.dispose())
    os.unlink(temp_db.name)


@pytest.fixture
def uma_with_cache(test_engine):
    """Create UMA instance with memory cache."""
    return UMA.create(
        namespace_configs={
            'main': NamespaceConfig(
                engine=test_engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        },
        cache_backend=MemoryCacheBackend(max_size=10),
    )


@pytest.fixture
def uma_without_cache(test_engine):
    """Create UMA instance without cache."""
    return UMA.create(
        namespace_configs={
            'main': NamespaceConfig(
                engine=test_engine,
                metadata_provider=DefaultMetadataProvider(),
            ),
        },
        cache_enabled=False,
    )


class TestCacheKey:
    """Test cache key generation."""

    def test_same_jsql_same_key(self):
        """Same JSQL should produce same key."""
        jsql = {'from': 'users', 'select': ['id', 'name']}
        key1 = make_cache_key(jsql)
        key2 = make_cache_key(jsql)
        assert key1 == key2

    def test_different_jsql_different_key(self):
        """Different JSQL should produce different keys."""
        jsql1 = {'from': 'users', 'select': ['id', 'name']}
        jsql2 = {'from': 'users', 'select': ['id', 'email']}
        key1 = make_cache_key(jsql1)
        key2 = make_cache_key(jsql2)
        assert key1 != key2

    def test_user_context_affects_key(self):
        """Different user contexts should produce different keys."""
        jsql = {'from': 'users', 'select': ['id', 'name']}
        key1 = make_cache_key(jsql, user_context={'role': 'admin'})
        key2 = make_cache_key(jsql, user_context={'role': 'user'})
        assert key1 != key2

    def test_namespace_affects_key(self):
        """Different namespaces should produce different keys."""
        jsql1 = {'from': 'db1:users', 'select': ['id', 'name']}
        jsql2 = {'from': 'db2:users', 'select': ['id', 'name']}
        key1 = make_cache_key(jsql1)
        key2 = make_cache_key(jsql2)
        assert key1 != key2

    def test_key_is_compact(self):
        """Cache key should be compact (32 hex chars)."""
        jsql = {'from': 'users', 'select': ['id', 'name']}
        key = make_cache_key(jsql)
        assert len(key) == 32  # 16 bytes = 32 hex chars
        assert all(c in '0123456789abcdef' for c in key)


class TestMemoryCacheBackend:
    """Test memory cache backend."""

    def test_cache_miss(self):
        """First access should be cache miss."""
        cache = MemoryCacheBackend(max_size=10)
        result = cache.get('test_key')
        assert result is None

    def test_cache_hit(self):
        """Second access should be cache hit."""
        cache = MemoryCacheBackend(max_size=10)
        query = CachedQuery(
            sql='SELECT * FROM users',
            params_mapping={},
            dialect='sqlite',
        )
        cache.set('test_key', query)
        result = cache.get('test_key')
        assert result is not None
        assert result.sql == 'SELECT * FROM users'

    def test_lru_eviction(self):
        """Oldest entry should be evicted when cache full."""
        cache = MemoryCacheBackend(max_size=2)
        query1 = CachedQuery(sql='SELECT 1', params_mapping={}, dialect='sqlite')
        query2 = CachedQuery(sql='SELECT 2', params_mapping={}, dialect='sqlite')
        query3 = CachedQuery(sql='SELECT 3', params_mapping={}, dialect='sqlite')

        cache.set('key1', query1)
        cache.set('key2', query2)
        cache.set('key3', query3)  # Should evict key1

        assert cache.get('key1') is None  # Evicted
        assert cache.get('key2') is not None
        assert cache.get('key3') is not None

    def test_stats(self):
        """Stats should track hits/misses."""
        cache = MemoryCacheBackend(max_size=10)
        query = CachedQuery(sql='SELECT 1', params_mapping={}, dialect='sqlite')

        cache.set('key1', query)
        cache.get('key1')  # Hit
        cache.get('key2')  # Miss

        stats = cache.stats()
        assert stats['backend'] == 'memory'
        assert stats['size'] == 1
        assert stats['hits'] == 1
        assert stats['misses'] == 1
        assert stats['hit_rate'] == 0.5

    def test_clear(self):
        """Clear should remove all entries."""
        cache = MemoryCacheBackend(max_size=10)
        query = CachedQuery(sql='SELECT 1', params_mapping={}, dialect='sqlite')

        cache.set('key1', query)
        cache.set('key2', query)
        cache.clear()

        assert cache.get('key1') is None
        assert cache.get('key2') is None
        assert cache.stats()['size'] == 0


class TestCachedQuery:
    """Test CachedQuery serialization."""

    def test_to_dict(self):
        """Should serialize to dict."""
        query = CachedQuery(
            sql='SELECT * FROM users WHERE id = :id',
            params_mapping={'id': 'id'},
            dialect='postgresql',
        )
        data = query.to_dict()
        assert data['sql'] == 'SELECT * FROM users WHERE id = :id'
        assert data['params_mapping'] == {'id': 'id'}
        assert data['dialect'] == 'postgresql'

    def test_from_dict(self):
        """Should deserialize from dict."""
        data = {
            'sql': 'SELECT * FROM users WHERE id = :id',
            'params_mapping': {'id': 'id'},
            'dialect': 'postgresql',
        }
        query = CachedQuery.from_dict(data)
        assert query.sql == 'SELECT * FROM users WHERE id = :id'
        assert query.params_mapping == {'id': 'id'}
        assert query.dialect == 'postgresql'


@pytest.mark.asyncio
class TestUMACacheIntegration:
    """Test UMA cache integration."""

    async def test_cache_enabled_by_default(self, uma_with_cache):
        """Cache should be enabled by default."""
        assert uma_with_cache.cache_enabled is True
        assert uma_with_cache.cache_backend is not None

    async def test_cache_disabled(self, uma_without_cache):
        """Cache can be disabled."""
        assert uma_without_cache.cache_enabled is False

    async def test_query_caching(self, uma_with_cache):
        """Repeated queries should hit cache."""
        jsql = {'from': 'users', 'select': ['id', 'name']}

        # First query - cache miss
        result1 = await uma_with_cache.select(jsql)
        stats1 = uma_with_cache.cache_stats()
        assert stats1['misses'] == 1

        # Second query - cache hit
        result2 = await uma_with_cache.select(jsql)
        stats2 = uma_with_cache.cache_stats()
        assert stats2['hits'] == 1

        # Data should be identical (metadata may differ for cached queries)
        assert result1['data'] == result2['data']

    async def test_disable_cache(self, uma_with_cache):
        """Disabling cache should bypass cache lookup."""
        jsql = {'from': 'users', 'select': ['id', 'name']}

        # First query - populate cache
        await uma_with_cache.select(jsql)

        # Disable cache
        uma_with_cache.disable_cache()

        # Query should not hit cache
        await uma_with_cache.select(jsql)
        stats = uma_with_cache.cache_stats()
        assert stats['hits'] == 0  # No hits after disabling

    async def test_enable_cache(self, uma_with_cache):
        """Re-enabling cache should restore caching."""
        jsql = {'from': 'users', 'select': ['id', 'name']}

        uma_with_cache.disable_cache()
        await uma_with_cache.select(jsql)

        uma_with_cache.enable_cache()
        await uma_with_cache.select(jsql)  # Miss
        await uma_with_cache.select(jsql)  # Hit

        stats = uma_with_cache.cache_stats()
        assert stats['hits'] == 1

    async def test_clear_cache(self, uma_with_cache):
        """Clear should invalidate all cached queries."""
        jsql = {'from': 'users', 'select': ['id', 'name']}

        # Populate cache
        await uma_with_cache.select(jsql)
        stats1 = uma_with_cache.cache_stats()
        assert stats1['size'] == 1

        # Clear cache (also resets stats)
        uma_with_cache.clear_cache()
        stats2 = uma_with_cache.cache_stats()
        assert stats2['size'] == 0
        assert stats2['hits'] == 0
        assert stats2['misses'] == 0

        # Next query should be cache miss
        await uma_with_cache.select(jsql)
        stats3 = uma_with_cache.cache_stats()
        assert stats3['misses'] == 1  # New miss after clear

    async def test_cache_stats(self, uma_with_cache):
        """Cache stats should provide useful metrics."""
        jsql = {'from': 'users', 'select': ['id', 'name']}

        # Initial stats
        stats0 = uma_with_cache.cache_stats()
        assert stats0['backend'] == 'memory'
        assert stats0['size'] == 0
        assert stats0['hits'] == 0
        assert stats0['misses'] == 0

        # After queries
        await uma_with_cache.select(jsql)  # Miss
        await uma_with_cache.select(jsql)  # Hit

        stats1 = uma_with_cache.cache_stats()
        assert stats1['size'] == 1
        assert stats1['hits'] == 1
        assert stats1['misses'] == 1
        assert stats1['hit_rate'] == 0.5


class TestRedisCacheBackend:
    """Test Redis cache backend (requires redis)."""

    def test_redis_import(self):
        """Redis backend should be importable."""
        try:
            from namerec.uma.jsql.cache.redis import RedisCacheBackend

            backend = RedisCacheBackend('redis://localhost:6379/0')
            assert backend is not None
        except ImportError:
            pytest.skip('redis package not installed')
        except Exception:
            # Connection error is OK - we just test import
            pass

```


–ò—Å–ø—Ä–∞–≤–ª—è—é `extract_select_entities_from_ast` ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º `selected_columns` –≤–º–µ—Å—Ç–æ —É—Å—Ç–∞—Ä–µ–≤—à–µ–≥–æ `columns`:


```python
"""Entity extraction from SQLAlchemy AST."""

from typing import Any

from sqlalchemy.sql.expression import ColumnElement
from sqlalchemy.sql.expression import Select
from sqlalchemy import Table


def extract_select_entities_from_ast(select_ast: Select, from_entity: str) -> list[str]:
    """
    Extract entities from SELECT clause using SQLAlchemy AST.

    Pure function - no state, no side effects.

    Args:
        select_ast: Parsed SQLAlchemy SELECT statement
        from_entity: Entity name from FROM clause (for '*' resolution)

    Returns:
        List of entity names (qualified with namespace if present)
    """
    entities: set[str] = set()

    # Extract from SELECT clause columns (use selected_columns instead of deprecated columns)
    for column in select_ast.selected_columns:
        if isinstance(column, str):
            if column == '*' or '.' not in column:
                entities.add(from_entity)
            else:
                entity_part = column.split('.', 1)[0]
                entities.add(entity_part)

        elif isinstance(column, ColumnElement):
            # Column expression - extract from table
            if hasattr(column, 'table') and column.table is not None:
                table = column.table
                if isinstance(table, Table):
                    entities.add(table.name)
                else:
                    entities.add(str(table))

        elif isinstance(column, Select):
            # Subquery in SELECT - extract recursively
            subquery_entities = extract_select_entities_from_ast(column, from_entity)
            entities.update(subquery_entities)

    return list(entities)

```


–ü—Ä–æ–≤–µ—Ä—è—é –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ —Ç–µ—Å—Ç—ã:



–ó–∞–ø—É—Å–∫–∞—é –≤—Å–µ —Ç–µ—Å—Ç—ã:



–í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç. –ü—Ä–æ–≤–µ—Ä—è—é backend –≤ examples:



–ü—Ä–æ–≤–µ—Ä—è—é –∏–º–ø–æ—Ä—Ç—ã –≤ backend:



–ü—Ä–æ–≤–µ—Ä—è—é, —á—Ç–æ –≤—Å–µ –∏–º–ø–æ—Ä—Ç—ã –¥–æ—Å—Ç—É–ø–Ω—ã –∏–∑ `namerec.uma`:



–ü—Ä–æ–≤–µ—Ä—è—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é:



–ü—Ä–æ–≤–µ—Ä—è—é –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:



–ü—Ä–æ–≤–µ—Ä—è—é, —á—Ç–æ –ø—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç:



–ü—Ä–æ–≤–µ—Ä—è—é —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –ø—Ä–∏–º–µ—Ä–æ–≤:



## –ò—Ç–æ–≥–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏

### 1. –¢–µ—Å—Ç—ã ‚Äî –ø—Ä–æ—Ö–æ–¥—è—Ç

```
72 passed in 0.89s
```

–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:
- `test_namespace_affects_key` ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è –Ω–æ–≤–æ–≥–æ API `make_cache_key()`
- `test_query_parameters` ‚Äî –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ `parser.parse()`
- `test_invalid_jsql_missing_from` ‚Äî —Ä–∞–Ω–Ω—è—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤ `executor.execute()`
- `test_invalid_jsql_unknown_column` ‚Äî –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ `from_clause` –≤ `alias_manager`
- `test_debug_mode` –∏ `test_debug_mode_with_in_operator` ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ debug SQL

### 2. Backend –≤ examples/backend ‚Äî –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω

- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ–≤—ã–π API: `UMA.create()`, `uma.select()`, `uma.read()`, etc.
- –ò–º–ø–æ—Ä—Ç—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã: `from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig`
- –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã —á–µ—Ä–µ–∑ DI container
- –í—Å–µ –∏–º–ø–æ—Ä—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç –ø—Ä–æ–≤–µ—Ä–∫—É

### 3. –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è ‚Äî —á–∞—Å—Ç–∏—á–Ω–æ —É—Å—Ç–∞—Ä–µ–ª–∞

–ü—Ä–æ–±–ª–µ–º—ã:
- `docs/20260104-195802-doc-QUICKSTART.md` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å—Ç–∞—Ä—ã–π API:
  - `initialize_uma()` ‚Üí –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å `UMA.create()`
  - `uma_read()`, `uma_save()` ‚Üí –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å `uma.read()`, `uma.save()`
  - `uma_meta()`, `uma_list_entities()` ‚Üí –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å `uma.entity_details()`, `uma.entity_list()`

–ß—Ç–æ –∞–∫—Ç—É–∞–ª—å–Ω–æ:
- `examples/api_usage.py` ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ–≤—ã–π API
- `examples/basic_usage.py` ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ–≤—ã–π API
- `examples/jsql_usage.py` ‚Äî –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
- `README.md` ‚Äî –æ–±—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ

–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:
1. –û–±–Ω–æ–≤–∏—Ç—å `QUICKSTART.md` –ø–æ–¥ –Ω–æ–≤—ã–π API
2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã –≤ `docs/`
3. –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–º–µ—Ä—ã –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏

–ò—Ç–æ–≥: –∫–æ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç, backend –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω, –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —Ç—Ä–µ–±—É–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.

```plaintext
72 passed in 0.89s
```

---

**User**

–î–∞, –¥–∞–≤–∞–π –æ–±–Ω–æ–≤–∏–º –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é.
–°–ª–µ–¥—É–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç—ã –≤ —Ñ–∞–π–ª–∞—Ö –∫–∞—Ç–∞–ª–æ–≥–∞ `docs`, —Å–æ–¥–µ—Ä–∂–∞—â–∏—Ö –º–µ—Ç–∫—É `-doc-` –≤ –∏–º–µ–Ω–∏.

---

**Cursor**


–ò—â—É —Ñ–∞–π–ª—ã —Å –º–µ—Ç–∫–æ–π `-doc-` –≤ `docs`:



–ü—Ä–æ–≤–µ—Ä—è—é –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã:



–û–±–Ω–æ–≤–ª—è—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é, –Ω–∞—á–∏–Ω–∞—è —Å QUICKSTART.md:



–û–±–Ω–æ–≤–ª—è—é –≤—Å–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã. –ù–∞—á–∏–Ω–∞—é —Å QUICKSTART.md:


```markdown
# UMA Quick Start Guide

This guide will help you get started with UMA (Unified Model Access) in just a few minutes.

## Installation

### Using uv (recommended)

```bash
# Clone the repository
git clone <repository-url>
cd uma2

# Install dependencies
uv sync

# Install with dev dependencies
uv sync --dev
```

### Using pip

```bash
pip install -e .

# With dev dependencies
pip install -e ".[dev]"
```

## Basic Usage

UMA provides a high-level API through the `UMA` class for working with database entities.

### 1. Setup Database and Schema

```python
from sqlalchemy import Column, Integer, String, MetaData, Table
from sqlalchemy.ext.asyncio import create_async_engine

# Define schema
metadata = MetaData()

users = Table(
    'users',
    metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(100)),
    Column('email', String(100)),
)

# Create async engine
engine = create_async_engine('sqlite+aiosqlite:///test.db')

# Create tables
async with engine.begin() as conn:
    await conn.run_sync(metadata.create_all)
```

### 2. Initialize UMA

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

# Create metadata provider
metadata_provider = DefaultMetadataProvider()

# Initialize UMA (call once at application startup)
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})
```

### 3. Work with Entities

```python
# List all entities
entities = await uma.entity_list()
print(f"Available: {entities}")

# Get metadata
user_meta = await uma.entity_details('users')
print(f"Columns: {[col['name'] for col in user_meta['columns']]}")

# Create record
user_id = await uma.save(
    'users',
    {'name': 'John Doe', 'email': 'john@example.com'}
)

# Read record
user = await uma.read('users', user_id)
print(f"User: {user}")

# Update record
await uma.save(
    'users',
    {'id': user_id, 'name': 'John Smith', 'email': 'john.smith@example.com'}
)

# Delete record
await uma.delete('users', user_id)
```

### 4. Add Access Control

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    """Custom provider with access control."""
    
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        user_context: Any,
    ) -> bool:
        """Check access based on user role."""
        if not user_context:
            return False
        
        # Admin can do everything
        if user_context.role == 'admin':
            return True
        
        # Regular user: read only
        if user_context.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False

# Initialize with custom provider
metadata_provider = MyMetadataProvider()
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})

# Use with user context
class User:
    def __init__(self, role):
        self.role = role

admin = User(role='admin')
regular_user = User(role='user')

# Admin can write
await uma.save(
    'users',
    {'name': 'Admin User'},
    user_context=admin,
)

# Regular user can only read
user = await uma.read('users', 1, user_context=regular_user)

# Regular user cannot write (raises UMAAccessDeniedError)
try:
    await uma.save('users', {'name': 'Hacker'}, user_context=regular_user)
except UMAAccessDeniedError:
    print("Access denied!")
```

### 5. Create Virtual View

```python
from namerec.uma import VirtualViewHandler, copy_field_meta
from sqlalchemy import select, func

class UserStatsView(VirtualViewHandler):
    """Virtual view with user statistics."""
    
    description = "User statistics"
    
    @classmethod
    async def select(cls, entity_name, params, context):
        users = context.metadata.tables['users']
        
        query = select(
            users.c.id,
            users.c.name,
            func.length(users.c.email).label('email_length')
        )
        
        return query
    
    @classmethod
    async def meta(cls, entity_name, context, registry):
        columns_metadata = [
            await copy_field_meta('users', 'id', context, registry),
            await copy_field_meta('users', 'name', context, registry),
            {
                'name': 'email_length',
                'type': 'integer',
                'description': 'Length of email'
            }
        ]
        
        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': columns_metadata
        }

# Register virtual view
uma.registry.register('user_stats', UserStatsView)

# Use virtual view
view_meta = await uma.entity_details('user_stats')
```

### 6. Using JSQL Queries

UMA supports complex queries using JSQL (JSON-SQL) format:

```python
# Simple query with WHERE
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name', 'email'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        },
        'order_by': [{'field': 'name', 'direction': 'asc'}],
        'limit': 10
    },
    user_context=current_user
)

# Result format
# {
#     'meta': [
#         {'name': 'id', 'type': 'INTEGER', 'nullable': False, ...},
#         {'name': 'name', 'type': 'VARCHAR(255)', 'nullable': False, ...},
#         ...
#     ],
#     'data': [
#         [1, 'Alice', 'alice@example.com'],
#         [2, 'Bob', 'bob@example.com'],
#         ...
#     ]
# }
```

JSQL supports:
- Complex WHERE conditions with AND/OR/NOT
- JOINs (INNER, LEFT, RIGHT, FULL)
- Aggregations (COUNT, SUM, AVG, MIN, MAX)
- GROUP BY and HAVING
- ORDER BY (including by column aliases)
- Window functions
- CTEs (Common Table Expressions)
- Subqueries and parameterized queries

For complete JSQL syntax and examples, see [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md).

## Running Examples

```bash
# Run API usage example (recommended)
uv run python examples/api_usage.py

# Run basic usage example
uv run python examples/basic_usage.py

# Run JSQL usage example
uv run python examples/jsql_usage.py
```

## Running Tests

```bash
# Run all tests
uv run pytest

# Run with coverage
uv run pytest --cov=namerec.uma

# Run specific test
uv run pytest tests/test_basic.py::test_parse_entity_name
```

## Code Quality

```bash
# Run Ruff linter
ruff check src/

# Run Ruff formatter
ruff format src/

# Run MyPy type checker
mypy src/
```

## Common Patterns

### Pattern 1: Entity with Access Control

```python
class SecureEntityHandler(DefaultEntityHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        query = await super().select(entity_name, params, context)
        
        # Apply row-level security
        user_role = context.user_context.get('role')
        if user_role != 'admin':
            table = context.metadata.tables[entity_name.entity]
            query = query.where(table.c.is_public == True)
        
        return query
```

### Pattern 2: Computed Fields in Virtual View

```python
class ComputedView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        table = context.metadata.tables['products']
        
        return select(
            table.c.id,
            table.c.price,
            (table.c.price * 1.2).label('price_with_tax')
        )
```

### Pattern 3: Custom Metadata Provider

```python
class RedisMetadataProvider:
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def get_metadata(self, entity_name, context):
        key = f"uma:meta:{entity_name}"
        data = await self.redis.get(key)
        return json.loads(data) if data else {}

# Use in UMA initialization
metadata_provider = RedisMetadataProvider(redis_client)
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})
```

## Next Steps

- Read the [README.md](../README.md) for project overview
- Check [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md) for query syntax
- Review [API Summary](20260104-195632-doc-API_SUMMARY.md) for complete API reference
- Explore [examples/jsql_usage.py](../examples/jsql_usage.py) for JSQL examples
- Check [PROJECT_STRUCTURE.md](20260104-195714-doc-PROJECT_STRUCTURE.md) for architecture details

## Troubleshooting

### Import Error

If you get import errors, make sure you're using the correct import path:

```python
# Correct
from namerec.uma import UMA, NamespaceConfig

# Wrong
from uma import UMA
```

### Async Engine Required

UMA uses async operations. Make sure to use async engine:

```python
# Correct
from sqlalchemy.ext.asyncio import create_async_engine
engine = create_async_engine('sqlite+aiosqlite:///test.db')

# Wrong
from sqlalchemy import create_engine
engine = create_engine('sqlite:///test.db')
```

### UMA Not Initialized

If you get errors about UMA, make sure to initialize it:

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

## Support

For questions and issues, please refer to the project documentation or create an issue in the repository.

```


–û–±–Ω–æ–≤–ª—è—é API_SUMMARY.md:


```markdown
# UMA API Summary

## Overview

The UMA API provides a high-level interface for working with database entities through the `UMA` class. All API methods support access control, user context, and namespace isolation.

## Initialization

### `UMA.create()`

Initialize UMA at application startup.

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig
from sqlalchemy.ext.asyncio import create_async_engine

engine = create_async_engine('sqlite+aiosqlite:///test.db')
metadata_provider = DefaultMetadataProvider()

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=metadata_provider,
    ),
})
```

**Returns**: `UMA` instance

**Required**: Call once before using other API methods.

**Multiple Namespaces**: You can configure multiple namespaces:

```python
uma = UMA.create({
    'db1': NamespaceConfig(engine=engine1, metadata_provider=provider1),
    'db2': NamespaceConfig(engine=engine2, metadata_provider=provider2),
})
```

## Core API Methods

### `uma.read()`

Read a single record by ID.

```python
user = await uma.read(
    entity_name='users',        # Entity name
    id_value=123,              # Record ID
    user_context=current_user, # Optional: for access control
    namespace=None,            # Optional: entity namespace
)
```

**Returns**: `dict` with record data

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found

### `uma.save()`

Create or update a record.

```python
# Create (no id)
user_id = await uma.save(
    entity_name='users',
    data={'name': 'John', 'email': 'john@example.com'},
    user_context=current_user,
)

# Update (with id)
await uma.save(
    entity_name='users',
    data={'id': 123, 'name': 'John Smith'},
    user_context=current_user,
)
```

**Returns**: ID of saved record

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found (for update)

### `uma.delete()`

Delete a record by ID.

```python
deleted = await uma.delete(
    entity_name='users',
    id_value=123,
    user_context=current_user,
)
```

**Returns**: `bool` - True if deleted

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Record not found

### `uma.entity_details()`

Get entity metadata (columns, types, descriptions).

```python
metadata = await uma.entity_details(
    entity_name='users',
    user_context=current_user,
)

# Access metadata
print(metadata['name'])         # Entity name
print(metadata['description'])  # Description
for col in metadata['columns']:
    print(col['name'], col['type'])
```

**Returns**: `dict` with metadata

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `UMANotFoundError` - Entity not found

### `uma.entity_list()`

List all available entities.

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace=None,  # Optional: filter by namespace
)

print(entities)  # ['users', 'orders', 'virtual:user_summary', ...]
```

**Returns**: `list[str]` - Entity names

**Raises**: 
- `UMAAccessDeniedError` - Access denied

### `uma.select()` ‚úÖ

Execute JSQL (JSON-SQL) query.

```python
# Simple SELECT with WHERE
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name', 'email'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    user_context=current_user,
)

# With parameters
result = await uma.select(
    jsql={
        'from': 'orders',
        'select': ['id', 'amount'],
        'where': {
            'op': '>',
            'left': {'field': 'amount'},
            'right': {'param': 'min_amount'}
        }
    },
    params={'min_amount': 100},
    user_context=current_user,
)

# With debug mode
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'debug': True  # Include generated SQL in result
    },
    user_context=current_user,
)
# result['debug'] contains formatted SQL
```

**Returns**: Dictionary with `meta` and `data` keys:
- `meta`: List of column metadata (name, type, nullable, qualified_name, etc.)
- `data`: List of rows (each row is a list of values)
- `debug`: Optional formatted SQL string (if `debug: true` in JSQL)

**Raises**: 
- `UMAAccessDeniedError` - Access denied
- `JSQLSyntaxError` - Invalid JSQL syntax
- `JSQLExecutionError` - Query execution failed

**Documentation**: See [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md) for complete syntax and examples.

**Supported Features**:
- SELECT with fields and aliases
- WHERE with all operators (=, !=, <, >, <=, >=, AND, OR, NOT, IN, LIKE, EXISTS, IS NULL)
- JOINs (INNER, LEFT, RIGHT, FULL)
- Aggregations (COUNT, SUM, AVG, MIN, MAX)
- GROUP BY and HAVING
- ORDER BY (including by aliases)
- LIMIT and OFFSET
- CTEs (Common Table Expressions)
- Subqueries
- Window functions (ROW_NUMBER, RANK, etc.)
- Parameterized queries

## Access Control

### Implementing Custom Access Control

Create a custom `MetadataProvider` with `can()` method:

```python
from namerec.uma import DefaultMetadataProvider, Operation

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        user_context: Any,
    ) -> bool:
        """Check access based on user role."""
        if not user_context:
            return False
        
        # Admin can do everything
        if user_context.role == 'admin':
            return True
        
        # Regular user: read-only
        if user_context.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        # Default: deny
        return False

# Use in initialization
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=MyMetadataProvider(),
    ),
})
```

### Operations

Available operations for access control:

- `Operation.SELECT` - JSQL query execution
- `Operation.READ` - Read single record
- `Operation.CREATE` - Create new record
- `Operation.UPDATE` - Update existing record
- `Operation.DELETE` - Delete record
- `Operation.META` - Get metadata
- `Operation.LIST` - List entities

## User Context

Pass user information for access control:

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

current_user = User(user_id=123, role='user')

# Use in API calls
user_data = await uma.read('users', 456, user_context=current_user)
```

The `user_context` can be any object - it's passed to `can()` method in `MetadataProvider`.

## Namespaces

Use namespaces to organize entities:

```python
# In entity name
await uma.read('virtual:user_summary', 1)

# As parameter
await uma.read('user_summary', 1, namespace='virtual')

# List by namespace
entities = await uma.entity_list(namespace='virtual')
```

## Error Handling

```python
from namerec.uma import (
    UMAAccessDeniedError,
    UMANotFoundError,
    UMAError,
)

try:
    user = await uma.read('users', 123, user_context=current_user)
except UMAAccessDeniedError as e:
    print(f"Access denied: {e}")
except UMANotFoundError as e:
    print(f"Not found: {e}")
except UMAError as e:
    print(f"UMA error: {e}")
```

## Virtual Views

Register virtual views for computed data:

```python
from namerec.uma import VirtualViewHandler
from sqlalchemy import select, func

class UserStatsView(VirtualViewHandler):
    description = "User statistics"
    
    @classmethod
    async def select(cls, entity_name, params, context):
        users = context.metadata.tables['users']
        return select(
            users.c.id,
            func.count().label('record_count')
        ).group_by(users.c.id)
    
    @classmethod
    async def meta(cls, entity_name, context, registry):
        return {
            'name': str(entity_name),
            'description': cls.description,
            'is_virtual_view': True,
            'columns': [
                {'name': 'id', 'type': 'integer'},
                {'name': 'record_count', 'type': 'integer'},
            ]
        }

# Register
uma.registry.register('user_stats', UserStatsView)

# Use like regular entity
stats = await uma.entity_details('user_stats')
```

## Cache Management

UMA supports query caching for JSQL queries:

```python
from namerec.uma.jsql.cache import MemoryCacheBackend

# Enable cache
cache_backend = MemoryCacheBackend(max_size=1000)
uma = UMA.create(
    {
        'main': NamespaceConfig(
            engine=engine,
            metadata_provider=metadata_provider,
        ),
    },
    cache_backend=cache_backend,
)

# Cache operations
uma.enable_cache()   # Enable caching
uma.disable_cache()  # Disable caching
uma.clear_cache()    # Clear all cached queries
stats = uma.cache_stats()  # Get cache statistics
```

## Best Practices

1. **Initialize Once**: Call `UMA.create()` at application startup
2. **Use Access Control**: Always implement `can()` method for security
3. **Pass User Context**: Include `user_context` in all API calls
4. **Handle Errors**: Catch and handle UMA exceptions properly
5. **Use Namespaces**: Organize entities with namespaces for clarity
6. **Virtual Views**: Use for computed/aggregated data
7. **Async/Await**: All API methods are async - use `await`

## Complete Example

```python
import asyncio
from sqlalchemy import Column, Integer, String, MetaData, Table
from sqlalchemy.ext.asyncio import create_async_engine
from namerec.uma import (
    UMA,
    DefaultMetadataProvider,
    NamespaceConfig,
    UMAAccessDeniedError,
)

async def main():
    # Setup
    engine = create_async_engine('sqlite+aiosqlite:///test.db')
    metadata = MetaData()
    Table('users', metadata,
          Column('id', Integer, primary_key=True),
          Column('name', String(100)))
    
    async with engine.begin() as conn:
        await conn.run_sync(metadata.create_all)
    
    # Initialize UMA
    uma = UMA.create({
        'main': NamespaceConfig(
            engine=engine,
            metadata_provider=DefaultMetadataProvider(),
        ),
    })
    
    # Use API
    entities = await uma.entity_list()
    print(f"Entities: {entities}")
    
    user_id = await uma.save('users', {'name': 'John'})
    print(f"Created: {user_id}")
    
    user = await uma.read('users', user_id)
    print(f"User: {user}")
    
    await uma.delete('users', user_id)
    print("Deleted")
    
    await engine.dispose()

if __name__ == '__main__':
    asyncio.run(main())
```

## See Also

- [QUICKSTART.md](20260104-195802-doc-QUICKSTART.md) - Quick start guide
- [examples/api_usage.py](../examples/api_usage.py) - Complete example with access control
- [PROJECT_STRUCTURE.md](20260104-195714-doc-PROJECT_STRUCTURE.md) - Architecture details

```


–û–±–Ω–æ–≤–ª—è—é –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã:


```markdown
# API Implementation Summary

## ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –±–∞–∑–æ–≤–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π API-—Å–ª–æ–π.

### –ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/api.py`** (320 —Å—Ç—Ä–æ–∫)
   - –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã `_registry` –∏ `_context_template`
   - 8 –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥

2. **`examples/api_usage.py`** (300+ —Å—Ç—Ä–æ–∫)
   - –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `AccessControlMetadataProvider` —Å —Ä–æ–ª—è–º–∏
   - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π CRUD
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞

3. **`tests/test_api.py`**
   - –¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π
   - –ü–æ–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

4. **`API_SUMMARY.md`**
   - –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API
   - –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - Best practices

### –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/__init__.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç—ã –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π

2. **`src/namerec/uma/core/types.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è `Operation.LIST`

3. **`src/namerec/uma/metadata.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `can()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
   - –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –≤—Å—ë

4. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã QUICKSTART.md, VERIFICATION.md, CREATED_FILES_SUMMARY.md

## API –ú–µ—Ç–æ–¥—ã

### 1. `UMA.create()`

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UMA –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `UMA` instance

### 2. `uma.read()`

```python
user = await uma.read(
    entity_name='users',
    id_value=123,
    user_context=current_user,  # Optional
    namespace=None,             # Optional
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –¥–∞–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å–∏

**–ò—Å–∫–ª—é—á–µ–Ω–∏—è**: `UMAAccessDeniedError`, `UMANotFoundError`

### 3. `uma.save()`

```python
# Create
user_id = await uma.save('users', {'name': 'John'})

# Update
await uma.save('users', {'id': 123, 'name': 'John Smith'})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: ID —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏

**–õ–æ–≥–∏–∫–∞**: –ï—Å–ª–∏ –≤ `data` –µ—Å—Ç—å `id` - UPDATE, –∏–Ω–∞—á–µ CREATE

### 4. `uma.delete()`

```python
deleted = await uma.delete('users', 123, user_context=current_user)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `bool` - True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–æ

### 5. `uma.entity_details()`

```python
metadata = await uma.entity_details('users')
print(metadata['columns'])
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (columns, description, etc.)

### 6. `uma.entity_list()`

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace='virtual',  # Optional filter
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `list[str]` - –∏–º–µ–Ω–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π

### 7. `uma.select()` ‚úÖ

```python
# JSQL query execution
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    params={},
    user_context=current_user,
)
```

**–°—Ç–∞—Ç—É—Å**: ‚úÖ Fully implemented

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**: 
- –ü–∞—Ä—Å–µ—Ä JSQL ‚Üí SQLAlchemy (`jsql/parser.py`)
- Executor –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (`jsql/executor.py`)
- –ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (`jsql/result.py`)

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: –°–º. [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md)

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏**:
- –í—Å–µ —Ç–∏–ø—ã SELECT –∑–∞–ø—Ä–æ—Å–æ–≤
- WHERE —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏, AND/OR/NOT
- JOINs –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
- –ê–≥—Ä–µ–≥–∞—Ü–∏–∏ –∏ GROUP BY
- ORDER BY (–≤–∫–ª—é—á–∞—è –ø–æ –∞–ª–∏–∞—Å–∞–º)
- CTEs, –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã, –æ–∫–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã

### 8. `uma.registry`

```python
# Registry –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ –∞—Ç—Ä–∏–±—É—Ç UMA instance
uma.registry.register('custom_view', MyViewHandler)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤

## –ö–æ–Ω—Ç—Ä–æ–ª—å –î–æ—Å—Ç—É–ø–∞

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `can()` –º–µ—Ç–æ–¥–∞

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        user = context.user_context
        
        if not user:
            return False
        
        if user.role == 'admin':
            return True
        
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å User Context

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

admin = User(1, 'admin')
user = User(2, 'user')

# –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç –≤—Å—ë
await uma_save('users', {'name': 'Admin'}, user_context=admin)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞—Ç—å
user_data = await uma_read('users', 1, user_context=user)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å
try:
    await uma_save('users', {'name': 'Hack'}, user_context=user)
except UMAAccessDeniedError:
    print("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω!")
```

## –¢–∏–ø—ã –û–ø–µ—Ä–∞—Ü–∏–π

```python
from namerec.uma import Operation

Operation.SELECT  # JSQL –∑–∞–ø—Ä–æ—Å
Operation.READ    # –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.CREATE  # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.UPDATE  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.DELETE  # –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.META    # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
Operation.LIST    # –°–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π
```

## –ü—Ä–∏–º–µ—Ä—ã –ó–∞–ø—É—Å–∫–∞

```bash
# API –ø—Ä–∏–º–µ—Ä —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–æ—Å—Ç—É–ø–∞
uv run python examples/api_usage.py

# –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä (–Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π API)
uv run python examples/basic_usage.py

# –¢–µ—Å—Ç—ã
uv run pytest tests/test_api.py -v
```

## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### 1. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ

- `_registry` - –≥–ª–æ–±–∞–ª—å–Ω—ã–π registry
- `_context_template` - —à–∞–±–ª–æ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —á–µ—Ä–µ–∑ `initialize_uma()`
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ –∫–∞–∂–¥–æ–π API —Ñ—É–Ω–∫—Ü–∏–∏

### 2. –°–æ–∑–¥–∞–Ω–∏–µ –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞

–§—É–Ω–∫—Ü–∏—è `_create_context()`:
- –ö–æ–ø–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ `_context_template`
- –î–æ–±–∞–≤–ª—è–µ—Ç `user_context` –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ `**extra`

### 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –î–æ—Å—Ç—É–ø–∞

–§—É–Ω–∫—Ü–∏—è `_check_access()`:
- –í—ã–∑—ã–≤–∞–µ—Ç `metadata_provider.can()`
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ `Operation` enum, —Ç–∞–∫ –∏ —Å—Ç—Ä–æ–∫–∏
- –í—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç `UMAAccessDeniedError` –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ

### 4. Namespace Support

- –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –≤ –∏–º–µ–Ω–∏ —Å—É—â–Ω–æ—Å—Ç–∏: `'virtual:users'`
- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º: `namespace='virtual'`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `parse_entity_name()` –¥–ª—è —Ä–∞–∑–±–æ—Ä–∞

## –°–ª–µ–¥—É—é—â–∏–µ –®–∞–≥–∏

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ ‚úÖ

- [x] –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (handlers, registry, context)
- [x] API —Ñ—É–Ω–∫—Ü–∏–∏ (read, save, delete, meta, list)
- [x] –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥
- [x] User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] Namespace –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã
- [x] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### –ù–µ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ (–±—É–¥—É—â–µ–µ)

- [ ] JSQL –ø–∞—Ä—Å–µ—Ä (uma_select –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π)
- [ ] Many-to-many –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [ ] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- [ ] –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [ ] –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (constraints, indexes)

## –ü—Ä–æ–≤–µ—Ä–∫–∞

```bash
# –ù–µ—Ç –æ—à–∏–±–æ–∫ –ª–∏–Ω—Ç–µ—Ä–∞
ruff check src/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
mypy src/

# –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
uv run pytest

# –ü—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç
uv run python examples/api_usage.py
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

API-—Å–ª–æ–π –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —Å–æ–≥–ª–∞—Å–Ω–æ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤ `docs/20260104-142932-log-impl_proposal-entity_handlers.md`:

‚úÖ `initialize_uma()` - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è  
‚úÖ `uma_read()` - —á—Ç–µ–Ω–∏–µ  
‚úÖ `uma_save()` - —Å–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ  
‚úÖ `uma_delete()` - —É–¥–∞–ª–µ–Ω–∏–µ  
‚úÖ `uma_meta()` - –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ  
‚úÖ `uma_list_entities()` - —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π  
‚úÖ `uma_select()` - placeholder –¥–ª—è JSQL  
‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()`  
‚úÖ User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞  
‚úÖ –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã  

–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!

```

```markdown
# Use in initialization
uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=MyMetadataProvider(),
    ),
})
```

```markdown
# API Implementation Summary

## ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –±–∞–∑–æ–≤–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π API-—Å–ª–æ–π.

### –ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/api.py`** (320 —Å—Ç—Ä–æ–∫)
   - –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã `_registry` –∏ `_context_template`
   - 8 –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥

2. **`examples/api_usage.py`** (300+ —Å—Ç—Ä–æ–∫)
   - –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `AccessControlMetadataProvider` —Å —Ä–æ–ª—è–º–∏
   - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π CRUD
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞

3. **`tests/test_api.py`**
   - –¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π
   - –ü–æ–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

4. **`API_SUMMARY.md`**
   - –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API
   - –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - Best practices

### –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/__init__.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç—ã –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π

2. **`src/namerec/uma/core/types.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è `Operation.LIST`

3. **`src/namerec/uma/metadata.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `can()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
   - –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –≤—Å—ë

4. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã QUICKSTART.md, VERIFICATION.md, CREATED_FILES_SUMMARY.md

## API –ú–µ—Ç–æ–¥—ã

### 1. `UMA.create()`

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UMA –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `UMA` instance

### 2. `uma.read()`

```python
user = await uma.read(
    entity_name='users',
    id_value=123,
    user_context=current_user,  # Optional
    namespace=None,             # Optional
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –¥–∞–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å–∏

**–ò—Å–∫–ª—é—á–µ–Ω–∏—è**: `UMAAccessDeniedError`, `UMANotFoundError`

### 3. `uma.save()`

```python
# Create
user_id = await uma.save('users', {'name': 'John'})

# Update
await uma.save('users', {'id': 123, 'name': 'John Smith'})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: ID —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏

**–õ–æ–≥–∏–∫–∞**: –ï—Å–ª–∏ –≤ `data` –µ—Å—Ç—å `id` - UPDATE, –∏–Ω–∞—á–µ CREATE

### 4. `uma.delete()`

```python
deleted = await uma.delete('users', 123, user_context=current_user)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `bool` - True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–æ

### 5. `uma.entity_details()`

```python
metadata = await uma.entity_details('users')
print(metadata['columns'])
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (columns, description, etc.)

### 6. `uma.entity_list()`

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace='virtual',  # Optional filter
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `list[str]` - –∏–º–µ–Ω–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π

### 7. `uma.select()` ‚úÖ

```python
# JSQL query execution
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    params={},
    user_context=current_user,
)
```

**–°—Ç–∞—Ç—É—Å**: ‚úÖ Fully implemented

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**: 
- –ü–∞—Ä—Å–µ—Ä JSQL ‚Üí SQLAlchemy (`jsql/parser.py`)
- Executor –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (`jsql/executor.py`)
- –ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (`jsql/result.py`)

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: –°–º. [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md)

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏**:
- –í—Å–µ —Ç–∏–ø—ã SELECT –∑–∞–ø—Ä–æ—Å–æ–≤
- WHERE —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏, AND/OR/NOT
- JOINs –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
- –ê–≥—Ä–µ–≥–∞—Ü–∏–∏ –∏ GROUP BY
- ORDER BY (–≤–∫–ª—é—á–∞—è –ø–æ –∞–ª–∏–∞—Å–∞–º)
- CTEs, –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã, –æ–∫–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã

### 8. `uma.registry`

```python
# Registry –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ –∞—Ç—Ä–∏–±—É—Ç UMA instance
uma.registry.register('custom_view', MyViewHandler)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤

## –ö–æ–Ω—Ç—Ä–æ–ª—å –î–æ—Å—Ç—É–ø–∞

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `can()` –º–µ—Ç–æ–¥–∞

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        user = context.user_context
        
        if not user:
            return False
        
        if user.role == 'admin':
            return True
        
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å User Context

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

admin = User(1, 'admin')
user = User(2, 'user')

# –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç –≤—Å—ë
await uma.save('users', {'name': 'Admin'}, user_context=admin)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞—Ç—å
user_data = await uma.read('users', 1, user_context=user)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å
try:
    await uma.save('users', {'name': 'Hack'}, user_context=user)
except UMAAccessDeniedError:
    print("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω!")
```

## –¢–∏–ø—ã –û–ø–µ—Ä–∞—Ü–∏–π

```python
from namerec.uma import Operation

Operation.SELECT  # JSQL –∑–∞–ø—Ä–æ—Å
Operation.READ    # –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.CREATE  # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.UPDATE  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.DELETE  # –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.META    # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
Operation.LIST    # –°–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π
```

## –ü—Ä–∏–º–µ—Ä—ã –ó–∞–ø—É—Å–∫–∞

```bash
# API –ø—Ä–∏–º–µ—Ä —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–æ—Å—Ç—É–ø–∞
uv run python examples/api_usage.py

# –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä (–Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π API)
uv run python examples/basic_usage.py

# –¢–µ—Å—Ç—ã
uv run pytest tests/test_api.py -v
```

## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### 1. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ

- `_registry` - –≥–ª–æ–±–∞–ª—å–Ω—ã–π registry
- `_context_template` - —à–∞–±–ª–æ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —á–µ—Ä–µ–∑ `initialize_uma()`
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ –∫–∞–∂–¥–æ–π API —Ñ—É–Ω–∫—Ü–∏–∏

### 2. –°–æ–∑–¥–∞–Ω–∏–µ –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞

–§—É–Ω–∫—Ü–∏—è `_create_context()`:
- –ö–æ–ø–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ `_context_template`
- –î–æ–±–∞–≤–ª—è–µ—Ç `user_context` –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ `**extra`

### 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –î–æ—Å—Ç—É–ø–∞

–§—É–Ω–∫—Ü–∏—è `_check_access()`:
- –í—ã–∑—ã–≤–∞–µ—Ç `metadata_provider.can()`
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ `Operation` enum, —Ç–∞–∫ –∏ —Å—Ç—Ä–æ–∫–∏
- –í—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç `UMAAccessDeniedError` –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ

### 4. Namespace Support

- –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –≤ –∏–º–µ–Ω–∏ —Å—É—â–Ω–æ—Å—Ç–∏: `'virtual:users'`
- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º: `namespace='virtual'`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `parse_entity_name()` –¥–ª—è —Ä–∞–∑–±–æ—Ä–∞

## –°–ª–µ–¥—É—é—â–∏–µ –®–∞–≥–∏

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ ‚úÖ

- [x] –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (handlers, registry, context)
- [x] API —Ñ—É–Ω–∫—Ü–∏–∏ (read, save, delete, meta, list)
- [x] –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥
- [x] User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] Namespace –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã
- [x] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### –ù–µ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ (–±—É–¥—É—â–µ–µ)

- [ ] JSQL –ø–∞—Ä—Å–µ—Ä (uma_select –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π)
- [ ] Many-to-many –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [ ] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- [ ] –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [ ] –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (constraints, indexes)

## –ü—Ä–æ–≤–µ—Ä–∫–∞

```bash
# –ù–µ—Ç –æ—à–∏–±–æ–∫ –ª–∏–Ω—Ç–µ—Ä–∞
ruff check src/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
mypy src/

# –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
uv run pytest

# –ü—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç
uv run python examples/api_usage.py
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

API-—Å–ª–æ–π –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —Å–æ–≥–ª–∞—Å–Ω–æ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤ `docs/20260104-142932-log-impl_proposal-entity_handlers.md`:

‚úÖ `initialize_uma()` - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è  
‚úÖ `uma_read()` - —á—Ç–µ–Ω–∏–µ  
‚úÖ `uma_save()` - —Å–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ  
‚úÖ `uma_delete()` - —É–¥–∞–ª–µ–Ω–∏–µ  
‚úÖ `uma_meta()` - –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ  
‚úÖ `uma_list_entities()` - —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π  
‚úÖ `uma_select()` - placeholder –¥–ª—è JSQL  
‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()`  
‚úÖ User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞  
‚úÖ –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã  

–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!

```

```markdown
# Register
uma.registry.register('user_stats', UserStatsView)

# Use like regular entity
stats = await uma.entity_details('user_stats')
```

```markdown
# API Implementation Summary

## ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –±–∞–∑–æ–≤–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π API-—Å–ª–æ–π.

### –ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/api.py`** (320 —Å—Ç—Ä–æ–∫)
   - –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã `_registry` –∏ `_context_template`
   - 8 –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥

2. **`examples/api_usage.py`** (300+ —Å—Ç—Ä–æ–∫)
   - –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `AccessControlMetadataProvider` —Å —Ä–æ–ª—è–º–∏
   - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π CRUD
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞

3. **`tests/test_api.py`**
   - –¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π
   - –ü–æ–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

4. **`API_SUMMARY.md`**
   - –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API
   - –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - Best practices

### –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/__init__.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç—ã –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π

2. **`src/namerec/uma/core/types.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è `Operation.LIST`

3. **`src/namerec/uma/metadata.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `can()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
   - –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –≤—Å—ë

4. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã QUICKSTART.md, VERIFICATION.md, CREATED_FILES_SUMMARY.md

## API –ú–µ—Ç–æ–¥—ã

### 1. `UMA.create()`

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UMA –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `UMA` instance

### 2. `uma.read()`

```python
user = await uma.read(
    entity_name='users',
    id_value=123,
    user_context=current_user,  # Optional
    namespace=None,             # Optional
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –¥–∞–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å–∏

**–ò—Å–∫–ª—é—á–µ–Ω–∏—è**: `UMAAccessDeniedError`, `UMANotFoundError`

### 3. `uma.save()`

```python
# Create
user_id = await uma.save('users', {'name': 'John'})

# Update
await uma.save('users', {'id': 123, 'name': 'John Smith'})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: ID —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏

**–õ–æ–≥–∏–∫–∞**: –ï—Å–ª–∏ –≤ `data` –µ—Å—Ç—å `id` - UPDATE, –∏–Ω–∞—á–µ CREATE

### 4. `uma.delete()`

```python
deleted = await uma.delete('users', 123, user_context=current_user)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `bool` - True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–æ

### 5. `uma.entity_details()`

```python
metadata = await uma.entity_details('users')
print(metadata['columns'])
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (columns, description, etc.)

### 6. `uma.entity_list()`

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace='virtual',  # Optional filter
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `list[str]` - –∏–º–µ–Ω–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π

### 7. `uma.select()` ‚úÖ

```python
# JSQL query execution
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    params={},
    user_context=current_user,
)
```

**–°—Ç–∞—Ç—É—Å**: ‚úÖ Fully implemented

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**: 
- –ü–∞—Ä—Å–µ—Ä JSQL ‚Üí SQLAlchemy (`jsql/parser.py`)
- Executor –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (`jsql/executor.py`)
- –ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (`jsql/result.py`)

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: –°–º. [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md)

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏**:
- –í—Å–µ —Ç–∏–ø—ã SELECT –∑–∞–ø—Ä–æ—Å–æ–≤
- WHERE —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏, AND/OR/NOT
- JOINs –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
- –ê–≥—Ä–µ–≥–∞—Ü–∏–∏ –∏ GROUP BY
- ORDER BY (–≤–∫–ª—é—á–∞—è –ø–æ –∞–ª–∏–∞—Å–∞–º)
- CTEs, –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã, –æ–∫–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã

### 8. `uma.registry`

```python
# Registry –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ –∞—Ç—Ä–∏–±—É—Ç UMA instance
uma.registry.register('custom_view', MyViewHandler)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤

## –ö–æ–Ω—Ç—Ä–æ–ª—å –î–æ—Å—Ç—É–ø–∞

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `can()` –º–µ—Ç–æ–¥–∞

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        user = context.user_context
        
        if not user:
            return False
        
        if user.role == 'admin':
            return True
        
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å User Context

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

admin = User(1, 'admin')
user = User(2, 'user')

# –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç –≤—Å—ë
await uma.save('users', {'name': 'Admin'}, user_context=admin)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞—Ç—å
user_data = await uma.read('users', 1, user_context=user)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å
try:
    await uma.save('users', {'name': 'Hack'}, user_context=user)
except UMAAccessDeniedError:
    print("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω!")
```

## –¢–∏–ø—ã –û–ø–µ—Ä–∞—Ü–∏–π

```python
from namerec.uma import Operation

Operation.SELECT  # JSQL –∑–∞–ø—Ä–æ—Å
Operation.READ    # –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.CREATE  # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.UPDATE  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.DELETE  # –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.META    # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
Operation.LIST    # –°–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π
```

## –ü—Ä–∏–º–µ—Ä—ã –ó–∞–ø—É—Å–∫–∞

```bash
# API –ø—Ä–∏–º–µ—Ä —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–æ—Å—Ç—É–ø–∞
uv run python examples/api_usage.py

# –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä (–Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π API)
uv run python examples/basic_usage.py

# –¢–µ—Å—Ç—ã
uv run pytest tests/test_api.py -v
```

## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### 1. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ

- `_registry` - –≥–ª–æ–±–∞–ª—å–Ω—ã–π registry
- `_context_template` - —à–∞–±–ª–æ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —á–µ—Ä–µ–∑ `initialize_uma()`
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ –∫–∞–∂–¥–æ–π API —Ñ—É–Ω–∫—Ü–∏–∏

### 2. –°–æ–∑–¥–∞–Ω–∏–µ –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞

–§—É–Ω–∫—Ü–∏—è `_create_context()`:
- –ö–æ–ø–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ `_context_template`
- –î–æ–±–∞–≤–ª—è–µ—Ç `user_context` –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ `**extra`

### 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –î–æ—Å—Ç—É–ø–∞

–§—É–Ω–∫—Ü–∏—è `_check_access()`:
- –í—ã–∑—ã–≤–∞–µ—Ç `metadata_provider.can()`
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ `Operation` enum, —Ç–∞–∫ –∏ —Å—Ç—Ä–æ–∫–∏
- –í—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç `UMAAccessDeniedError` –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ

### 4. Namespace Support

- –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –≤ –∏–º–µ–Ω–∏ —Å—É—â–Ω–æ—Å—Ç–∏: `'virtual:users'`
- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º: `namespace='virtual'`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `parse_entity_name()` –¥–ª—è —Ä–∞–∑–±–æ—Ä–∞

## –°–ª–µ–¥—É—é—â–∏–µ –®–∞–≥–∏

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ ‚úÖ

- [x] –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (handlers, registry, context)
- [x] UMA –∫–ª–∞—Å—Å —Å –º–µ—Ç–æ–¥–∞–º–∏ (read, save, delete, entity_details, entity_list, select)
- [x] –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥
- [x] User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] Namespace –ø–æ–¥–¥–µ—Ä–∂–∫–∞ (—á–µ—Ä–µ–∑ NamespaceConfig)
- [x] JSQL –ø–∞—Ä—Å–µ—Ä –∏ executor
- [x] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
- [x] –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã
- [x] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### –ù–µ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ (–±—É–¥—É—â–µ–µ)

- [ ] JSQL –ø–∞—Ä—Å–µ—Ä (uma_select –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π)
- [ ] Many-to-many –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [ ] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- [ ] –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [ ] –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (constraints, indexes)

## –ü—Ä–æ–≤–µ—Ä–∫–∞

```bash
# –ù–µ—Ç –æ—à–∏–±–æ–∫ –ª–∏–Ω—Ç–µ—Ä–∞
ruff check src/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
mypy src/

# –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
uv run pytest

# –ü—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç
uv run python examples/api_usage.py
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

API-—Å–ª–æ–π –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —Å–æ–≥–ª–∞—Å–Ω–æ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤ `docs/20260104-142932-log-impl_proposal-entity_handlers.md`:

‚úÖ `initialize_uma()` - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è  
‚úÖ `uma_read()` - —á—Ç–µ–Ω–∏–µ  
‚úÖ `uma_save()` - —Å–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ  
‚úÖ `uma_delete()` - —É–¥–∞–ª–µ–Ω–∏–µ  
‚úÖ `uma_meta()` - –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ  
‚úÖ `uma_list_entities()` - —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π  
‚úÖ `uma_select()` - placeholder –¥–ª—è JSQL  
‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()`  
‚úÖ User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞  
‚úÖ –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã  

–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!

```

```markdown
# API Implementation Summary

## ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –±–∞–∑–æ–≤–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π API-—Å–ª–æ–π.

### –ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/api.py`** (320 —Å—Ç—Ä–æ–∫)
   - –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã `_registry` –∏ `_context_template`
   - 8 –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥

2. **`examples/api_usage.py`** (300+ —Å—Ç—Ä–æ–∫)
   - –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `AccessControlMetadataProvider` —Å —Ä–æ–ª—è–º–∏
   - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π CRUD
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞

3. **`tests/test_api.py`**
   - –¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π
   - –ü–æ–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

4. **`API_SUMMARY.md`**
   - –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API
   - –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - Best practices

### –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/__init__.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç—ã –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π

2. **`src/namerec/uma/core/types.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è `Operation.LIST`

3. **`src/namerec/uma/metadata.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `can()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
   - –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –≤—Å—ë

4. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã QUICKSTART.md, VERIFICATION.md, CREATED_FILES_SUMMARY.md

## API –ú–µ—Ç–æ–¥—ã

### 1. `UMA.create()`

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UMA –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `UMA` instance

### 2. `uma.read()`

```python
user = await uma.read(
    entity_name='users',
    id_value=123,
    user_context=current_user,  # Optional
    namespace=None,             # Optional
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –¥–∞–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å–∏

**–ò—Å–∫–ª—é—á–µ–Ω–∏—è**: `UMAAccessDeniedError`, `UMANotFoundError`

### 3. `uma.save()`

```python
# Create
user_id = await uma.save('users', {'name': 'John'})

# Update
await uma.save('users', {'id': 123, 'name': 'John Smith'})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: ID —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏

**–õ–æ–≥–∏–∫–∞**: –ï—Å–ª–∏ –≤ `data` –µ—Å—Ç—å `id` - UPDATE, –∏–Ω–∞—á–µ CREATE

### 4. `uma.delete()`

```python
deleted = await uma.delete('users', 123, user_context=current_user)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `bool` - True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–æ

### 5. `uma.entity_details()`

```python
metadata = await uma.entity_details('users')
print(metadata['columns'])
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (columns, description, etc.)

### 6. `uma.entity_list()`

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace='virtual',  # Optional filter
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `list[str]` - –∏–º–µ–Ω–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π

### 7. `uma.select()` ‚úÖ

```python
# JSQL query execution
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    params={},
    user_context=current_user,
)
```

**–°—Ç–∞—Ç—É—Å**: ‚úÖ Fully implemented

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**: 
- –ü–∞—Ä—Å–µ—Ä JSQL ‚Üí SQLAlchemy (`jsql/parser.py`)
- Executor –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (`jsql/executor.py`)
- –ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (`jsql/result.py`)

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: –°–º. [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md)

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏**:
- –í—Å–µ —Ç–∏–ø—ã SELECT –∑–∞–ø—Ä–æ—Å–æ–≤
- WHERE —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏, AND/OR/NOT
- JOINs –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
- –ê–≥—Ä–µ–≥–∞—Ü–∏–∏ –∏ GROUP BY
- ORDER BY (–≤–∫–ª—é—á–∞—è –ø–æ –∞–ª–∏–∞—Å–∞–º)
- CTEs, –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã, –æ–∫–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã

### 8. `uma.registry`

```python
# Registry –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ –∞—Ç—Ä–∏–±—É—Ç UMA instance
uma.registry.register('custom_view', MyViewHandler)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤

## –ö–æ–Ω—Ç—Ä–æ–ª—å –î–æ—Å—Ç—É–ø–∞

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `can()` –º–µ—Ç–æ–¥–∞

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        user = context.user_context
        
        if not user:
            return False
        
        if user.role == 'admin':
            return True
        
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å User Context

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

admin = User(1, 'admin')
user = User(2, 'user')

# –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç –≤—Å—ë
await uma.save('users', {'name': 'Admin'}, user_context=admin)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞—Ç—å
user_data = await uma.read('users', 1, user_context=user)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å
try:
    await uma.save('users', {'name': 'Hack'}, user_context=user)
except UMAAccessDeniedError:
    print("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω!")
```

## –¢–∏–ø—ã –û–ø–µ—Ä–∞—Ü–∏–π

```python
from namerec.uma import Operation

Operation.SELECT  # JSQL –∑–∞–ø—Ä–æ—Å
Operation.READ    # –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.CREATE  # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.UPDATE  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.DELETE  # –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.META    # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
Operation.LIST    # –°–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π
```

## –ü—Ä–∏–º–µ—Ä—ã –ó–∞–ø—É—Å–∫–∞

```bash
# API –ø—Ä–∏–º–µ—Ä —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–æ—Å—Ç—É–ø–∞
uv run python examples/api_usage.py

# –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä (–Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π API)
uv run python examples/basic_usage.py

# –¢–µ—Å—Ç—ã
uv run pytest tests/test_api.py -v
```

## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### 1. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ

- `_registry` - –≥–ª–æ–±–∞–ª—å–Ω—ã–π registry
- `_context_template` - —à–∞–±–ª–æ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —á–µ—Ä–µ–∑ `initialize_uma()`
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ –∫–∞–∂–¥–æ–π API —Ñ—É–Ω–∫—Ü–∏–∏

### 2. –°–æ–∑–¥–∞–Ω–∏–µ –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞

–§—É–Ω–∫—Ü–∏—è `_create_context()`:
- –ö–æ–ø–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ `_context_template`
- –î–æ–±–∞–≤–ª—è–µ—Ç `user_context` –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ `**extra`

### 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –î–æ—Å—Ç—É–ø–∞

–§—É–Ω–∫—Ü–∏—è `_check_access()`:
- –í—ã–∑—ã–≤–∞–µ—Ç `metadata_provider.can()`
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ `Operation` enum, —Ç–∞–∫ –∏ —Å—Ç—Ä–æ–∫–∏
- –í—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç `UMAAccessDeniedError` –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ

### 4. Namespace Support

- –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –≤ –∏–º–µ–Ω–∏ —Å—É—â–Ω–æ—Å—Ç–∏: `'virtual:users'`
- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º: `namespace='virtual'`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `parse_entity_name()` –¥–ª—è —Ä–∞–∑–±–æ—Ä–∞

## –°–ª–µ–¥—É—é—â–∏–µ –®–∞–≥–∏

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ ‚úÖ

- [x] –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (handlers, registry, context)
- [x] UMA –∫–ª–∞—Å—Å —Å –º–µ—Ç–æ–¥–∞–º–∏ (read, save, delete, entity_details, entity_list, select)
- [x] –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥
- [x] User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] Namespace –ø–æ–¥–¥–µ—Ä–∂–∫–∞ (—á–µ—Ä–µ–∑ NamespaceConfig)
- [x] JSQL –ø–∞—Ä—Å–µ—Ä –∏ executor
- [x] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
- [x] –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã
- [x] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### –ù–µ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ (–±—É–¥—É—â–µ–µ)

- [ ] Many-to-many –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [ ] –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [ ] –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (constraints, indexes)

## –ü—Ä–æ–≤–µ—Ä–∫–∞

```bash
# –ù–µ—Ç –æ—à–∏–±–æ–∫ –ª–∏–Ω—Ç–µ—Ä–∞
ruff check src/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
mypy src/

# –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
uv run pytest

# –ü—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç
uv run python examples/api_usage.py
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

API-—Å–ª–æ–π –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω —Å–æ–≥–ª–∞—Å–Ω–æ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤ `docs/20260104-142932-log-impl_proposal-entity_handlers.md`:

‚úÖ `initialize_uma()` - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è  
‚úÖ `uma_read()` - —á—Ç–µ–Ω–∏–µ  
‚úÖ `uma_save()` - —Å–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ  
‚úÖ `uma_delete()` - —É–¥–∞–ª–µ–Ω–∏–µ  
‚úÖ `uma_meta()` - –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ  
‚úÖ `uma_list_entities()` - —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π  
‚úÖ `uma_select()` - placeholder –¥–ª—è JSQL  
‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()`  
‚úÖ User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞  
‚úÖ –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã  

–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!

```

```markdown
# API Implementation Summary

## ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –±–∞–∑–æ–≤–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –±—ã–ª —Å–æ–∑–¥–∞–Ω –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π API-—Å–ª–æ–π.

### –ù–æ–≤—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/api.py`** (320 —Å—Ç—Ä–æ–∫)
   - –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã `_registry` –∏ `_context_template`
   - 8 –ø—É–±–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥

2. **`examples/api_usage.py`** (300+ —Å—Ç—Ä–æ–∫)
   - –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
   - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `AccessControlMetadataProvider` —Å —Ä–æ–ª—è–º–∏
   - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π CRUD
   - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞

3. **`tests/test_api.py`**
   - –¢–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π
   - –ü–æ–∫—Ä—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

4. **`API_SUMMARY.md`**
   - –ü–æ–ª–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è API
   - –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - Best practices

### –û–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã

1. **`src/namerec/uma/__init__.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω—ã —ç–∫—Å–ø–æ—Ä—Ç—ã –≤—Å–µ—Ö API —Ñ—É–Ω–∫—Ü–∏–π

2. **`src/namerec/uma/core/types.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è `Operation.LIST`

3. **`src/namerec/uma/metadata.py`**
   - –î–æ–±–∞–≤–ª–µ–Ω –º–µ—Ç–æ–¥ `can()` –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
   - –ë–∞–∑–æ–≤–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑—Ä–µ—à–∞–µ—Ç –≤—Å—ë

4. **–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã QUICKSTART.md, VERIFICATION.md, CREATED_FILES_SUMMARY.md

## API –ú–µ—Ç–æ–¥—ã

### 1. `UMA.create()`

```python
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UMA –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `UMA` instance

### 2. `uma.read()`

```python
user = await uma.read(
    entity_name='users',
    id_value=123,
    user_context=current_user,  # Optional
    namespace=None,             # Optional
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –¥–∞–Ω–Ω—ã–º–∏ –∑–∞–ø–∏—Å–∏

**–ò—Å–∫–ª—é—á–µ–Ω–∏—è**: `UMAAccessDeniedError`, `UMANotFoundError`

### 3. `uma.save()`

```python
# Create
user_id = await uma.save('users', {'name': 'John'})

# Update
await uma.save('users', {'id': 123, 'name': 'John Smith'})
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: ID —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏

**–õ–æ–≥–∏–∫–∞**: –ï—Å–ª–∏ –≤ `data` –µ—Å—Ç—å `id` - UPDATE, –∏–Ω–∞—á–µ CREATE

### 4. `uma.delete()`

```python
deleted = await uma.delete('users', 123, user_context=current_user)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ ID

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `bool` - True –µ—Å–ª–∏ —É–¥–∞–ª–µ–Ω–æ

### 5. `uma.entity_details()`

```python
metadata = await uma.entity_details('users')
print(metadata['columns'])
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–∏

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `dict` —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (columns, description, etc.)

### 6. `uma.entity_list()`

```python
entities = await uma.entity_list(
    user_context=current_user,
    namespace='virtual',  # Optional filter
)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π

**–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç**: `list[str]` - –∏–º–µ–Ω–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π

### 7. `uma.select()` ‚úÖ

```python
# JSQL query execution
result = await uma.select(
    jsql={
        'from': 'users',
        'select': ['id', 'name'],
        'where': {
            'op': '=',
            'left': {'field': 'active'},
            'right': {'value': True}
        }
    },
    params={},
    user_context=current_user,
)
```

**–°—Ç–∞—Ç—É—Å**: ‚úÖ Fully implemented

**–†–µ–∞–ª–∏–∑–∞—Ü–∏—è**: 
- –ü–∞—Ä—Å–µ—Ä JSQL ‚Üí SQLAlchemy (`jsql/parser.py`)
- Executor –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (`jsql/executor.py`)
- –ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ (`jsql/result.py`)

**–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è**: –°–º. [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md)

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏**:
- –í—Å–µ —Ç–∏–ø—ã SELECT –∑–∞–ø—Ä–æ—Å–æ–≤
- WHERE —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏, AND/OR/NOT
- JOINs –≤—Å–µ—Ö —Ç–∏–ø–æ–≤
- –ê–≥—Ä–µ–≥–∞—Ü–∏–∏ –∏ GROUP BY
- ORDER BY (–≤–∫–ª—é—á–∞—è –ø–æ –∞–ª–∏–∞—Å–∞–º)
- CTEs, –ø–æ–¥–∑–∞–ø—Ä–æ—Å—ã, –æ–∫–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
- –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã

### 8. `uma.registry`

```python
# Registry –¥–æ—Å—Ç—É–ø–µ–Ω –∫–∞–∫ –∞—Ç—Ä–∏–±—É—Ç UMA instance
uma.registry.register('custom_view', MyViewHandler)
```

**–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ**: –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–π –∏ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤

## –ö–æ–Ω—Ç—Ä–æ–ª—å –î–æ—Å—Ç—É–ø–∞

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è `can()` –º–µ—Ç–æ–¥–∞

```python
from namerec.uma import DefaultMetadataProvider, Operation, UMAContext

class MyMetadataProvider(DefaultMetadataProvider):
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,
    ) -> bool:
        user = context.user_context
        
        if not user:
            return False
        
        if user.role == 'admin':
            return True
        
        if user.role == 'user':
            return operation in (Operation.READ, Operation.META, Operation.LIST)
        
        return False
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å User Context

```python
class User:
    def __init__(self, user_id, role):
        self.id = user_id
        self.role = role

admin = User(1, 'admin')
user = User(2, 'user')

# –ê–¥–º–∏–Ω –º–æ–∂–µ—Ç –≤—Å—ë
await uma.save('users', {'name': 'Admin'}, user_context=admin)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞—Ç—å
user_data = await uma.read('users', 1, user_context=user)

# –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å
try:
    await uma.save('users', {'name': 'Hack'}, user_context=user)
except UMAAccessDeniedError:
    print("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω!")
```

## –¢–∏–ø—ã –û–ø–µ—Ä–∞—Ü–∏–π

```python
from namerec.uma import Operation

Operation.SELECT  # JSQL –∑–∞–ø—Ä–æ—Å
Operation.READ    # –ß—Ç–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.CREATE  # –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.UPDATE  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.DELETE  # –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏
Operation.META    # –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
Operation.LIST    # –°–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π
```

## –ü—Ä–∏–º–µ—Ä—ã –ó–∞–ø—É—Å–∫–∞

```bash
# API –ø—Ä–∏–º–µ—Ä —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –¥–æ—Å—Ç—É–ø–∞
uv run python examples/api_usage.py

# –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä (–Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π API)
uv run python examples/basic_usage.py

# –¢–µ—Å—Ç—ã
uv run pytest tests/test_api.py -v
```

## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### 1. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ

- `_registry` - –≥–ª–æ–±–∞–ª—å–Ω—ã–π registry
- `_context_template` - —à–∞–±–ª–æ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è —á–µ—Ä–µ–∑ `initialize_uma()`
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤ –∫–∞–∂–¥–æ–π API —Ñ—É–Ω–∫—Ü–∏–∏

### 2. –°–æ–∑–¥–∞–Ω–∏–µ –ö–æ–Ω—Ç–µ–∫—Å—Ç–∞

–§—É–Ω–∫—Ü–∏—è `_create_context()`:
- –ö–æ–ø–∏—Ä—É–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ `_context_template`
- –î–æ–±–∞–≤–ª—è–µ—Ç `user_context` –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —á–µ—Ä–µ–∑ `**extra`

### 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –î–æ—Å—Ç—É–ø–∞

–§—É–Ω–∫—Ü–∏—è `_check_access()`:
- –í—ã–∑—ã–≤–∞–µ—Ç `metadata_provider.can()`
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–∫ `Operation` enum, —Ç–∞–∫ –∏ —Å—Ç—Ä–æ–∫–∏
- –í—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç `UMAAccessDeniedError` –ø—Ä–∏ –æ—Ç–∫–∞–∑–µ

### 4. Namespace Support

- –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –≤ –∏–º–µ–Ω–∏ —Å—É—â–Ω–æ—Å—Ç–∏: `'virtual:users'`
- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º: `namespace='virtual'`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `parse_entity_name()` –¥–ª—è —Ä–∞–∑–±–æ—Ä–∞

## –°–ª–µ–¥—É—é—â–∏–µ –®–∞–≥–∏

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ ‚úÖ

- [x] –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ (handlers, registry, context)
- [x] UMA –∫–ª–∞—Å—Å —Å –º–µ—Ç–æ–¥–∞–º–∏ (read, save, delete, entity_details, entity_list, select)
- [x] –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()` –º–µ—Ç–æ–¥
- [x] User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [x] Namespace –ø–æ–¥–¥–µ—Ä–∂–∫–∞ (—á–µ—Ä–µ–∑ NamespaceConfig)
- [x] JSQL –ø–∞—Ä—Å–µ—Ä –∏ executor
- [x] –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
- [x] –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã
- [x] –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### –ù–µ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ (–±—É–¥—É—â–µ–µ)

- [ ] Many-to-many –ø–æ–¥–¥–µ—Ä–∂–∫–∞
- [ ] –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- [ ] –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (constraints, indexes)

## –ü—Ä–æ–≤–µ—Ä–∫–∞

```bash
# –ù–µ—Ç –æ—à–∏–±–æ–∫ –ª–∏–Ω—Ç–µ—Ä–∞
ruff check src/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
mypy src/

# –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
uv run pytest

# –ü—Ä–∏–º–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç
uv run python examples/api_usage.py
```

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

API-—Å–ª–æ–π –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω:

‚úÖ `UMA.create()` - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è  
‚úÖ `uma.read()` - —á—Ç–µ–Ω–∏–µ  
‚úÖ `uma.save()` - —Å–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ  
‚úÖ `uma.delete()` - —É–¥–∞–ª–µ–Ω–∏–µ  
‚úÖ `uma.entity_details()` - –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ  
‚úÖ `uma.entity_list()` - —Å–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π  
‚úÖ `uma.select()` - JSQL –∑–∞–ø—Ä–æ—Å—ã  
‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å –¥–æ—Å—Ç—É–ø–∞ —á–µ—Ä–µ–∑ `can()`  
‚úÖ User context –ø–æ–¥–¥–µ—Ä–∂–∫–∞  
‚úÖ Namespace –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —á–µ—Ä–µ–∑ NamespaceConfig  
‚úÖ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤  
‚úÖ –ü—Ä–∏–º–µ—Ä—ã –∏ —Ç–µ—Å—Ç—ã  

–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!

```

```markdown
# UMA Project Structure

This document describes the structure of the UMA (Unified Model Access) project.

## Directory Layout

```
uma2/
‚îú‚îÄ‚îÄ src/                          # Source code (src-layout)
‚îÇ   ‚îî‚îÄ‚îÄ namerec/                  # Vendor namespace
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py           # Namespace package marker
‚îÇ       ‚îî‚îÄ‚îÄ uma/                  # UMA package
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py       # Public API exports
‚îÇ           ‚îú‚îÄ‚îÄ py.typed          # PEP 561 marker for type checking
‚îÇ           ‚îú‚îÄ‚îÄ core/             # Core components
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # Type definitions (EntityName, Operation, Protocols)
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ context.py    # UMAContext
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # Exception hierarchy
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ utils.py      # Utility functions
‚îÇ           ‚îú‚îÄ‚îÄ handlers/         # Entity handlers
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ base.py       # DefaultEntityHandler
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ virtual.py    # VirtualViewHandler
‚îÇ           ‚îú‚îÄ‚îÄ jsql/             # JSQL (JSON-SQL) implementation
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # JSQL type definitions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # JSQL-specific exceptions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ parser.py     # JSQL to SQLAlchemy parser
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ executor.py   # JSQL query executor
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ result.py     # Result builder with metadata
‚îÇ           ‚îú‚îÄ‚îÄ application.py    # UMA application class
‚îÇ           ‚îú‚îÄ‚îÄ registry.py       # EntityRegistry
‚îÇ           ‚îî‚îÄ‚îÄ metadata.py       # DefaultMetadataProvider
‚îú‚îÄ‚îÄ tests/                        # Tests
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py              # Pytest fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_basic.py            # Basic tests
‚îÇ   ‚îú‚îÄ‚îÄ test_api.py              # API tests
‚îÇ   ‚îî‚îÄ‚îÄ test_jsql.py             # JSQL parser and executor tests
‚îú‚îÄ‚îÄ examples/                     # Usage examples
‚îÇ   ‚îú‚îÄ‚îÄ basic_usage.py           # Basic CRUD operations
‚îÇ   ‚îú‚îÄ‚îÄ api_usage.py             # API usage with access control
‚îÇ   ‚îî‚îÄ‚îÄ jsql_usage.py            # JSQL query examples
‚îú‚îÄ‚îÄ docs/                         # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ 20251201-010207-intro.md
‚îÇ   ‚îú‚îÄ‚îÄ 20251202-050343-log-concept.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260103-130403-log-impl_proposal.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-142932-log-impl_proposal-entity_handlers.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195602-doc-API_IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195632-doc-API_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195714-doc-PROJECT_STRUCTURE.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195802-doc-QUICKSTART.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-203856-log-project_setup.md
‚îÇ   ‚îî‚îÄ‚îÄ 20260104-220450-doc-JSQL_SPECIFICATION.md
‚îú‚îÄ‚îÄ context_portal/              # ConPort data (gitignored)
‚îú‚îÄ‚îÄ logs/                        # Logs (gitignored)
‚îú‚îÄ‚îÄ README.md                    # Project overview
‚îú‚îÄ‚îÄ PROJECT_STRUCTURE.md         # This file
‚îú‚îÄ‚îÄ pyproject.toml              # Project configuration
‚îî‚îÄ‚îÄ .gitignore                  # Git ignore rules
```

## Package Import Structure

After installation, the package can be imported as:

```python
from namerec.uma import (
    # Core types
    EntityName,
    Operation,
    EntityHandler,
    MetadataProvider,
    UMAContext,
    
    # Exceptions
    UMAError,
    UMAAccessDeniedError,
    UMANotFoundError,
    UMANotImplementedError,
    UMAValidationError,
    
    # Utils
    parse_entity_name,
    form_entity_name,
    copy_field_meta,
    is_virtual_view,
    
    # Handlers
    DefaultEntityHandler,
    VirtualViewHandler,
    
    # Registry
    EntityRegistry,
    init_global_registry,
    get_global_registry,
    
    # Metadata
    DefaultMetadataProvider,
)
```

## Key Components

### Core Module (`namerec.uma.core`)

- **types.py**: Defines core types and protocols
  - `EntityName`: Structured entity name with optional namespace
  - `Operation`: Enum for UMA operations (SELECT, READ, CREATE, UPDATE, DELETE, META)
  - `EntityHandler`: Protocol for entity handlers
  - `MetadataProvider`: Protocol for metadata providers

- **context.py**: Execution context
  - `UMAContext`: Contains engine, metadata, metadata_provider, user_context, cache, and extra fields

- **exceptions.py**: Exception hierarchy
  - `UMAError`: Base exception
  - `UMAAccessDeniedError`: Access denied
  - `UMANotFoundError`: Entity/record not found
  - `UMANotImplementedError`: Operation not implemented
  - `UMAValidationError`: Validation error

- **utils.py**: Utility functions
  - `parse_entity_name()`: Parse entity name string
  - `form_entity_name()`: Create EntityName from components
  - `copy_field_meta()`: Copy field metadata from source entity
  - `is_virtual_view()`: Check if entity is virtual view

### Handlers Module (`namerec.uma.handlers`)

- **base.py**: Default handler for database tables
  - `DefaultEntityHandler`: Implements all operations for regular tables
  - Supports simple and composite primary keys
  - Automatic metadata extraction from SQLAlchemy

- **virtual.py**: Base class for virtual views
  - `VirtualViewHandler`: Base class with default implementations
  - Raises `UMANotImplementedError` for operations that must be overridden
  - Automatically marks metadata with `is_virtual_view=True`

### Registry Module (`namerec.uma.registry`)

- `EntityRegistry`: Maps entity names to handlers
- Global registry singleton pattern
- Fallback to default handler for unregistered entities
- Auto-discovery of database tables

### Metadata Module (`namerec.uma.metadata`)

- `DefaultMetadataProvider`: Stores and retrieves custom metadata
- Can be extended for Redis or other storage backends

## Design Principles

1. **Stateless Handlers**: Entity handlers are classes with only classmethods, no instance state
2. **Explicit Context**: All necessary dependencies passed via `UMAContext`
3. **Protocol-Based**: Uses Python protocols for type safety and flexibility
4. **Async-First**: All operations are async for better scalability
5. **Extensible**: Easy to extend with custom handlers, metadata providers, and context fields

## Development Workflow

### Setup

```bash
# Install dependencies
uv sync --dev

# Run tests
uv run pytest

# Run linters
ruff check src/
mypy src/
```

### Creating Custom Handlers

1. Inherit from `DefaultEntityHandler` or `VirtualViewHandler`
2. Override necessary methods
3. Register with `EntityRegistry`

Example:

```python
from namerec.uma import VirtualViewHandler, get_global_registry

class MyView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        # Implementation
        pass

registry = get_global_registry()
registry.register('my_view', MyView)
```

## Testing Strategy

- Unit tests for core components
- Integration tests with SQLite in-memory database
- Async tests using pytest-asyncio
- Fixtures in `conftest.py` for common setup

## Future Enhancements

- JSQL parser (JSON to SQLAlchemy) - ‚úÖ Implemented (see [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md))
- Access control hooks
- Query executor
- API layer (uma_select, uma_read, uma_save, etc.) - ‚úÖ Implemented
- Support for many-to-many relationships
- Caching layer
- Performance optimizations

```

```markdown
# UMA Project Structure

This document describes the structure of the UMA (Unified Model Access) project.

## Directory Layout

```
uma2/
‚îú‚îÄ‚îÄ src/                          # Source code (src-layout)
‚îÇ   ‚îî‚îÄ‚îÄ namerec/                  # Vendor namespace
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py           # Namespace package marker
‚îÇ       ‚îî‚îÄ‚îÄ uma/                  # UMA package
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py       # Public API exports
‚îÇ           ‚îú‚îÄ‚îÄ py.typed          # PEP 561 marker for type checking
‚îÇ           ‚îú‚îÄ‚îÄ core/             # Core components
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # Type definitions (EntityName, Operation, Protocols)
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ context.py    # UMAContext
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # Exception hierarchy
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ utils.py      # Utility functions
‚îÇ           ‚îú‚îÄ‚îÄ handlers/         # Entity handlers
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ base.py       # DefaultEntityHandler
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ virtual.py    # VirtualViewHandler
‚îÇ           ‚îú‚îÄ‚îÄ jsql/             # JSQL (JSON-SQL) implementation
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # JSQL type definitions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # JSQL-specific exceptions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ parser.py     # JSQL to SQLAlchemy parser
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ executor.py   # JSQL query executor
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ result.py     # Result builder with metadata
‚îÇ           ‚îú‚îÄ‚îÄ application.py    # UMA application class
‚îÇ           ‚îú‚îÄ‚îÄ registry.py       # EntityRegistry
‚îÇ           ‚îî‚îÄ‚îÄ metadata.py       # DefaultMetadataProvider
‚îú‚îÄ‚îÄ tests/                        # Tests
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py              # Pytest fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_basic.py            # Basic tests
‚îÇ   ‚îú‚îÄ‚îÄ test_api.py              # API tests
‚îÇ   ‚îî‚îÄ‚îÄ test_jsql.py             # JSQL parser and executor tests
‚îú‚îÄ‚îÄ examples/                     # Usage examples
‚îÇ   ‚îú‚îÄ‚îÄ basic_usage.py           # Basic CRUD operations
‚îÇ   ‚îú‚îÄ‚îÄ api_usage.py             # API usage with access control
‚îÇ   ‚îî‚îÄ‚îÄ jsql_usage.py            # JSQL query examples
‚îú‚îÄ‚îÄ docs/                         # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ 20251201-010207-intro.md
‚îÇ   ‚îú‚îÄ‚îÄ 20251202-050343-log-concept.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260103-130403-log-impl_proposal.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-142932-log-impl_proposal-entity_handlers.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195602-doc-API_IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195632-doc-API_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195714-doc-PROJECT_STRUCTURE.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195802-doc-QUICKSTART.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-203856-log-project_setup.md
‚îÇ   ‚îî‚îÄ‚îÄ 20260104-220450-doc-JSQL_SPECIFICATION.md
‚îú‚îÄ‚îÄ context_portal/              # ConPort data (gitignored)
‚îú‚îÄ‚îÄ logs/                        # Logs (gitignored)
‚îú‚îÄ‚îÄ README.md                    # Project overview
‚îú‚îÄ‚îÄ PROJECT_STRUCTURE.md         # This file
‚îú‚îÄ‚îÄ pyproject.toml              # Project configuration
‚îî‚îÄ‚îÄ .gitignore                  # Git ignore rules
```

## Package Import Structure

After installation, the package can be imported as:

```python
from namerec.uma import (
    # Main class
    UMA,
    
    # Core types
    EntityName,
    Operation,
    EntityHandler,
    MetadataProvider,
    UMAContext,
    NamespaceConfig,
    
    # Exceptions
    UMAError,
    UMAAccessDeniedError,
    UMANotFoundError,
    UMANotImplementedError,
    UMAValidationError,
    
    # Utils
    parse_entity_name,
    form_entity_name,
    copy_field_meta,
    is_virtual_view,
    
    # Handlers
    DefaultEntityHandler,
    VirtualViewHandler,
    
    # Registry
    EntityRegistry,
    
    # Metadata
    DefaultMetadataProvider,
)
```

## Key Components

### Core Module (`namerec.uma.core`)

- **types.py**: Defines core types and protocols
  - `EntityName`: Structured entity name with optional namespace
  - `Operation`: Enum for UMA operations (SELECT, READ, CREATE, UPDATE, DELETE, META)
  - `EntityHandler`: Protocol for entity handlers
  - `MetadataProvider`: Protocol for metadata providers

- **context.py**: Execution context
  - `UMAContext`: Contains engine, metadata, metadata_provider, user_context, cache, and extra fields

- **exceptions.py**: Exception hierarchy
  - `UMAError`: Base exception
  - `UMAAccessDeniedError`: Access denied
  - `UMANotFoundError`: Entity/record not found
  - `UMANotImplementedError`: Operation not implemented
  - `UMAValidationError`: Validation error

- **utils.py**: Utility functions
  - `parse_entity_name()`: Parse entity name string
  - `form_entity_name()`: Create EntityName from components
  - `copy_field_meta()`: Copy field metadata from source entity
  - `is_virtual_view()`: Check if entity is virtual view

### Handlers Module (`namerec.uma.handlers`)

- **base.py**: Default handler for database tables
  - `DefaultEntityHandler`: Implements all operations for regular tables
  - Supports simple and composite primary keys
  - Automatic metadata extraction from SQLAlchemy

- **virtual.py**: Base class for virtual views
  - `VirtualViewHandler`: Base class with default implementations
  - Raises `UMANotImplementedError` for operations that must be overridden
  - Automatically marks metadata with `is_virtual_view=True`

### Registry Module (`namerec.uma.registry`)

- `EntityRegistry`: Maps entity names to handlers
- Global registry singleton pattern
- Fallback to default handler for unregistered entities
- Auto-discovery of database tables

### Metadata Module (`namerec.uma.metadata`)

- `DefaultMetadataProvider`: Stores and retrieves custom metadata
- Can be extended for Redis or other storage backends

## Design Principles

1. **Stateless Handlers**: Entity handlers are classes with only classmethods, no instance state
2. **Explicit Context**: All necessary dependencies passed via `UMAContext`
3. **Protocol-Based**: Uses Python protocols for type safety and flexibility
4. **Async-First**: All operations are async for better scalability
5. **Extensible**: Easy to extend with custom handlers, metadata providers, and context fields

## Development Workflow

### Setup

```bash
# Install dependencies
uv sync --dev

# Run tests
uv run pytest

# Run linters
ruff check src/
mypy src/
```

### Creating Custom Handlers

1. Inherit from `DefaultEntityHandler` or `VirtualViewHandler`
2. Override necessary methods
3. Register with `EntityRegistry`

Example:

```python
from namerec.uma import VirtualViewHandler, get_global_registry

class MyView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        # Implementation
        pass

registry = get_global_registry()
registry.register('my_view', MyView)
```

## Testing Strategy

- Unit tests for core components
- Integration tests with SQLite in-memory database
- Async tests using pytest-asyncio
- Fixtures in `conftest.py` for common setup

## Future Enhancements

- JSQL parser (JSON to SQLAlchemy) - ‚úÖ Implemented (see [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md))
- Access control hooks
- Query executor
- API layer (uma_select, uma_read, uma_save, etc.) - ‚úÖ Implemented
- Support for many-to-many relationships
- Caching layer
- Performance optimizations

```

```markdown
# UMA Project Structure

This document describes the structure of the UMA (Unified Model Access) project.

## Directory Layout

```
uma2/
‚îú‚îÄ‚îÄ src/                          # Source code (src-layout)
‚îÇ   ‚îî‚îÄ‚îÄ namerec/                  # Vendor namespace
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py           # Namespace package marker
‚îÇ       ‚îî‚îÄ‚îÄ uma/                  # UMA package
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py       # Public API exports
‚îÇ           ‚îú‚îÄ‚îÄ py.typed          # PEP 561 marker for type checking
‚îÇ           ‚îú‚îÄ‚îÄ core/             # Core components
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # Type definitions (EntityName, Operation, Protocols)
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ context.py    # UMAContext
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # Exception hierarchy
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ utils.py      # Utility functions
‚îÇ           ‚îú‚îÄ‚îÄ handlers/         # Entity handlers
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ base.py       # DefaultEntityHandler
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ virtual.py    # VirtualViewHandler
‚îÇ           ‚îú‚îÄ‚îÄ jsql/             # JSQL (JSON-SQL) implementation
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # JSQL type definitions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # JSQL-specific exceptions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ parser.py     # JSQL to SQLAlchemy parser
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ executor.py   # JSQL query executor
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ result.py     # Result builder with metadata
‚îÇ           ‚îú‚îÄ‚îÄ application.py    # UMA application class
‚îÇ           ‚îú‚îÄ‚îÄ registry.py       # EntityRegistry
‚îÇ           ‚îî‚îÄ‚îÄ metadata.py       # DefaultMetadataProvider
‚îú‚îÄ‚îÄ tests/                        # Tests
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py              # Pytest fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_basic.py            # Basic tests
‚îÇ   ‚îú‚îÄ‚îÄ test_api.py              # API tests
‚îÇ   ‚îî‚îÄ‚îÄ test_jsql.py             # JSQL parser and executor tests
‚îú‚îÄ‚îÄ examples/                     # Usage examples
‚îÇ   ‚îú‚îÄ‚îÄ basic_usage.py           # Basic CRUD operations
‚îÇ   ‚îú‚îÄ‚îÄ api_usage.py             # API usage with access control
‚îÇ   ‚îî‚îÄ‚îÄ jsql_usage.py            # JSQL query examples
‚îú‚îÄ‚îÄ docs/                         # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ 20251201-010207-intro.md
‚îÇ   ‚îú‚îÄ‚îÄ 20251202-050343-log-concept.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260103-130403-log-impl_proposal.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-142932-log-impl_proposal-entity_handlers.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195602-doc-API_IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195632-doc-API_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195714-doc-PROJECT_STRUCTURE.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195802-doc-QUICKSTART.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-203856-log-project_setup.md
‚îÇ   ‚îî‚îÄ‚îÄ 20260104-220450-doc-JSQL_SPECIFICATION.md
‚îú‚îÄ‚îÄ context_portal/              # ConPort data (gitignored)
‚îú‚îÄ‚îÄ logs/                        # Logs (gitignored)
‚îú‚îÄ‚îÄ README.md                    # Project overview
‚îú‚îÄ‚îÄ PROJECT_STRUCTURE.md         # This file
‚îú‚îÄ‚îÄ pyproject.toml              # Project configuration
‚îî‚îÄ‚îÄ .gitignore                  # Git ignore rules
```

## Package Import Structure

After installation, the package can be imported as:

```python
from namerec.uma import (
    # Main class
    UMA,
    
    # Core types
    EntityName,
    Operation,
    EntityHandler,
    MetadataProvider,
    UMAContext,
    NamespaceConfig,
    
    # Exceptions
    UMAError,
    UMAAccessDeniedError,
    UMANotFoundError,
    UMANotImplementedError,
    UMAValidationError,
    
    # Utils
    parse_entity_name,
    form_entity_name,
    copy_field_meta,
    is_virtual_view,
    
    # Handlers
    DefaultEntityHandler,
    VirtualViewHandler,
    
    # Registry
    EntityRegistry,
    
    # Metadata
    DefaultMetadataProvider,
)
```

## Key Components

### Core Module (`namerec.uma.core`)

- **types.py**: Defines core types and protocols
  - `EntityName`: Structured entity name with optional namespace
  - `Operation`: Enum for UMA operations (SELECT, READ, CREATE, UPDATE, DELETE, META)
  - `EntityHandler`: Protocol for entity handlers
  - `MetadataProvider`: Protocol for metadata providers

- **context.py**: Execution context
  - `UMAContext`: Contains engine, metadata, metadata_provider, user_context, cache, and extra fields

- **exceptions.py**: Exception hierarchy
  - `UMAError`: Base exception
  - `UMAAccessDeniedError`: Access denied
  - `UMANotFoundError`: Entity/record not found
  - `UMANotImplementedError`: Operation not implemented
  - `UMAValidationError`: Validation error

- **utils.py**: Utility functions
  - `parse_entity_name()`: Parse entity name string
  - `form_entity_name()`: Create EntityName from components
  - `copy_field_meta()`: Copy field metadata from source entity
  - `is_virtual_view()`: Check if entity is virtual view

### Handlers Module (`namerec.uma.handlers`)

- **base.py**: Default handler for database tables
  - `DefaultEntityHandler`: Implements all operations for regular tables
  - Supports simple and composite primary keys
  - Automatic metadata extraction from SQLAlchemy

- **virtual.py**: Base class for virtual views
  - `VirtualViewHandler`: Base class with default implementations
  - Raises `UMANotImplementedError` for operations that must be overridden
  - Automatically marks metadata with `is_virtual_view=True`

### Registry Module (`namerec.uma.registry`)

- `EntityRegistry`: Maps entity names to handlers
- Global registry singleton pattern
- Fallback to default handler for unregistered entities
- Auto-discovery of database tables

### Metadata Module (`namerec.uma.metadata`)

- `DefaultMetadataProvider`: Stores and retrieves custom metadata
- Can be extended for Redis or other storage backends

## Design Principles

1. **Stateless Handlers**: Entity handlers are classes with only classmethods, no instance state
2. **Explicit Context**: All necessary dependencies passed via `UMAContext`
3. **Protocol-Based**: Uses Python protocols for type safety and flexibility
4. **Async-First**: All operations are async for better scalability
5. **Extensible**: Easy to extend with custom handlers, metadata providers, and context fields

## Development Workflow

### Setup

```bash
# Install dependencies
uv sync --dev

# Run tests
uv run pytest

# Run linters
ruff check src/
mypy src/
```

### Creating Custom Handlers

1. Inherit from `DefaultEntityHandler` or `VirtualViewHandler`
2. Override necessary methods
3. Register with `EntityRegistry`

Example:

```python
from namerec.uma import VirtualViewHandler, UMA, DefaultMetadataProvider, NamespaceConfig

class MyView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        # Implementation
        pass

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
uma.registry.register('my_view', MyView)
```

## Testing Strategy

- Unit tests for core components
- Integration tests with SQLite in-memory database
- Async tests using pytest-asyncio
- Fixtures in `conftest.py` for common setup

## Future Enhancements

- JSQL parser (JSON to SQLAlchemy) - ‚úÖ Implemented (see [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md))
- Access control hooks
- Query executor
- API layer (uma_select, uma_read, uma_save, etc.) - ‚úÖ Implemented
- Support for many-to-many relationships
- Caching layer
- Performance optimizations

```

```markdown
# UMA Project Structure

This document describes the structure of the UMA (Unified Model Access) project.

## Directory Layout

```
uma2/
‚îú‚îÄ‚îÄ src/                          # Source code (src-layout)
‚îÇ   ‚îî‚îÄ‚îÄ namerec/                  # Vendor namespace
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py           # Namespace package marker
‚îÇ       ‚îî‚îÄ‚îÄ uma/                  # UMA package
‚îÇ           ‚îú‚îÄ‚îÄ __init__.py       # Public API exports
‚îÇ           ‚îú‚îÄ‚îÄ py.typed          # PEP 561 marker for type checking
‚îÇ           ‚îú‚îÄ‚îÄ core/             # Core components
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # Type definitions (EntityName, Operation, Protocols)
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ context.py    # UMAContext
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # Exception hierarchy
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ utils.py      # Utility functions
‚îÇ           ‚îú‚îÄ‚îÄ handlers/         # Entity handlers
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ base.py       # DefaultEntityHandler
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ virtual.py    # VirtualViewHandler
‚îÇ           ‚îú‚îÄ‚îÄ jsql/             # JSQL (JSON-SQL) implementation
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ types.py      # JSQL type definitions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.py # JSQL-specific exceptions
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ parser.py     # JSQL to SQLAlchemy parser
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ executor.py   # JSQL query executor
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ result.py     # Result builder with metadata
‚îÇ           ‚îú‚îÄ‚îÄ application.py    # UMA application class
‚îÇ           ‚îú‚îÄ‚îÄ registry.py       # EntityRegistry
‚îÇ           ‚îî‚îÄ‚îÄ metadata.py       # DefaultMetadataProvider
‚îú‚îÄ‚îÄ tests/                        # Tests
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py              # Pytest fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_basic.py            # Basic tests
‚îÇ   ‚îú‚îÄ‚îÄ test_api.py              # API tests
‚îÇ   ‚îî‚îÄ‚îÄ test_jsql.py             # JSQL parser and executor tests
‚îú‚îÄ‚îÄ examples/                     # Usage examples
‚îÇ   ‚îú‚îÄ‚îÄ basic_usage.py           # Basic CRUD operations
‚îÇ   ‚îú‚îÄ‚îÄ api_usage.py             # API usage with access control
‚îÇ   ‚îî‚îÄ‚îÄ jsql_usage.py            # JSQL query examples
‚îú‚îÄ‚îÄ docs/                         # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ 20251201-010207-intro.md
‚îÇ   ‚îú‚îÄ‚îÄ 20251202-050343-log-concept.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260103-130403-log-impl_proposal.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-142932-log-impl_proposal-entity_handlers.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195602-doc-API_IMPLEMENTATION_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195632-doc-API_SUMMARY.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195714-doc-PROJECT_STRUCTURE.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-195802-doc-QUICKSTART.md
‚îÇ   ‚îú‚îÄ‚îÄ 20260104-203856-log-project_setup.md
‚îÇ   ‚îî‚îÄ‚îÄ 20260104-220450-doc-JSQL_SPECIFICATION.md
‚îú‚îÄ‚îÄ context_portal/              # ConPort data (gitignored)
‚îú‚îÄ‚îÄ logs/                        # Logs (gitignored)
‚îú‚îÄ‚îÄ README.md                    # Project overview
‚îú‚îÄ‚îÄ PROJECT_STRUCTURE.md         # This file
‚îú‚îÄ‚îÄ pyproject.toml              # Project configuration
‚îî‚îÄ‚îÄ .gitignore                  # Git ignore rules
```

## Package Import Structure

After installation, the package can be imported as:

```python
from namerec.uma import (
    # Main class
    UMA,
    
    # Core types
    EntityName,
    Operation,
    EntityHandler,
    MetadataProvider,
    UMAContext,
    NamespaceConfig,
    
    # Exceptions
    UMAError,
    UMAAccessDeniedError,
    UMANotFoundError,
    UMANotImplementedError,
    UMAValidationError,
    
    # Utils
    parse_entity_name,
    form_entity_name,
    copy_field_meta,
    is_virtual_view,
    
    # Handlers
    DefaultEntityHandler,
    VirtualViewHandler,
    
    # Registry
    EntityRegistry,
    
    # Metadata
    DefaultMetadataProvider,
)
```

## Key Components

### Core Module (`namerec.uma.core`)

- **types.py**: Defines core types and protocols
  - `EntityName`: Structured entity name with optional namespace
  - `Operation`: Enum for UMA operations (SELECT, READ, CREATE, UPDATE, DELETE, META)
  - `EntityHandler`: Protocol for entity handlers
  - `MetadataProvider`: Protocol for metadata providers

- **context.py**: Execution context
  - `UMAContext`: Contains engine, metadata, metadata_provider, user_context, cache, and extra fields

- **exceptions.py**: Exception hierarchy
  - `UMAError`: Base exception
  - `UMAAccessDeniedError`: Access denied
  - `UMANotFoundError`: Entity/record not found
  - `UMANotImplementedError`: Operation not implemented
  - `UMAValidationError`: Validation error

- **utils.py**: Utility functions
  - `parse_entity_name()`: Parse entity name string
  - `form_entity_name()`: Create EntityName from components
  - `copy_field_meta()`: Copy field metadata from source entity
  - `is_virtual_view()`: Check if entity is virtual view

### Handlers Module (`namerec.uma.handlers`)

- **base.py**: Default handler for database tables
  - `DefaultEntityHandler`: Implements all operations for regular tables
  - Supports simple and composite primary keys
  - Automatic metadata extraction from SQLAlchemy

- **virtual.py**: Base class for virtual views
  - `VirtualViewHandler`: Base class with default implementations
  - Raises `UMANotImplementedError` for operations that must be overridden
  - Automatically marks metadata with `is_virtual_view=True`

### Registry Module (`namerec.uma.registry`)

- `EntityRegistry`: Maps entity names to handlers
- Global registry singleton pattern
- Fallback to default handler for unregistered entities
- Auto-discovery of database tables

### Metadata Module (`namerec.uma.metadata`)

- `DefaultMetadataProvider`: Stores and retrieves custom metadata
- Can be extended for Redis or other storage backends

## Design Principles

1. **Stateless Handlers**: Entity handlers are classes with only classmethods, no instance state
2. **Explicit Context**: All necessary dependencies passed via `UMAContext`
3. **Protocol-Based**: Uses Python protocols for type safety and flexibility
4. **Async-First**: All operations are async for better scalability
5. **Extensible**: Easy to extend with custom handlers, metadata providers, and context fields

## Development Workflow

### Setup

```bash
# Install dependencies
uv sync --dev

# Run tests
uv run pytest

# Run linters
ruff check src/
mypy src/
```

### Creating Custom Handlers

1. Inherit from `DefaultEntityHandler` or `VirtualViewHandler`
2. Override necessary methods
3. Register with `EntityRegistry`

Example:

```python
from namerec.uma import VirtualViewHandler, UMA, DefaultMetadataProvider, NamespaceConfig

class MyView(VirtualViewHandler):
    @classmethod
    async def select(cls, entity_name, params, context):
        # Implementation
        pass

uma = UMA.create({
    'main': NamespaceConfig(
        engine=engine,
        metadata_provider=DefaultMetadataProvider(),
    ),
})
uma.registry.register('my_view', MyView)
```

## Testing Strategy

- Unit tests for core components
- Integration tests with SQLite in-memory database
- Async tests using pytest-asyncio
- Fixtures in `conftest.py` for common setup

## Future Enhancements

- JSQL parser (JSON to SQLAlchemy) - ‚úÖ Implemented (see [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md))
- Access control hooks - ‚úÖ Implemented (via MetadataProvider.can())
- Query executor - ‚úÖ Implemented (JSQLExecutor)
- API layer (UMA class with methods) - ‚úÖ Implemented
- Support for many-to-many relationships
- Caching layer - ‚úÖ Implemented (MemoryCacheBackend, RedisCacheBackend)
- Performance optimizations

```

```markdown
# SQL ‚Üî JSQL Conversion Guide

## Overview

UMA provides bidirectional conversion between SQL and JSQL (JSON-SQL) formats. This allows you to:

- Convert JSQL queries to SQL for debugging and inspection
- Convert SQL queries to JSQL for programmatic use
- Debug JSQL queries by viewing the generated SQL

## Features

### 1. Debug Mode in JSQL Queries

Enable debug mode to see the generated SQL alongside your query results.

#### Usage

Add `"debug": true` to your JSQL query at the root level (same level as `from` and `select`):

```python
import asyncio
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import MetaData

async def main():
    # Initialize UMA
    engine = create_async_engine('sqlite+aiosqlite:///mydb.db')
    metadata = MetaData()
    await engine.run_sync(metadata.reflect)
    
    uma = UMA.create({
        'main': NamespaceConfig(
            engine=engine,
            metadata_provider=DefaultMetadataProvider(),
        ),
    })

    # Query with debug mode enabled
    jsql = {
        "from": "users",
        "select": [
            {"field": "id"},
            {"field": "name"}
        ],
        "where": {
            "field": "active",
            "op": "=",
            "value": True
        },
        "debug": True  # Enable debug mode
    }

    result = await uma.select(jsql)
    result_dict = result  # Already a dict

    # Access debug SQL
    print("Generated SQL:")
    print(result_dict['debug'])
    print("\nData:")
    print(result_dict['data'])

asyncio.run(main())
```

#### Response Format

When debug mode is enabled, the response includes a `debug` field at the root level:

```json
{
  "meta": [
    {"name": "id", "type": "INTEGER", "nullable": false, ...},
    {"name": "name", "type": "VARCHAR", "nullable": false, ...}
  ],
  "data": [
    [1, "Alice"],
    [2, "Bob"]
  ],
  "debug": "SELECT users.id,\n       users.name\nFROM users\nWHERE users.active = TRUE"
}
```

The debug SQL is formatted for readability with:
- Keywords in UPPERCASE
- Proper indentation
- Parameter values substituted (literal binds)

### 2. Console Script

UMA provides a unified `convert-query` script with automatic format detection:

#### convert-query - Bidirectional Conversion with Auto-Detection

The script automatically detects input format:
- **JSON input** ‚Üí converts to SQL
- **Text input** ‚Üí converts to JSQL

```bash
# Auto-detect: JSON ‚Üí SQL
echo '{"from": "users", "select": [{"field": "id"}, {"field": "name"}]}' | uv run convert-query

# Auto-detect: SQL ‚Üí JSQL
echo "SELECT id, name FROM users WHERE active = 1" | uv run convert-query

# From file (auto-detect)
uv run convert-query input.json
uv run convert-query query.sql

# Force specific output format
echo "SELECT * FROM users" | uv run convert-query --format jsql
echo '{"from": "users", "select": [{"field": "*"}]}' | uv run convert-query --format sql

# Specify SQL dialect
uv run convert-query input.json --dialect postgresql

# Compact output (no formatting)
echo '{"from": "users", "select": [{"field": "id"}]}' | uv run convert-query --no-pretty
```

**Options:**
- `-d, --dialect`: SQL dialect (generic, postgresql, mysql, sqlite, etc.) [default: generic]
- `--pretty/--no-pretty`: Pretty print output [default: pretty]
- `-f, --format`: Force output format (`sql` or `jsql`) [default: auto-detect]

**Example 1: JSQL ‚Üí SQL (auto-detected)**

Input:
```json
{
  "from": "users",
  "select": [{"field": "id"}, {"field": "name"}],
  "where": {"field": "active", "op": "=", "value": true},
  "limit": 10
}
```

Command:
```bash
echo '<jsql>' | uv run convert-query
```

Output:
```sql
SELECT users.id,
       users.name
FROM users
WHERE users.active = TRUE
LIMIT 10
```

**Example 2: SQL ‚Üí JSQL (auto-detected)**

Input:
```sql
SELECT id, name FROM users WHERE active = 1 ORDER BY name LIMIT 10
```

Command:
```bash
echo "SELECT id, name FROM users WHERE active = 1 ORDER BY name LIMIT 10" | uv run convert-query
```

Output:
```json
{
  "from": "users",
  "select": [
    {"field": "id"},
    {"field": "name"}
  ],
  "where": {
    "field": "active",
    "op": "=",
    "value": 1
  },
  "order_by": [
    {"field": "name", "direction": "ASC"}
  ],
  "limit": 10
}
```

### 3. Programmatic API

Use the converter functions directly in your Python code:

```python
from namerec.uma.jsql.converter import jsql_to_sql, sql_to_jsql

# JSQL to SQL
jsql = {
    "from": "users",
    "select": [{"field": "id"}, {"field": "name"}],
    "where": {"field": "active", "op": "=", "value": True}
}
sql = jsql_to_sql(jsql, dialect='postgresql')
print(sql)

# SQL to JSQL
sql = "SELECT id, name FROM users WHERE active = 1"
jsql = sql_to_jsql(sql, dialect='generic')
print(jsql)
```

## Supported Features

### JSQL ‚Üí SQL Conversion

The `jsql_to_sql()` function supports all JSQL features:

- ‚úÖ SELECT with fields and aliases
- ‚úÖ WHERE with all operators (=, !=, <, >, <=, >=, AND, OR, NOT, IN, LIKE, EXISTS, IS NULL)
- ‚úÖ JOINs (INNER, LEFT, RIGHT, FULL, CROSS)
- ‚úÖ Aggregations (COUNT, SUM, AVG, MIN, MAX)
- ‚úÖ GROUP BY and HAVING
- ‚úÖ ORDER BY (including by aliases)
- ‚úÖ LIMIT and OFFSET
- ‚úÖ CTEs (Common Table Expressions)
- ‚úÖ Subqueries
- ‚úÖ Window functions
- ‚úÖ Parameterized queries

### SQL ‚Üí JSQL Conversion

The `sql_to_jsql()` function supports:

- ‚úÖ SELECT with fields and aliases
- ‚úÖ WHERE with comparison operators (=, !=, <, >, <=, >=)
- ‚úÖ WHERE with logical operators (AND, OR, NOT)
- ‚úÖ WHERE with IN and LIKE
- ‚úÖ JOINs (INNER, LEFT, RIGHT, FULL)
- ‚úÖ Aggregation functions (COUNT, SUM, etc.)
- ‚úÖ GROUP BY and HAVING
- ‚úÖ ORDER BY with direction
- ‚úÖ LIMIT and OFFSET
- ‚ö†Ô∏è Limited CTE support
- ‚ö†Ô∏è Limited subquery support
- ‚ö†Ô∏è Limited window function support

**Note:** SQL ‚Üí JSQL conversion uses the `sqlglot` library for parsing. Complex queries may not be fully supported. Always test the conversion output for correctness.

## Error Handling

Both conversion functions raise `JSQLSyntaxError` on invalid input:

```python
from namerec.uma.jsql.converter import sql_to_jsql
from namerec.uma.jsql.exceptions import JSQLSyntaxError

try:
    jsql = sql_to_jsql("INVALID SQL")
except JSQLSyntaxError as e:
    print(f"Error: {e.message}")
    if e.path:
        print(f"Path: {e.path}")
```

## SQL Dialects

The converter supports multiple SQL dialects via the `dialect` parameter:

- `generic` - Generic SQL (default)
- `postgresql` - PostgreSQL
- `mysql` - MySQL
- `sqlite` - SQLite
- `mssql` - Microsoft SQL Server
- `oracle` - Oracle Database
- `snowflake` - Snowflake
- `bigquery` - Google BigQuery
- `redshift` - Amazon Redshift
- And many more...

**Note:** Dialect conversion uses `sqlglot` for transpilation. Not all SQL features may be supported across all dialects.

## Use Cases

### 1. Debugging JSQL Queries

Enable debug mode to see the actual SQL being executed:

```python
jsql = {
    "from": "orders",
    "select": [
        {"func": "SUM", "args": [{"field": "amount"}], "alias": "total"}
    ],
    "joins": [
        {
            "type": "INNER",
            "entity": "customers",
            "on": {"field": "orders.customer_id", "op": "=", "right_field": "customers.id"}
        }
    ],
    "group_by": [{"field": "customers.id"}],
    "debug": True
}

result = await uma_select(jsql)
print(result.to_dict()['debug'])
```

### 2. Learning JSQL Syntax

Convert SQL you're familiar with to JSQL to learn the syntax:

```bash
echo "SELECT id, name FROM users WHERE email LIKE '%@example.com' ORDER BY name DESC" | \
  uv run python sql2jsql.py
```

### 3. Migrating from SQL to JSQL

Convert existing SQL queries to JSQL for use in your application:

```bash
# Convert a file with SQL queries
uv run python sql2jsql.py existing_queries.sql > converted_jsql.json
```

### 4. Generating SQL Documentation

Generate SQL versions of your JSQL queries for documentation:

```bash
# Convert JSQL queries to SQL for documentation
uv run python jsql2sql.py api_queries.json > api_queries.sql
```

### 5. Cross-Database Testing

Test the same query across different databases:

```python
from namerec.uma.jsql.converter import jsql_to_sql

jsql = {"from": "users", "select": [{"field": "*"}], "limit": 10}

# Generate SQL for different databases
pg_sql = jsql_to_sql(jsql, dialect='postgresql')
mysql_sql = jsql_to_sql(jsql, dialect='mysql')
mssql_sql = jsql_to_sql(jsql, dialect='mssql')

print("PostgreSQL:", pg_sql)
print("MySQL:", mysql_sql)
print("MSSQL:", mssql_sql)
```

## Limitations

### SQL ‚Üí JSQL Conversion

- Only `SELECT` queries are supported (no INSERT, UPDATE, DELETE)
- Complex subqueries may not be fully preserved
- Window functions may require manual adjustment
- CTEs (WITH clauses) have limited support
- Some dialect-specific features may not convert correctly

### JSQL ‚Üí SQL Conversion

- Requires a temporary SQLite engine for parsing (lightweight, no database needed)
- Parameterized queries are rendered with literal values for debugging
- Custom functions may not be available in all dialects

## Best Practices

1. **Always test converted queries**: SQL ‚Üí JSQL conversion is best-effort. Always test the output.

2. **Use debug mode during development**: Enable debug mode to understand what SQL is being generated.

3. **Specify dialect when needed**: Use the appropriate dialect parameter for database-specific SQL.

4. **Format for readability**: Use `--pretty` (default) for human-readable output.

5. **Validate complex queries**: For queries with CTEs, window functions, or subqueries, manually verify the conversion.

## Dependencies

The conversion features require additional packages:

```toml
dependencies = [
    "sqlalchemy>=2.0.0",
    "sqlglot>=25.0.0",  # For SQL parsing and transpilation
    "sqlparse>=0.5.0",  # For SQL formatting
    "click>=8.1.0",     # For console scripts
]
```

These are automatically installed when you install UMA.

## Examples

See `examples/converter_usage.py` for complete working examples of all conversion features.

## Troubleshooting

### "Failed to parse SQL"

- Check that your SQL is valid SELECT syntax
- Try specifying the correct dialect with `-d`
- Some complex SQL features may not be supported

### "Invalid JSQL"

- Verify that your JSQL follows the correct structure
- Check the error message for the specific path where the error occurred
- See `docs/20260104-220450-doc-JSQL_SPECIFICATION.md` for full JSQL syntax

### "Import error: sqlglot not found"

Install dependencies:
```bash
uv pip install sqlglot sqlparse click
```

## See Also

- [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md) - Complete JSQL syntax reference
- [Quickstart Guide](20260104-195802-doc-QUICKSTART.md) - Getting started with UMA
- [API Summary](20260104-195632-doc-API_SUMMARY.md) - Complete API reference

```


–û–±–Ω–æ–≤–ª—è—é –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –≤ SQL_JSQL_CONVERSION.md:



–ò—Å–ø—Ä–∞–≤–ª—è—é –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–∏–º–µ—Ä –≤ SQL_JSQL_CONVERSION.md:


```markdown
# SQL ‚Üî JSQL Conversion Guide

## Overview

UMA provides bidirectional conversion between SQL and JSQL (JSON-SQL) formats. This allows you to:

- Convert JSQL queries to SQL for debugging and inspection
- Convert SQL queries to JSQL for programmatic use
- Debug JSQL queries by viewing the generated SQL

## Features

### 1. Debug Mode in JSQL Queries

Enable debug mode to see the generated SQL alongside your query results.

#### Usage

Add `"debug": true` to your JSQL query at the root level (same level as `from` and `select`):

```python
import asyncio
from namerec.uma import UMA, DefaultMetadataProvider, NamespaceConfig
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import MetaData

async def main():
    # Initialize UMA
    engine = create_async_engine('sqlite+aiosqlite:///mydb.db')
    metadata = MetaData()
    await engine.run_sync(metadata.reflect)
    
    uma = UMA.create({
        'main': NamespaceConfig(
            engine=engine,
            metadata_provider=DefaultMetadataProvider(),
        ),
    })

    # Query with debug mode enabled
    jsql = {
        "from": "users",
        "select": [
            {"field": "id"},
            {"field": "name"}
        ],
        "where": {
            "field": "active",
            "op": "=",
            "value": True
        },
        "debug": True  # Enable debug mode
    }

    result = await uma.select(jsql)
    result_dict = result  # Already a dict

    # Access debug SQL
    print("Generated SQL:")
    print(result_dict['debug'])
    print("\nData:")
    print(result_dict['data'])

asyncio.run(main())
```

#### Response Format

When debug mode is enabled, the response includes a `debug` field at the root level:

```json
{
  "meta": [
    {"name": "id", "type": "INTEGER", "nullable": false, ...},
    {"name": "name", "type": "VARCHAR", "nullable": false, ...}
  ],
  "data": [
    [1, "Alice"],
    [2, "Bob"]
  ],
  "debug": "SELECT users.id,\n       users.name\nFROM users\nWHERE users.active = TRUE"
}
```

The debug SQL is formatted for readability with:
- Keywords in UPPERCASE
- Proper indentation
- Parameter values substituted (literal binds)

### 2. Console Script

UMA provides a unified `convert-query` script with automatic format detection:

#### convert-query - Bidirectional Conversion with Auto-Detection

The script automatically detects input format:
- **JSON input** ‚Üí converts to SQL
- **Text input** ‚Üí converts to JSQL

```bash
# Auto-detect: JSON ‚Üí SQL
echo '{"from": "users", "select": [{"field": "id"}, {"field": "name"}]}' | uv run convert-query

# Auto-detect: SQL ‚Üí JSQL
echo "SELECT id, name FROM users WHERE active = 1" | uv run convert-query

# From file (auto-detect)
uv run convert-query input.json
uv run convert-query query.sql

# Force specific output format
echo "SELECT * FROM users" | uv run convert-query --format jsql
echo '{"from": "users", "select": [{"field": "*"}]}' | uv run convert-query --format sql

# Specify SQL dialect
uv run convert-query input.json --dialect postgresql

# Compact output (no formatting)
echo '{"from": "users", "select": [{"field": "id"}]}' | uv run convert-query --no-pretty
```

**Options:**
- `-d, --dialect`: SQL dialect (generic, postgresql, mysql, sqlite, etc.) [default: generic]
- `--pretty/--no-pretty`: Pretty print output [default: pretty]
- `-f, --format`: Force output format (`sql` or `jsql`) [default: auto-detect]

**Example 1: JSQL ‚Üí SQL (auto-detected)**

Input:
```json
{
  "from": "users",
  "select": [{"field": "id"}, {"field": "name"}],
  "where": {"field": "active", "op": "=", "value": true},
  "limit": 10
}
```

Command:
```bash
echo '<jsql>' | uv run convert-query
```

Output:
```sql
SELECT users.id,
       users.name
FROM users
WHERE users.active = TRUE
LIMIT 10
```

**Example 2: SQL ‚Üí JSQL (auto-detected)**

Input:
```sql
SELECT id, name FROM users WHERE active = 1 ORDER BY name LIMIT 10
```

Command:
```bash
echo "SELECT id, name FROM users WHERE active = 1 ORDER BY name LIMIT 10" | uv run convert-query
```

Output:
```json
{
  "from": "users",
  "select": [
    {"field": "id"},
    {"field": "name"}
  ],
  "where": {
    "field": "active",
    "op": "=",
    "value": 1
  },
  "order_by": [
    {"field": "name", "direction": "ASC"}
  ],
  "limit": 10
}
```

### 3. Programmatic API

Use the converter functions directly in your Python code:

```python
from namerec.uma.jsql.converter import jsql_to_sql, sql_to_jsql

# JSQL to SQL
jsql = {
    "from": "users",
    "select": [{"field": "id"}, {"field": "name"}],
    "where": {"field": "active", "op": "=", "value": True}
}
sql = jsql_to_sql(jsql, dialect='postgresql')
print(sql)

# SQL to JSQL
sql = "SELECT id, name FROM users WHERE active = 1"
jsql = sql_to_jsql(sql, dialect='generic')
print(jsql)
```

## Supported Features

### JSQL ‚Üí SQL Conversion

The `jsql_to_sql()` function supports all JSQL features:

- ‚úÖ SELECT with fields and aliases
- ‚úÖ WHERE with all operators (=, !=, <, >, <=, >=, AND, OR, NOT, IN, LIKE, EXISTS, IS NULL)
- ‚úÖ JOINs (INNER, LEFT, RIGHT, FULL, CROSS)
- ‚úÖ Aggregations (COUNT, SUM, AVG, MIN, MAX)
- ‚úÖ GROUP BY and HAVING
- ‚úÖ ORDER BY (including by aliases)
- ‚úÖ LIMIT and OFFSET
- ‚úÖ CTEs (Common Table Expressions)
- ‚úÖ Subqueries
- ‚úÖ Window functions
- ‚úÖ Parameterized queries

### SQL ‚Üí JSQL Conversion

The `sql_to_jsql()` function supports:

- ‚úÖ SELECT with fields and aliases
- ‚úÖ WHERE with comparison operators (=, !=, <, >, <=, >=)
- ‚úÖ WHERE with logical operators (AND, OR, NOT)
- ‚úÖ WHERE with IN and LIKE
- ‚úÖ JOINs (INNER, LEFT, RIGHT, FULL)
- ‚úÖ Aggregation functions (COUNT, SUM, etc.)
- ‚úÖ GROUP BY and HAVING
- ‚úÖ ORDER BY with direction
- ‚úÖ LIMIT and OFFSET
- ‚ö†Ô∏è Limited CTE support
- ‚ö†Ô∏è Limited subquery support
- ‚ö†Ô∏è Limited window function support

**Note:** SQL ‚Üí JSQL conversion uses the `sqlglot` library for parsing. Complex queries may not be fully supported. Always test the conversion output for correctness.

## Error Handling

Both conversion functions raise `JSQLSyntaxError` on invalid input:

```python
from namerec.uma.jsql.converter import sql_to_jsql
from namerec.uma.jsql.exceptions import JSQLSyntaxError

try:
    jsql = sql_to_jsql("INVALID SQL")
except JSQLSyntaxError as e:
    print(f"Error: {e.message}")
    if e.path:
        print(f"Path: {e.path}")
```

## SQL Dialects

The converter supports multiple SQL dialects via the `dialect` parameter:

- `generic` - Generic SQL (default)
- `postgresql` - PostgreSQL
- `mysql` - MySQL
- `sqlite` - SQLite
- `mssql` - Microsoft SQL Server
- `oracle` - Oracle Database
- `snowflake` - Snowflake
- `bigquery` - Google BigQuery
- `redshift` - Amazon Redshift
- And many more...

**Note:** Dialect conversion uses `sqlglot` for transpilation. Not all SQL features may be supported across all dialects.

## Use Cases

### 1. Debugging JSQL Queries

Enable debug mode to see the actual SQL being executed:

```python
jsql = {
    "from": "orders",
    "select": [
        {"func": "SUM", "args": [{"field": "amount"}], "alias": "total"}
    ],
    "joins": [
        {
            "type": "INNER",
            "entity": "customers",
            "on": {"field": "orders.customer_id", "op": "=", "right_field": "customers.id"}
        }
    ],
    "group_by": [{"field": "customers.id"}],
    "debug": True
}

result = await uma.select(jsql)
print(result['debug'])
```

### 2. Learning JSQL Syntax

Convert SQL you're familiar with to JSQL to learn the syntax:

```bash
echo "SELECT id, name FROM users WHERE email LIKE '%@example.com' ORDER BY name DESC" | \
  uv run python sql2jsql.py
```

### 3. Migrating from SQL to JSQL

Convert existing SQL queries to JSQL for use in your application:

```bash
# Convert a file with SQL queries
uv run python sql2jsql.py existing_queries.sql > converted_jsql.json
```

### 4. Generating SQL Documentation

Generate SQL versions of your JSQL queries for documentation:

```bash
# Convert JSQL queries to SQL for documentation
uv run python jsql2sql.py api_queries.json > api_queries.sql
```

### 5. Cross-Database Testing

Test the same query across different databases:

```python
from namerec.uma.jsql.converter import jsql_to_sql

jsql = {"from": "users", "select": [{"field": "*"}], "limit": 10}

# Generate SQL for different databases
pg_sql = jsql_to_sql(jsql, dialect='postgresql')
mysql_sql = jsql_to_sql(jsql, dialect='mysql')
mssql_sql = jsql_to_sql(jsql, dialect='mssql')

print("PostgreSQL:", pg_sql)
print("MySQL:", mysql_sql)
print("MSSQL:", mssql_sql)
```

## Limitations

### SQL ‚Üí JSQL Conversion

- Only `SELECT` queries are supported (no INSERT, UPDATE, DELETE)
- Complex subqueries may not be fully preserved
- Window functions may require manual adjustment
- CTEs (WITH clauses) have limited support
- Some dialect-specific features may not convert correctly

### JSQL ‚Üí SQL Conversion

- Requires a temporary SQLite engine for parsing (lightweight, no database needed)
- Parameterized queries are rendered with literal values for debugging
- Custom functions may not be available in all dialects

## Best Practices

1. **Always test converted queries**: SQL ‚Üí JSQL conversion is best-effort. Always test the output.

2. **Use debug mode during development**: Enable debug mode to understand what SQL is being generated.

3. **Specify dialect when needed**: Use the appropriate dialect parameter for database-specific SQL.

4. **Format for readability**: Use `--pretty` (default) for human-readable output.

5. **Validate complex queries**: For queries with CTEs, window functions, or subqueries, manually verify the conversion.

## Dependencies

The conversion features require additional packages:

```toml
dependencies = [
    "sqlalchemy>=2.0.0",
    "sqlglot>=25.0.0",  # For SQL parsing and transpilation
    "sqlparse>=0.5.0",  # For SQL formatting
    "click>=8.1.0",     # For console scripts
]
```

These are automatically installed when you install UMA.

## Examples

See `examples/converter_usage.py` for complete working examples of all conversion features.

## Troubleshooting

### "Failed to parse SQL"

- Check that your SQL is valid SELECT syntax
- Try specifying the correct dialect with `-d`
- Some complex SQL features may not be supported

### "Invalid JSQL"

- Verify that your JSQL follows the correct structure
- Check the error message for the specific path where the error occurred
- See `docs/20260104-220450-doc-JSQL_SPECIFICATION.md` for full JSQL syntax

### "Import error: sqlglot not found"

Install dependencies:
```bash
uv pip install sqlglot sqlparse click
```

## See Also

- [JSQL Specification](20260104-220450-doc-JSQL_SPECIFICATION.md) - Complete JSQL syntax reference
- [Quickstart Guide](20260104-195802-doc-QUICKSTART.md) - Getting started with UMA
- [API Summary](20260104-195632-doc-API_SUMMARY.md) - Complete API reference

```


–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞. –ò—Ç–æ–≥–∏:

## –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã

1. **QUICKSTART.md** ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω –ø–æ–¥ –Ω–æ–≤—ã–π API:
   - `initialize_uma()` ‚Üí `UMA.create()`
   - `uma_read()`, `uma_save()`, etc. ‚Üí `uma.read()`, `uma.save()`, etc.
   - `uma_meta()` ‚Üí `uma.entity_details()`
   - `uma_list_entities()` ‚Üí `uma.entity_list()`
   - `uma_select()` ‚Üí `uma.select()`
   - –£–±—Ä–∞–Ω—ã —É–ø–æ–º–∏–Ω–∞–Ω–∏—è `get_registry()`, `init_global_registry()`

2. **API_SUMMARY.md** ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω:
   - –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ –º–µ—Ç–æ–¥—ã –∫–ª–∞—Å—Å–∞ `UMA`
   - –î–æ–±–∞–≤–ª–µ–Ω—ã –ø—Ä–∏–º–µ—Ä—ã —Å `NamespaceConfig`
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∏–º–µ—Ä—ã –¥–æ—Å—Ç—É–ø–∞ –∫ registry —á–µ—Ä–µ–∑ `uma.registry`

3. **API_IMPLEMENTATION_SUMMARY.md** ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω:
   - API —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ –º–µ—Ç–æ–¥—ã –∫–ª–∞—Å—Å–∞
   - –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
   - –û—Ç–º–µ—á–µ–Ω–æ, —á—Ç–æ JSQL –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã

4. **PROJECT_STRUCTURE.md** ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω:
   - –ò–º–ø–æ—Ä—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã (—É–±—Ä–∞–Ω—ã `init_global_registry`, `get_global_registry`)
   - –î–æ–±–∞–≤–ª–µ–Ω `UMA` –∏ `NamespaceConfig` –≤ –∏–º–ø–æ—Ä—Ç—ã
   - –ü—Ä–∏–º–µ—Ä—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã

5. **SQL_JSQL_CONVERSION.md** ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω:
   - –ü—Ä–∏–º–µ—Ä—ã —Å `initialize_uma()` ‚Üí `UMA.create()`
   - `uma_select()` ‚Üí `uma.select()`
   - –£–±—Ä–∞–Ω—ã –≤—ã–∑–æ–≤—ã `.to_dict()` (—Ä–µ–∑—É–ª—å—Ç–∞—Ç —É–∂–µ dict)

6. **JSQL_SPECIFICATION.md** ‚Äî –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π (—Ç–æ–ª—å–∫–æ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è JSQL, –±–µ–∑ –ø—Ä–∏–º–µ—Ä–æ–≤ API)

–í—Å–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã —Ç–µ–ø–µ—Ä—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –Ω–æ–≤–æ–º—É API —Å –∫–ª–∞—Å—Å–æ–º `UMA` –∏ –º–µ—Ç–æ–¥–∞–º–∏ –≤–º–µ—Å—Ç–æ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π.

