# –ê–Ω–∞–ª–∏–∑ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∏ –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞
_Exported on 14.01.2026 at 10:19:55 GMT+3 from Cursor (2.3.34)_

---

**User**

–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–ø–æ–ª–Ω–∏ code review —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞.
–û—Å–æ–±–µ–Ω–Ω–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ DRY, –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ SOLID (–æ—Å–æ–±–µ–Ω–Ω–æ SRP), –∞ —Ç–∞–∫–∂–µ –ø—Ä–∏—Å—Ç–∞–ª—å–Ω–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ –∫ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (–∞–ª–≥–æ—Ä–∏—Ç–º –º–∞–ª—è—Ä–∞ –∏ –ø—Ä–æ—á–µ–µ –ø–æ–¥–æ–±–Ω–æ–µ).
–ï—Å–ª–∏ —É–≤–∏–¥–∏—à—å –ø—Ä–æ–±–ª–µ–º—ã —Å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π ‚Äì –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥—Å–≤–µ—Ç–∏ –∏—Ö.

---

**Cursor**

–ü—Ä–æ–≤–µ–¥—É –¥–µ—Ç–∞–ª—å–Ω—ã–π code review –ø—Ä–æ–µ–∫—Ç–∞. –ù–∞—á–Ω—É —Å –∏–∑—É—á–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –∫–ª—é—á–µ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤.

–¢–µ–ø–µ—Ä—å –∏–∑—É—á—É –∫–ª—é—á–µ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞:

–¢–µ–ø–µ—Ä—å –∏–∑—É—á—É JSQL –º–æ–¥—É–ª–∏ –∏ –¥—Ä—É–≥–∏–µ –∫–ª—é—á–µ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:

–¢–µ–ø–µ—Ä—å –ø—Ä–æ—á–∏—Ç–∞—é —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π —Ñ–∞–π–ª converter.py –∏ –¥—Ä—É–≥–∏–µ –≤–∞–∂–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:

–ü—Ä–æ–¥–æ–ª–∂—É —á—Ç–µ–Ω–∏–µ converter.py –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞:

–ü—Ä–æ–≤–µ–¥—É –ø–æ–ª–Ω—ã–π code review –ø—Ä–æ–µ–∫—Ç–∞. –ù–∞—á–Ω—É —Å —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞.

```markdown
# Code Review - UMA Project
**–î–∞—Ç–∞:** 2026-01-13  
**–í–µ—Ä—Å–∏—è:** 2.3

## Executive Summary

–ü—Ä–æ–µ–∫—Ç UMA –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Ö–æ—Ä–æ—à–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É –¥–ª—è —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω—ã–º —á–µ—Ä–µ–∑ JSON-SQL –∑–∞–ø—Ä–æ—Å—ã. –û–¥–Ω–∞–∫–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å —Å–æ–±–ª—é–¥–µ–Ω–∏–µ–º –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ DRY –∏ SOLID, –∞ —Ç–∞–∫–∂–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –Ω–µ–¥–æ—á–µ—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø–æ–≤–ª–∏—è—Ç—å –Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç—å –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å –∫–æ–¥–∞.

## üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã

### 1. –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ API Layer (`api.py`)

**–ü—Ä–æ–±–ª–µ–º–∞:** –§—É–Ω–∫—Ü–∏–∏ `uma_read`, `uma_save`, `uma_delete`, `uma_entity_details` —Å–æ–¥–µ—Ä–∂–∞—Ç –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∏–¥–µ–Ω—Ç–∏—á–Ω—É—é –ª–æ–≥–∏–∫—É:

```python
# –ü–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –ø–∞—Ç—Ç–µ—Ä–Ω –≤ –∫–∞–∂–¥–æ–π —Ñ—É–Ω–∫—Ü–∏–∏:
entity = parse_entity_name(entity_name)
if namespace and not entity.namespace:
    entity = EntityName(entity=entity.entity, namespace=namespace)
context = _create_context(entity.namespace, user_context)
_check_access(str(entity), Operation.XXX, context)
handler = await get_registry().get_handler(entity, context)
return await handler.xxx(entity, ...)
```

**–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –∏–ª–∏ –±–∞–∑–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±—â–µ–π –ª–æ–≥–∏–∫–∏:

```python
async def _execute_entity_operation(
    entity_name: str,
    operation: Operation,
    handler_method: str,
    namespace: str | None = None,
    user_context: Any = None,
    **kwargs: Any
) -> Any:
    """Common logic for entity operations."""
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    context = _create_context(entity.namespace, user_context)
    _check_access(str(entity), operation, context)
    
    handler = await get_registry().get_handler(entity, context)
    method = getattr(handler, handler_method)
    return await method(entity, context, **kwargs)
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üî¥ –í—ã—Å–æ–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 2-3 —á–∞—Å–∞

---

### 2. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (Anti-pattern)

**–ü—Ä–æ–±–ª–µ–º–∞:** –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:
- `api.py`: `_registry`
- `namespace_config.py`: `_namespace_configs`, `_default_namespace`
- `registry.py`: `_global_registry`

–≠—Ç–æ —Å–æ–∑–¥–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã:
- –°–ª–æ–∂–Ω–æ—Å—Ç—å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω—É–∂–Ω–æ —Å–±—Ä–∞—Å—ã–≤–∞—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ç–µ—Å—Ç–∞–º–∏)
- –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–∑–æ–ª–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Å—Ç–∞–Ω—Å—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ü–µ–ª–µ–π
- –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ race conditions –≤ –º–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ–π —Å—Ä–µ–¥–µ

**–†–µ—à–µ–Ω–∏–µ:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∏–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä:

```python
@dataclass
class UMAApplication:
    """UMA application instance with all dependencies."""
    registry: EntityRegistry
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None
    
    async def read(self, entity_name: str, ...) -> dict:
        """Read operation."""
        ...
    
    # ... other operations

# Usage:
uma = UMAApplication(
    registry=EntityRegistry(...),
    namespace_configs={...},
    default_namespace='main'
)
result = await uma.read('users', id=1)
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üî¥ –í—ã—Å–æ–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 8-12 —á–∞—Å–æ–≤ (breaking change)

---

### 3. –ù–∞—Ä—É—à–µ–Ω–∏–µ SRP: –ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π `converter.py` (1033 —Å—Ç—Ä–æ–∫–∏)

**–ü—Ä–æ–±–ª–µ–º–∞:** –§–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π:
1. JSQL ‚Üí SQL –∫–æ–Ω–≤–µ—Ä—Å–∏—é
2. SQL ‚Üí JSQL –∫–æ–Ω–≤–µ—Ä—Å–∏—é
3. –û–±—Ä–∞–±–æ—Ç–∫—É –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
4. –û–±—Ä–∞–±–æ—Ç–∫—É JOIN'–æ–≤
5. –û–±—Ä–∞–±–æ—Ç–∫—É —Ñ—É–Ω–∫—Ü–∏–π
6. –û–±—Ä–∞–±–æ—Ç–∫—É —É—Å–ª–æ–≤–∏–π

**–†–µ—à–µ–Ω–∏–µ:** –†–∞–∑–±–∏—Ç—å –Ω–∞ –º–æ–¥—É–ª–∏:

```
jsql/converter/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ jsql_to_sql.py          # JSQL ‚Üí SQL
‚îú‚îÄ‚îÄ sql_to_jsql.py          # SQL ‚Üí JSQL
‚îú‚îÄ‚îÄ operators.py            # –û–ø–µ—Ä–∞—Ç–æ—Ä—ã (comparison, logical, arithmetic)
‚îú‚îÄ‚îÄ expressions.py          # –í—ã—Ä–∞–∂–µ–Ω–∏—è
‚îú‚îÄ‚îÄ conditions.py           # –£—Å–ª–æ–≤–∏—è
‚îú‚îÄ‚îÄ joins.py                # JOIN'—ã
‚îî‚îÄ‚îÄ functions.py            # –§—É–Ω–∫—Ü–∏–∏
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üî¥ –í—ã—Å–æ–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 6-8 —á–∞—Å–æ–≤

---

## üü† –í–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã

### 4. –ù–∞—Ä—É—à–µ–Ω–∏–µ SRP: `DefaultMetadataProvider` (286 —Å—Ç—Ä–æ–∫)

**–ü—Ä–æ–±–ª–µ–º–∞:** –ö–ª–∞—Å—Å –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞:
1. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—ç—à–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
2. –†–µ—Ñ–ª–µ–∫—Å–∏—é –ë–î
3. –ü—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞ (–º–µ—Ç–æ–¥ `can`)
4. –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü
5. –°–ø–∏—Å–æ–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π

**–†–µ—à–µ–Ω–∏–µ:** –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:

```python
class MetadataCache:
    """Cache for metadata and tables."""
    ...

class DatabaseReflector:
    """Reflects database schema."""
    ...

class AccessController:
    """Controls access to operations."""
    ...

class DefaultMetadataProvider:
    """Coordinates metadata operations."""
    def __init__(self, cache: MetadataCache, reflector: DatabaseReflector):
        ...
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü† –°—Ä–µ–¥–Ω–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 4-6 —á–∞—Å–æ–≤

---

### 5. –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–ª–æ–Ω–æ–∫ –≤ `parser.py`

**–ü—Ä–æ–±–ª–µ–º–∞:** –í –º–µ—Ç–æ–¥–µ `_resolve_column` (—Å—Ç—Ä–æ–∫–∏ 386-394):

```python
# –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º —Ç–∞–±–ª–∏—Ü–∞–º
for table in self.table_aliases.values():
    if hasattr(table, 'columns') and field_spec in table.columns:
        return table.columns[field_spec]
```

–ü—Ä–∏ –±–æ–ª—å—à–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ JOIN'–æ–≤ —ç—Ç–æ O(n*m), –≥–¥–µ n - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∞–±–ª–∏—Ü, m - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ª–æ–Ω–æ–∫.

**–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å –ø–ª–æ—Å–∫–∏–π –∏–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫:

```python
def __init__(self, context: UMAContext) -> None:
    self.context = context
    self.ctes: dict[str, Select] = {}
    self.table_aliases: dict[str, Any] = {}
    self.select_aliases: dict[str, ColumnElement] = {}
    # –î–æ–±–∞–≤–∏—Ç—å –∏–Ω–¥–µ–∫—Å –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
    self._column_index: dict[str, list[tuple[str, ColumnElement]]] = {}

def _register_table_alias(self, alias_name: str, table: Any, ...) -> None:
    self.table_aliases[alias_name] = table
    # –ò–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –∫–æ–ª–æ–Ω–∫–∏ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã
    if hasattr(table, 'columns'):
        for col in table.columns:
            if col.name not in self._column_index:
                self._column_index[col.name] = []
            self._column_index[col.name].append((alias_name, col))

async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column:
    # –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ –∏–Ω–¥–µ–∫—Å - O(1)
    if candidates := self._column_index.get(field_spec):
        if len(candidates) == 1:
            return candidates[0][1]
        # –ï—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ - –Ω—É–∂–Ω–∞ –∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏—è
        raise JSQLSyntaxError(f'Ambiguous column "{field_spec}"...')
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü† –°—Ä–µ–¥–Ω–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 3-4 —á–∞—Å–∞

---

### 6. –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–ª–∏–∞—Å–æ–≤

**–ü—Ä–æ–±–ª–µ–º–∞:** –í `converter.py` –∏ `parser.py` –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–ª–∏–∞—Å–æ–≤ —Ç–∞–±–ª–∏—Ü –∏ –∫–æ–ª–æ–Ω–æ–∫.

**–õ–æ–∫–∞—Ü–∏–∏:**
- `converter.py:568-570`: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞–ª–∏–∞—Å–æ–≤ –¥–ª—è JOIN
- `converter.py:640-646`: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞–ª–∏–∞—Å–æ–≤ –¥–ª—è FROM
- `parser.py:451-457`: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞–ª–∏–∞—Å–æ–≤ –¥–ª—è JOIN
- `parser.py:176-187`: —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∞–ª–∏–∞—Å–æ–≤

**–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å —É—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–π –∫–ª–∞—Å—Å `AliasManager`:

```python
class AliasManager:
    """Manages table and column aliases."""
    
    def __init__(self) -> None:
        self._table_aliases: dict[str, Any] = {}
        self._column_index: dict[str, list[tuple[str, ColumnElement]]] = {}
    
    def register_table(self, alias: str, table: Any) -> None:
        """Register table with alias."""
        ...
    
    def resolve_column(self, column_name: str, table_name: str | None = None) -> ColumnElement:
        """Resolve column by name, optionally qualified with table."""
        ...
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü† –°—Ä–µ–¥–Ω–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 2-3 —á–∞—Å–∞

---

## üü° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∫ —É–ª—É—á—à–µ–Ω–∏—é

### 7. –ò–∑–±—ã—Ç–æ—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

**–ü—Ä–æ–±–ª–µ–º–∞:** –í `converter.py` –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø—Ä–æ–≤–µ—Ä–æ–∫ —Ç–∏–ø–æ–≤:

```python
if not isinstance(from_spec, str):
    raise JSQLSyntaxError(...)

if not isinstance(cond_spec, dict):
    raise InvalidExpressionError(...)

if not isinstance(join_spec, dict):
    raise InvalidExpressionError(...)
```

**–†–µ—à–µ–Ω–∏–µ:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Pydantic models –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏:

```python
from pydantic import BaseModel, Field, validator

class JSQLSelect(BaseModel):
    field: str | None = None
    alias: str | None = None
    func: str | None = None
    value: Any = None
    
    @validator('*', pre=True)
    def validate_one_of(cls, v, values):
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –∑–∞–¥–∞–Ω–æ —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –ø–æ–ª–µ
        ...

class JSQLQuery(BaseModel):
    from_: str = Field(..., alias='from')
    select: list[JSQLSelect] = Field(default_factory=lambda: [JSQLSelect(field='*')])
    where: JSQLCondition | None = None
    # ...
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü° –ù–∏–∑–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 6-8 —á–∞—Å–æ–≤

---

### 8. –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

**–ü—Ä–æ–±–ª–µ–º–∞:** –ö–∞–∂–¥—ã–π JSQL –∑–∞–ø—Ä–æ—Å –ø–∞—Ä—Å–∏—Ç—Å—è –∑–∞–Ω–æ–≤–æ, –¥–∞–∂–µ –µ—Å–ª–∏ —ç—Ç–æ —Ç–æ—Ç –∂–µ –∑–∞–ø—Ä–æ—Å —Å —Ä–∞–∑–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.

**–†–µ—à–µ–Ω–∏–µ:** –î–æ–±–∞–≤–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä—Å–∏–Ω–≥–∞:

```python
from functools import lru_cache

class JSQLParser:
    def __init__(self, context: UMAContext) -> None:
        self.context = context
        self._parse_cache: dict[str, Select] = {}
    
    async def parse(self, jsql: JSQLQuery, params: dict | None = None) -> Select:
        # –°–æ–∑–¥–∞—Ç—å –∫–ª—é—á –∫—ç—à–∞ (–±–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)
        cache_key = self._make_cache_key(jsql)
        
        if cache_key in self._parse_cache:
            # –í–µ—Ä–Ω—É—Ç—å –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å –ø–æ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
            return self._bind_params(self._parse_cache[cache_key], params)
        
        # –ü–∞—Ä—Å–∏—Ç—å –∏ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞—Ç—å
        query = await self._build_query(jsql)
        self._parse_cache[cache_key] = query
        return self._bind_params(query, params)
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü° –ù–∏–∑–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 4-5 —á–∞—Å–æ–≤

---

### 9. –¶–∏—Ä–∫—É–ª—è—Ä–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã

**–ü—Ä–æ–±–ª–µ–º–∞:** –í –∫–æ–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∏–º–ø–æ—Ä—Ç—ã –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:

**–õ–æ–∫–∞—Ü–∏–∏:**
- `registry.py:26-29`: –∏–º–ø–æ—Ä—Ç `DefaultEntityHandler` –≤–Ω—É—Ç—Ä–∏ `__init__`
- `utils.py:76`: –∏–º–ø–æ—Ä—Ç `get_registry` –≤–Ω—É—Ç—Ä–∏ `copy_field_meta`
- `parser.py:242`: –∏–º–ø–æ—Ä—Ç `get_table` –≤–Ω—É—Ç—Ä–∏ `_get_table_async`

**–†–µ—à–µ–Ω–∏–µ:** –†–µ–æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –º–æ–¥—É–ª–µ–π:

```
core/
‚îú‚îÄ‚îÄ types.py          # –í—Å–µ —Ç–∏–ø—ã –∏ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã (–±–µ–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π)
‚îú‚îÄ‚îÄ exceptions.py     # –ò—Å–∫–ª—é—á–µ–Ω–∏—è (–±–µ–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π)
‚îú‚îÄ‚îÄ context.py        # –ö–æ–Ω—Ç–µ–∫—Å—Ç (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç types)
‚îî‚îÄ‚îÄ utils.py          # –£—Ç–∏–ª–∏—Ç—ã (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç types, context)

handlers/
‚îú‚îÄ‚îÄ base.py           # DefaultEntityHandler (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç core)
‚îî‚îÄ‚îÄ virtual.py        # VirtualViewHandler (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç core)

registry.py           # EntityRegistry (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç handlers)
metadata.py           # MetadataProvider (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç core)
api.py                # API (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤—Å–µ–≥–æ)
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü° –ù–∏–∑–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 3-4 —á–∞—Å–∞

---

### 10. –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ Builder

**–ü—Ä–æ–±–ª–µ–º–∞:** –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–∂–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ (–æ—Å–æ–±–µ–Ω–Ω–æ `UMAContext`, `JSQLParser`) –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–∞–ø—Ä—è–º—É—é, —á—Ç–æ —É—Å–ª–æ–∂–Ω—è–µ—Ç —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.

**–†–µ—à–µ–Ω–∏–µ:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Builder pattern:

```python
class UMAContextBuilder:
    """Builder for UMAContext."""
    
    def __init__(self) -> None:
        self._engine: Engine | None = None
        self._metadata_provider: MetadataProvider | None = None
        self._namespace: str = 'default'
        self._user_context: Any = None
        self._extra: dict[str, Any] = {}
    
    def with_engine(self, engine: Engine) -> 'UMAContextBuilder':
        self._engine = engine
        return self
    
    def with_metadata_provider(self, provider: MetadataProvider) -> 'UMAContextBuilder':
        self._metadata_provider = provider
        return self
    
    def build(self) -> UMAContext:
        if not self._engine:
            raise ValueError('Engine is required')
        if not self._metadata_provider:
            raise ValueError('MetadataProvider is required')
        
        return UMAContext(
            engine=self._engine,
            metadata_provider=self._metadata_provider,
            namespace=self._namespace,
            user_context=self._user_context,
            extra=self._extra
        )
```

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** üü° –ù–∏–∑–∫–∏–π  
**–û—Ü–µ–Ω–∫–∞ —Ç—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç:** 2-3 —á–∞—Å–∞

---

## üü¢ –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã

1. ‚úÖ **–•–æ—Ä–æ—à–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è** - –≤–µ–∑–¥–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è type hints
2. ‚úÖ **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ dataclass** - `EntityName`, `NamespaceConfig`, `UMAContext`
3. ‚úÖ **–ü—Ä–æ—Ç–æ–∫–æ–ª—ã –≤–º–µ—Å—Ç–æ ABC** - `EntityHandler`, `MetadataProvider`
4. ‚úÖ **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ match-case** - —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å Python 3.10+
5. ‚úÖ **Walrus operator** - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —É—Å–ª–æ–≤–∏—è—Ö
6. ‚úÖ **Async/await** - –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç–∏
7. ‚úÖ **Docstrings** - —Ö–æ—Ä–æ—à–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–π
8. ‚úÖ **–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã** - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Enum –¥–ª—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ —Ç–∏–ø–æ–≤
9. ‚úÖ **Proper exception hierarchy** - —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è

---

## –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø–æ –º–æ–¥—É–ª—è–º

### `api.py` (412 —Å—Ç—Ä–æ–∫)
- ‚ùå –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY (–ø–æ–≤—Ç–æ—Ä—è—é—â–∞—è—Å—è –ª–æ–≥–∏–∫–∞)
- ‚ùå –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (`_registry`)
- ‚ùå –°–º–µ—à–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π (–ø–∞—Ä—Å–∏–Ω–≥, –≤–∞–ª–∏–¥–∞—Ü–∏—è, –¥–æ—Å—Ç—É–ø, –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ)
- ‚ö†Ô∏è –§—É–Ω–∫—Ü–∏—è `_check_access` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `hasattr` –≤–º–µ—Å—Ç–æ `isinstance`

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–∞ –∏–ª–∏ –±–∞–∑–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ + —É–¥–∞–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è.

---

### `converter.py` (1033 —Å—Ç—Ä–æ–∫–∏)
- ‚ùå –ù–∞—Ä—É—à–µ–Ω–∏–µ SRP (—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π)
- ‚ùå –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫
- ‚ùå –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–æ—Ö–æ–¥—ã –ø–æ —Å–ø–∏—Å–∫–∞–º (–Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ)
- ‚ö†Ô∏è –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ (–º–æ–∂–µ—Ç –≤–ª–∏—è—Ç—å –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
- ‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (—Å—Ç–æ–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Pydantic)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –†–∞–∑–±–∏—Ç—å –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –º–æ–¥—É–ª–∏ –ø–æ —Ç–∏–ø–∞–º –æ–ø–µ—Ä–∞—Ü–∏–π.

---

### `parser.py` (915 —Å—Ç—Ä–æ–∫)
- ‚ùå –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–ª–æ–Ω–æ–∫ (O(n*m))
- ‚ùå –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∞–ª–∏–∞—Å–æ–≤
- ‚ö†Ô∏è –î–ª–∏–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã (`_build_query`, `_build_select`, `_process_joins_for_aliases`)
- ‚ö†Ô∏è –¶–∏—Ä–∫—É–ª—è—Ä–Ω—ã–π –∏–º–ø–æ—Ä—Ç (`get_table`)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –°–æ–∑–¥–∞—Ç—å –∏–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫, –≤—ã–Ω–µ—Å—Ç–∏ –ª–æ–≥–∏–∫—É –∞–ª–∏–∞—Å–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –∫–ª–∞—Å—Å.

---

### `metadata.py` (286 —Å—Ç—Ä–æ–∫)
- ‚ùå –ù–∞—Ä—É—à–µ–Ω–∏–µ SRP (–∫—ç—à + —Ä–µ—Ñ–ª–µ–∫—Å–∏—è + –¥–æ—Å—Ç—É–ø)
- ‚ö†Ô∏è –ú–µ—Ç–æ–¥ `can` —Å–ª–∏—à–∫–æ–º –ø—Ä–∏–º–∏—Ç–∏–≤–µ–Ω (–≤—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `True`)
- ‚ö†Ô∏è –ö—ç—à –Ω–µ –∏–º–µ–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ —Ä–∞–∑–º–µ—Ä—É (–º–æ–∂–µ—Ç —Ä–∞—Å—Ç–∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã, –¥–æ–±–∞–≤–∏—Ç—å LRU-–∫—ç—à.

---

### `registry.py` (154 —Å—Ç—Ä–æ–∫–∏)
- ‚ùå –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (`_global_registry`)
- ‚ö†Ô∏è –ú–µ—Ç–æ–¥ `get_handler` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–ª–∞—Å—Å, –∞ –Ω–µ –∏–Ω—Å—Ç–∞–Ω—Å (–ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ —Å–±–∏–≤–∞–µ—Ç —Å —Ç–æ–ª–∫—É)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –£–¥–∞–ª–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤ –≤–º–µ—Å—Ç–æ –∫–ª–∞—Å—Å–æ–≤.

---

### `handlers/base.py` (279 —Å—Ç—Ä–æ–∫)
- ‚úÖ –•–æ—Ä–æ—à–∏–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è DRY (`_ensure_exists`, `_build_pk_condition`)
- ‚úÖ –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π –≤ –º–µ—Ç–æ–¥–∞—Ö
- ‚ö†Ô∏è –ú–µ—Ç–æ–¥ `save` –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç create/update –ø–æ –Ω–∞–ª–∏—á–∏—é ID (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–æ—á–µ–≤–∏–¥–Ω–æ)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å —è–≤–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ `create` –∏ `update` –º–µ—Ç–æ–¥–æ–≤.

---

### `handlers/virtual.py` (140 —Å—Ç—Ä–æ–∫)
- ‚úÖ –ü—Ä–æ—Å—Ç–æ–π –∏ –ø–æ–Ω—è—Ç–Ω—ã–π –∫–æ–¥
- ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–π –¥–ª—è –Ω–µ—Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤
- ‚ö†Ô∏è –ú–µ—Ç–æ–¥ `meta` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `getattr` –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –∫–ª–∞—Å—Å–∞ (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–æ—á–µ–≤–∏–¥–Ω–æ)

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –î–æ–±–∞–≤–∏—Ç—å –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ `description` –∏ `columns_metadata`.

---

## –ú–µ—Ç—Ä–∏–∫–∏ –∫–æ–¥–∞

| –ú–æ–¥—É–ª—å | –°—Ç—Ä–æ–∫ | –§—É–Ω–∫—Ü–∏–π/–ú–µ—Ç–æ–¥–æ–≤ | –°–ª–æ–∂–Ω–æ—Å—Ç—å | –û—Ü–µ–Ω–∫–∞ |
|--------|-------|----------------|-----------|--------|
| converter.py | 1033 | 24 | –í—ã—Å–æ–∫–∞—è | üî¥ |
| parser.py | 915 | 22 | –í—ã—Å–æ–∫–∞—è | üü† |
| api.py | 412 | 11 | –°—Ä–µ–¥–Ω—è—è | üü† |
| metadata.py | 286 | 13 | –°—Ä–µ–¥–Ω—è—è | üü† |
| handlers/base.py | 279 | 7 | –ù–∏–∑–∫–∞—è | üü¢ |
| executor.py | 112 | 3 | –ù–∏–∑–∫–∞—è | üü¢ |

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º

### –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ (1-2 –Ω–µ–¥–µ–ª–∏):
1. üî¥ –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ `api.py` - —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ DRY –Ω–∞—Ä—É—à–µ–Ω–∏–π
2. üî¥ –†–∞–∑–±–∏–µ–Ω–∏–µ `converter.py` –Ω–∞ –º–æ–¥—É–ª–∏
3. üü† –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ –∫–æ–ª–æ–Ω–æ–∫ –≤ `parser.py`

### –ö—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω–æ (1 –º–µ—Å—è—Ü):
4. üî¥ –£–¥–∞–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è (breaking change - —Ç—Ä–µ–±—É–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏)
5. üü† –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ `DefaultMetadataProvider`
6. üü† –°–æ–∑–¥–∞–Ω–∏–µ `AliasManager`

### –°—Ä–µ–¥–Ω–µ—Å—Ä–æ—á–Ω–æ (2-3 –º–µ—Å—è—Ü–∞):
7. üü° –í–Ω–µ–¥—Ä–µ–Ω–∏–µ Pydantic –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
8. üü° –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
9. üü° –†–µ–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–¥—É–ª–µ–π

### –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ (3+ –º–µ—Å—è—Ü–∞):
10. üü° –í–Ω–µ–¥—Ä–µ–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ Builder/Factory
11. üü° –£–ª—É—á—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
12. üü° –ú–µ—Ç—Ä–∏–∫–∏ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

---

## –û—Ü–µ–Ω–∫–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –¥–æ–ª–≥–∞

**–û–±—â–∞—è –æ—Ü–µ–Ω–∫–∞:** üü† –°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –¥–æ–ª–≥–∞

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:** 3  
**–í–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã:** 3  
**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:** 4

**–û–±—â–µ–µ –≤—Ä–µ–º—è –Ω–∞ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º:** ~25-35 —á–∞—Å–æ–≤  
**–û–±—â–µ–µ –≤—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥:** ~50-70 —á–∞—Å–æ–≤

---

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü—Ä–æ–µ–∫—Ç UMA –∏–º–µ–µ—Ç —Å–æ–ª–∏–¥–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—É—é –æ—Å–Ω–æ–≤—É –∏ —Ö–æ—Ä–æ—à—É—é —Ç–∏–ø–∏–∑–∞—Ü–∏—é, –Ω–æ —Å—Ç—Ä–∞–¥–∞–µ—Ç –æ—Ç:
1. –ù–∞—Ä—É—à–µ–Ω–∏–π –ø—Ä–∏–Ω—Ü–∏–ø–∞ DRY –≤ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –º–µ—Å—Ç–∞—Ö
2. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
3. –§–∞–π–ª–æ–≤-–º–æ–Ω–æ–ª–∏—Ç–æ–≤, –Ω–∞—Ä—É—à–∞—é—â–∏—Ö SRP
4. –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–∏—Å–∫–∞ –≤ –ø–∞—Ä—Å–µ—Ä–µ

–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º –¥–æ–ª–∂–Ω–æ —Å—Ç–∞—Ç—å —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º (DRY, –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —Ä–∞–∑–±–∏–µ–Ω–∏–µ converter.py), —á—Ç–æ –∑–∞–π–º–µ—Ç –æ–∫–æ–ª–æ 25-35 —á–∞—Å–æ–≤ —Ä–∞–±–æ—Ç—ã. –≠—Ç–æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–ª—É—á—à–∏—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç—å –∏ —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å –∫–æ–¥–∞.

---

**–ê–≤—Ç–æ—Ä:** Code Review System  
**–î–∞—Ç–∞:** 2026-01-13

```

–ó–∞–≤–µ—Ä—à–∏–ª –¥–µ—Ç–∞–ª—å–Ω—ã–π code review –ø—Ä–æ–µ–∫—Ç–∞ UMA. –°–æ–∑–¥–∞–Ω –¥–æ–∫—É–º–µ–Ω—Ç `CODE_REVIEW_2026-01-13.md` —Å –ø–æ–ª–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º.

## –ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞

### üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã (—Ç—Ä–µ–±—É—é—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è):

1. **–ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ `api.py`** - —Ñ—É–Ω–∫—Ü–∏–∏ `uma_read`, `uma_save`, `uma_delete`, `uma_entity_details` —Å–æ–¥–µ—Ä–∂–∞—Ç –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∏–¥–µ–Ω—Ç–∏—á–Ω—É—é –ª–æ–≥–∏–∫—É (–ø–∞—Ä—Å–∏–Ω–≥, —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞). –ú–æ–∂–Ω–æ —Å–æ–∫—Ä–∞—Ç–∏—Ç—å –Ω–∞ ~60% –∫–æ–¥–∞.

2. **–ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ** - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ `api.py`, `namespace_config.py`, `registry.py` - —ç—Ç–æ anti-pattern, –∫–æ—Ç–æ—Ä—ã–π:
   - –£—Å–ª–æ–∂–Ω—è–µ—Ç —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
   - –°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã —Å –∏–∑–æ–ª—è—Ü–∏–µ–π
   - –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ race conditions

3. **–ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π `converter.py` (1033 —Å—Ç—Ä–æ–∫–∏)** - —è–≤–Ω–æ–µ –Ω–∞—Ä—É—à–µ–Ω–∏–µ SRP. –§–∞–π–ª –¥–µ–ª–∞–µ—Ç:
   - JSQL ‚Üí SQL –∫–æ–Ω–≤–µ—Ä—Å–∏—é
   - SQL ‚Üí JSQL –∫–æ–Ω–≤–µ—Ä—Å–∏—é
   - –û–±—Ä–∞–±–æ—Ç–∫—É –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤, JOIN'–æ–≤, —Ñ—É–Ω–∫—Ü–∏–π
   - –ù—É–∂–Ω–æ —Ä–∞–∑–±–∏—Ç—å –Ω–∞ ~7 –º–æ–¥—É–ª–µ–π

### üü† –í–∞–∂–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã:

4. **–ù–∞—Ä—É—à–µ–Ω–∏–µ SRP –≤ `DefaultMetadataProvider`** - —Å–º–µ—à–∏–≤–∞–µ—Ç –∫—ç—à, —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –ë–î –∏ –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞

5. **–ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–ª–æ–Ω–æ–∫** - –≤ `parser.py` –ª–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ O(n*m) –ø—Ä–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏ –∫–æ–ª–æ–Ω–æ–∫. –ü—Ä–∏ –±–æ–ª—å—à–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ JOIN'–æ–≤ —ç—Ç–æ –º–µ–¥–ª–µ–Ω–Ω–æ.

6. **–î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –∞–ª–∏–∞—Å–æ–≤** - –≤ `converter.py` –∏ `parser.py` –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–ª–∏–∞—Å–æ–≤

### üü° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ (–Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –Ω–æ –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ):

7. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Pydantic –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ JSQL
8. –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
9. –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã—Ö –∏–º–ø–æ—Ä—Ç–æ–≤
10. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ Builder/Factory

### üü¢ –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã:

‚úÖ –û—Ç–ª–∏—á–Ω–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è  
‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ dataclass –∏ Protocol  
‚úÖ –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å (match-case, walrus operator)  
‚úÖ Async/await –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è  
‚úÖ –•–æ—Ä–æ—à–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è  

## –û—Ü–µ–Ω–∫–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–≥–æ –¥–æ–ª–≥–∞

- **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º:** 3
- **–í–∞–∂–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º:** 3
- **–í—Ä–µ–º—è –Ω–∞ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö:** 25-35 —á–∞—Å–æ–≤
- **–í—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥:** 50-70 —á–∞—Å–æ–≤

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏

–•–æ—á–µ—à—å, —á—Ç–æ–±—ã —è –Ω–∞—á–∞–ª –∏—Å–ø—Ä–∞–≤–ª—è—Ç—å –∫–∞–∫–∏–µ-—Ç–æ –∏–∑ —ç—Ç–∏—Ö –ø—Ä–æ–±–ª–µ–º? –†–µ–∫–æ–º–µ–Ω–¥—É—é –Ω–∞—á–∞—Ç—å —Å:

1. **–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ `api.py`** (2-3 —á–∞—Å–∞) - —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ –æ–±—â—É—é —Ñ—É–Ω–∫—Ü–∏—é/–¥–µ–∫–æ—Ä–∞—Ç–æ—Ä
2. **–†–∞–∑–±–∏–µ–Ω–∏–µ `converter.py`** (6-8 —á–∞—Å–æ–≤) - –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –º–æ–¥—É–ª–∏
3. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è `parser.py`** (3-4 —á–∞—Å–∞) - –¥–æ–±–∞–≤–∏—Ç—å –∏–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫

–ö–∞–∫—É—é –ø—Ä–æ–±–ª–µ–º—É —Ö–æ—Ç–µ–ª –±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å?

---

**User**

(20260113-153938)
> –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Pydantic –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ JSQL

–≠—Ç–æ –æ–±—Å—É–∂–¥–∞–ª–æ—Å—å. –†–µ—à–∏–ª–∏ –æ—Ç —ç—Ç–æ–≥–æ –æ—Ç–∫–∞–∑–∞—Ç—å—Å—è, –ø–æ—Å–∫–æ–ª—å–∫—É:
1) –≠—Ç–æ —Å–æ–∑–¥–∞—Å—Ç –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞
2) –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ —Ç–∞–∫ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ, –ø—Ä–∏—á—ë–º –ø—Ä–∏ —ç—Ç–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –ø–æ–º–µ—Å—Ç–∏—Ç—å –≤ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã.

(20260113-154122) –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –ø—Ä–æ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—é –≤—ã—è–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º 1-6, –∞ —Ç–∞–∫–∂–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π 8-10.

---

**Cursor**

–°–æ–∑–¥–∞–º –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.

```markdown
# –ü–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ UMA
**–î–∞—Ç–∞:** 2026-01-13  
**–í–µ—Ä—Å–∏—è:** 2.3

## –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
1. [–ü—Ä–æ–±–ª–µ–º–∞ 1: –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ api.py](#–ø—Ä–æ–±–ª–µ–º–∞-1-–Ω–∞—Ä—É—à–µ–Ω–∏–µ-dry-–≤-apipy)
2. [–ü—Ä–æ–±–ª–µ–º–∞ 2: –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ](#–ø—Ä–æ–±–ª–µ–º–∞-2-–≥–ª–æ–±–∞–ª—å–Ω–æ–µ-—Å–æ—Å—Ç–æ—è–Ω–∏–µ)
3. [–ü—Ä–æ–±–ª–µ–º–∞ 3: –ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π converter.py](#–ø—Ä–æ–±–ª–µ–º–∞-3-–≥–∏–≥–∞–Ω—Ç—Å–∫–∏–π-converterpy)
4. [–ü—Ä–æ–±–ª–µ–º–∞ 4: –ù–∞—Ä—É—à–µ–Ω–∏–µ SRP –≤ DefaultMetadataProvider](#–ø—Ä–æ–±–ª–µ–º–∞-4-–Ω–∞—Ä—É—à–µ–Ω–∏–µ-srp-–≤-defaultmetadataprovider)
5. [–ü—Ä–æ–±–ª–µ–º–∞ 5: –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–ª–æ–Ω–æ–∫](#–ø—Ä–æ–±–ª–µ–º–∞-5-–Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π-–ø–æ–∏—Å–∫-–∫–æ–ª–æ–Ω–æ–∫)
6. [–ü—Ä–æ–±–ª–µ–º–∞ 6: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –∞–ª–∏–∞—Å–æ–≤](#–ø—Ä–æ–±–ª–µ–º–∞-6-–¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ-–ª–æ–≥–∏–∫–∏-–∞–ª–∏–∞—Å–æ–≤)
7. [–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 8: –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤](#—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è-8-–∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ-–∑–∞–ø—Ä–æ—Å–æ–≤)
8. [–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 9: –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã—Ö –∏–º–ø–æ—Ä—Ç–æ–≤](#—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è-9-—É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ-—Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã—Ö-–∏–º–ø–æ—Ä—Ç–æ–≤)
9. [–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 10: –ü–∞—Ç—Ç–µ—Ä–Ω Builder](#—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è-10-–ø–∞—Ç—Ç–µ—Ä–Ω-builder)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 1: –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ api.py

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è

–ü–æ–≤—Ç–æ—Ä—è—é—â–∏–π—Å—è –∫–æ–¥ –≤ 4 —Ñ—É–Ω–∫—Ü–∏—è—Ö:
```python
async def uma_read(entity_name: str, id_value: Any, user_context: Any = None, namespace: str | None = None) -> dict:
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    context = _create_context(entity.namespace, user_context)
    _check_access(str(entity), Operation.READ, context)
    handler = await get_registry().get_handler(entity, context)
    return await handler.read(entity, id_value, context)
```

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 1A: –ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–ø—Ä–æ—Å—Ç–æ–µ —Ä–µ—à–µ–Ω–∏–µ)

**–§–∞–π–ª:** `src/namerec/uma/api.py`

```python
async def _execute_operation(
    entity_name: str,
    operation: Operation,
    handler_method: str,
    user_context: Any = None,
    namespace: str | None = None,
    **operation_args: Any,
) -> Any:
    """
    Execute entity operation with common logic.
    
    Args:
        entity_name: Entity name (can include namespace)
        operation: Operation type for access control
        handler_method: Name of handler method to call
        user_context: User context for access control
        namespace: Optional namespace override
        **operation_args: Arguments to pass to handler method
    
    Returns:
        Result from handler method
    
    Raises:
        UMAAccessDeniedError: If access denied
        UMANotFoundError: If entity/record not found
    """
    # Parse entity name and apply namespace override
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    # Create context and check access
    context = _create_context(entity.namespace, user_context)
    _check_access(str(entity), operation, context)
    
    # Get handler and execute operation
    handler = await get_registry().get_handler(entity, context)
    method = getattr(handler, handler_method)
    return await method(entity, context, **operation_args)


# Refactored operations
async def uma_read(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Read a record by id."""
    return await _execute_operation(
        entity_name=entity_name,
        operation=Operation.READ,
        handler_method='read',
        user_context=user_context,
        namespace=namespace,
        id_value=id_value,
    )


async def uma_save(
    entity_name: str,
    data: dict,
    user_context: Any = None,
    namespace: str | None = None,
) -> Any:
    """Save a record (create if id=None, otherwise update)."""
    # Determine operation type
    has_id = any(data.get(key) is not None for key in ['id', 'ID'])
    operation = Operation.UPDATE if has_id else Operation.CREATE
    
    return await _execute_operation(
        entity_name=entity_name,
        operation=operation,
        handler_method='save',
        user_context=user_context,
        namespace=namespace,
        data=data,
    )


async def uma_delete(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> bool:
    """Delete a record by id."""
    return await _execute_operation(
        entity_name=entity_name,
        operation=Operation.DELETE,
        handler_method='delete',
        user_context=user_context,
        namespace=namespace,
        id_value=id_value,
    )


async def uma_entity_details(
    entity_name: str,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Get entity metadata."""
    return await _execute_operation(
        entity_name=entity_name,
        operation=Operation.META,
        handler_method='meta',
        user_context=user_context,
        namespace=namespace,
    )
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∫–æ–¥–∞ —Å ~200 –¥–æ ~80 —Å—Ç—Ä–æ–∫
- –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ–±—â–µ–π –ª–æ–≥–∏–∫–∏
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 1-2 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (–Ω–µ breaking change)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 2: –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è

–ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ —Ç—Ä–µ—Ö –º–æ–¥—É–ª—è—Ö:
- `api.py`: `_registry`
- `namespace_config.py`: `_namespace_configs`, `_default_namespace`
- `registry.py`: `_global_registry`

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 2A: –ö–ª–∞—Å—Å UMAApplication (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ —Ä–µ—à–µ–Ω–∏–µ)

**–ù–æ–≤—ã–π —Ñ–∞–π–ª:** `src/namerec/uma/application.py`

```python
"""UMA application container."""

from collections.abc import Mapping
from typing import Any

from namerec.uma.core.context import UMAContext
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.core.types import Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.registry import EntityRegistry


class UMAApplication:
    """
    UMA application container with all dependencies.
    
    Replaces global state with explicit dependency injection.
    Each instance is isolated and can be used independently.
    
    Example:
        # Create application instance
        uma = UMAApplication(
            namespace_configs={
                'main': NamespaceConfig(
                    engine=engine,
                    metadata_provider=DefaultMetadataProvider(),
                ),
            },
            default_namespace='main',
            default_handler=DefaultEntityHandler,
        )
        
        # Use application
        result = await uma.read('users', 1)
        entities = await uma.entity_list()
    """

    def __init__(
        self,
        namespace_configs: Mapping[str, NamespaceConfig],
        default_namespace: str | None = None,
        default_handler: type[EntityHandler] | None = None,
    ) -> None:
        """
        Initialize UMA application.
        
        Args:
            namespace_configs: Mapping {namespace: NamespaceConfig}
            default_namespace: Default namespace (None = first namespace)
            default_handler: Default handler for unregistered entities
        
        Raises:
            ValueError: If namespace_configs is empty
        """
        if not namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)
        
        self._namespace_configs = namespace_configs
        self._default_namespace = default_namespace or next(iter(namespace_configs.keys()))
        self._registry = EntityRegistry(default_handler or DefaultEntityHandler)
    
    @property
    def registry(self) -> EntityRegistry:
        """Get entity registry."""
        return self._registry
    
    @property
    def default_namespace(self) -> str:
        """Get default namespace name."""
        return self._default_namespace
    
    def get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """
        Get configuration for a namespace.
        
        Args:
            namespace: Namespace name (None = use default)
        
        Returns:
            NamespaceConfig for the requested namespace
        
        Raises:
            ValueError: If namespace not found
        """
        ns = namespace or self._default_namespace
        if ns not in self._namespace_configs:
            available = ', '.join(self._namespace_configs.keys())
            msg = f'Namespace "{ns}" not found. Available: {available}'
            raise ValueError(msg)
        return self._namespace_configs[ns]
    
    def _create_context(
        self,
        namespace: str | None = None,
        user_context: Any = None,
        **extra: Any,
    ) -> UMAContext:
        """Create context for operation."""
        config = self.get_namespace_config(namespace)
        actual_namespace = namespace or self._default_namespace
        
        return UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
            extra=extra,
        )
    
    def _check_access(
        self,
        entity_name: str,
        operation: Operation,
        context: UMAContext,
    ) -> None:
        """Check access and raise exception if denied."""
        if hasattr(context.metadata_provider, 'can'):
            if not context.metadata_provider.can(entity_name, operation, context):  # type: ignore[union-attr]
                from namerec.uma.core.exceptions import UMAAccessDeniedError
                raise UMAAccessDeniedError(entity_name, operation.value)
    
    async def _execute_operation(
        self,
        entity_name: str,
        operation: Operation,
        handler_method: str,
        user_context: Any = None,
        namespace: str | None = None,
        **operation_args: Any,
    ) -> Any:
        """Execute entity operation (internal helper)."""
        from namerec.uma.core.types import EntityName
        
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)
        
        context = self._create_context(entity.namespace, user_context)
        self._check_access(str(entity), operation, context)
        
        handler = await self._registry.get_handler(entity, context)
        method = getattr(handler, handler_method)
        return await method(entity, context, **operation_args)
    
    # Public API methods
    
    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """Read a record by id."""
        return await self._execute_operation(
            entity_name=entity_name,
            operation=Operation.READ,
            handler_method='read',
            user_context=user_context,
            namespace=namespace,
            id_value=id_value,
        )
    
    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """Save a record (create if id=None, otherwise update)."""
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE
        
        return await self._execute_operation(
            entity_name=entity_name,
            operation=operation,
            handler_method='save',
            user_context=user_context,
            namespace=namespace,
            data=data,
        )
    
    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """Delete a record by id."""
        return await self._execute_operation(
            entity_name=entity_name,
            operation=Operation.DELETE,
            handler_method='delete',
            user_context=user_context,
            namespace=namespace,
            id_value=id_value,
        )
    
    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """Get entity metadata."""
        return await self._execute_operation(
            entity_name=entity_name,
            operation=Operation.META,
            handler_method='meta',
            user_context=user_context,
            namespace=namespace,
        )
    
    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """Get list of all available entities."""
        context = self._create_context(namespace, user_context)
        self._check_access('', Operation.META, context)
        
        entities = await context.metadata_provider.list_entities(
            context.namespace,
            context,
        )
        
        # Format with namespace prefix if not default
        if context.namespace != self._default_namespace:
            return [f'{context.namespace}:{e}' for e in entities]
        return entities
    
    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """Execute JSQL query."""
        from namerec.uma.core.types import EntityName
        from namerec.uma.jsql.executor import JSQLExecutor
        
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)
        
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)
        
        context = self._create_context(entity.namespace, user_context)
        self._check_access(str(entity), Operation.SELECT, context)
        
        executor = JSQLExecutor(context)
        result = await executor.execute(jsql, params)
        
        return result.to_dict()
```

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 2B: –û–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å

**–û–±–Ω–æ–≤–∏—Ç—å —Ñ–∞–π–ª:** `src/namerec/uma/api.py`

```python
"""High-level API functions for UMA (backward compatibility layer)."""

from collections.abc import Mapping
from typing import Any

from namerec.uma.application import UMAApplication
from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler
from namerec.uma.registry import EntityRegistry

# Global application instance for backward compatibility
_application: UMAApplication | None = None


def uma_initialize(
    namespace_configs: Mapping[str, NamespaceConfig],
    default_handler: type[EntityHandler] | None = None,
) -> EntityRegistry:
    """
    Initialize UMA with namespace configurations (legacy API).
    
    This function maintains backward compatibility but creates global state.
    For new code, prefer creating UMAApplication instances directly.
    
    Args:
        namespace_configs: Mapping {namespace: NamespaceConfig}
        default_handler: Default handler class for unregistered entities
    
    Returns:
        Initialized EntityRegistry
    
    Example:
        # Legacy usage (global state)
        uma_initialize({
            'main': NamespaceConfig(engine=engine, metadata_provider=provider)
        })
        result = await uma_read('users', 1)
        
        # Recommended usage (no global state)
        uma = UMAApplication(
            namespace_configs={'main': NamespaceConfig(...)},
        )
        result = await uma.read('users', 1)
    """
    global _application  # noqa: PLW0603
    
    # Determine default namespace
    if len(namespace_configs) == 1:
        default_ns = next(iter(namespace_configs.keys()))
    else:
        default_ns = None
    
    _application = UMAApplication(
        namespace_configs=namespace_configs,
        default_namespace=default_ns,
        default_handler=default_handler,
    )
    
    return _application.registry


# Legacy alias
initialize_uma = uma_initialize


def get_registry() -> EntityRegistry:
    """Get initialized registry (legacy API)."""
    if _application is None:
        msg = 'UMA not initialized. Call uma_initialize() first.'
        raise RuntimeError(msg)
    return _application.registry


def get_application() -> UMAApplication:
    """
    Get global application instance.
    
    Returns:
        Global UMAApplication instance
    
    Raises:
        RuntimeError: If UMA not initialized
    """
    if _application is None:
        msg = 'UMA not initialized. Call uma_initialize() first.'
        raise RuntimeError(msg)
    return _application


# Legacy API functions (delegate to application)

async def uma_read(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Read a record by id (legacy API)."""
    return await get_application().read(entity_name, id_value, user_context, namespace)


async def uma_save(
    entity_name: str,
    data: dict,
    user_context: Any = None,
    namespace: str | None = None,
) -> Any:
    """Save a record (legacy API)."""
    return await get_application().save(entity_name, data, user_context, namespace)


async def uma_delete(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> bool:
    """Delete a record by id (legacy API)."""
    return await get_application().delete(entity_name, id_value, user_context, namespace)


async def uma_entity_details(
    entity_name: str,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Get entity metadata (legacy API)."""
    return await get_application().entity_details(entity_name, user_context, namespace)


async def uma_entity_list(
    user_context: Any = None,
    namespace: str | None = None,
) -> list[str]:
    """Get list of all available entities (legacy API)."""
    return await get_application().entity_list(user_context, namespace)


async def uma_select(
    jsql: dict,
    params: dict | None = None,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Execute JSQL query (legacy API)."""
    return await get_application().select(jsql, params, user_context, namespace)
```

**–û–±–Ω–æ–≤–∏—Ç—å:** `src/namerec/uma/__init__.py`

```python
"""UMA - Unified Model Access"""

# New recommended API
from namerec.uma.application import UMAApplication

# Legacy API (backward compatibility)
from namerec.uma.api import get_application
from namerec.uma.api import get_registry
from namerec.uma.api import initialize_uma
from namerec.uma.api import uma_delete
from namerec.uma.api import uma_entity_details
from namerec.uma.api import uma_entity_list
from namerec.uma.api import uma_initialize
from namerec.uma.api import uma_read
from namerec.uma.api import uma_save
from namerec.uma.api import uma_select

# ... rest of imports

__all__ = [
    # New API
    'UMAApplication',
    
    # Legacy API
    'uma_initialize',
    'initialize_uma',
    'get_registry',
    'get_application',
    'uma_select',
    'uma_read',
    'uma_save',
    'uma_delete',
    'uma_entity_details',
    'uma_entity_list',
    
    # ... rest
]
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –ü–æ–ª–Ω–∞—è –∏–∑–æ–ª—è—Ü–∏—è –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤
- –õ–µ–≥–∫–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
- –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ race conditions
- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 4-6 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ (–ø–æ–ª–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 3: –ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π converter.py

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è

–§–∞–π–ª `converter.py` —Å–æ–¥–µ—Ä–∂–∏—Ç 1033 —Å—Ç—Ä–æ–∫–∏ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π.

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 3A: –†–∞–∑–±–∏–µ–Ω–∏–µ –Ω–∞ –º–æ–¥—É–ª–∏

**–ù–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:**

```
src/namerec/uma/jsql/converter/
‚îú‚îÄ‚îÄ __init__.py              # Public API
‚îú‚îÄ‚îÄ jsql_to_sql.py          # JSQL ‚Üí SQL conversion
‚îú‚îÄ‚îÄ sql_to_jsql.py          # SQL ‚Üí JSQL conversion
‚îú‚îÄ‚îÄ operators.py            # Operator mappings and conversions
‚îú‚îÄ‚îÄ expressions.py          # Expression conversions
‚îú‚îÄ‚îÄ conditions.py           # Condition conversions
‚îî‚îÄ‚îÄ utils.py                # Common utilities
```

**–§–∞–π–ª:** `src/namerec/uma/jsql/converter/__init__.py`

```python
"""JSQL to SQL and SQL to JSQL converters."""

from namerec.uma.jsql.converter.jsql_to_sql import jsql_to_sql
from namerec.uma.jsql.converter.sql_to_jsql import sql_to_jsql

__all__ = ['jsql_to_sql', 'sql_to_jsql']
```

**–§–∞–π–ª:** `src/namerec/uma/jsql/converter/operators.py`

```python
"""Operator mappings and conversions."""

import sqlglot.expressions as exp

from namerec.uma.jsql.constants import JSQLOperator

# JSQL ‚Üí SQLGlot mappings
ARITHMETIC_OP_TO_SQLGLOT: dict[str, type[exp.Expression]] = {
    JSQLOperator.ADD.value: exp.Add,
    JSQLOperator.SUB.value: exp.Sub,
    JSQLOperator.MUL.value: exp.Mul,
    JSQLOperator.DIV.value: exp.Div,
}

COMPARISON_OP_TO_SQLGLOT: dict[str, type[exp.Expression]] = {
    JSQLOperator.EQ.value: exp.EQ,
    JSQLOperator.NE.value: exp.NEQ,
    JSQLOperator.GT.value: exp.GT,
    JSQLOperator.GE.value: exp.GTE,
    JSQLOperator.LT.value: exp.LT,
    JSQLOperator.LE.value: exp.LTE,
}

LOGICAL_OP_TO_SQLGLOT: dict[str, type[exp.Expression]] = {
    JSQLOperator.AND.value: exp.And,
    JSQLOperator.OR.value: exp.Or,
}

# SQLGlot ‚Üí JSQL reverse mappings
SQLGLOT_TO_ARITHMETIC: dict[type[exp.Expression], str] = {
    exp.Add: JSQLOperator.ADD.value,
    exp.Sub: JSQLOperator.SUB.value,
    exp.Mul: JSQLOperator.MUL.value,
    exp.Div: JSQLOperator.DIV.value,
}

SQLGLOT_TO_COMPARISON: dict[type[exp.Expression], str] = {
    exp.EQ: JSQLOperator.EQ.value,
    exp.NEQ: JSQLOperator.NE.value,
    exp.GT: JSQLOperator.GT.value,
    exp.GTE: JSQLOperator.GE.value,
    exp.LT: JSQLOperator.LT.value,
    exp.LTE: JSQLOperator.LE.value,
}
```

**–§–∞–π–ª:** `src/namerec/uma/jsql/converter/expressions.py`

```python
"""Expression conversion utilities."""

import logging
from typing import Any

import sqlglot.expressions as exp

from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError
from namerec.uma.jsql.conversion_exceptions import UnknownOperatorError
from namerec.uma.jsql.converter.operators import ARITHMETIC_OP_TO_SQLGLOT
from namerec.uma.jsql.converter.operators import SQLGLOT_TO_ARITHMETIC
from namerec.uma.jsql.types import JSQLExpression

logger = logging.getLogger(__name__)


def jsql_expression_to_sqlglot(expr_spec: dict[str, Any] | str) -> exp.Expression:
    """
    Convert JSQL expression to sqlglot expression.
    
    Raises:
        InvalidExpressionError: If expression structure is invalid
    """
    if isinstance(expr_spec, str):
        return convert_field_reference(expr_spec)
    
    if isinstance(expr_spec, dict):
        if 'field' in expr_spec:
            return convert_field_reference(expr_spec['field'])
        if 'value' in expr_spec:
            return convert_literal_value(expr_spec['value'])
        if 'func' in expr_spec:
            return convert_function_call(expr_spec)
        if 'op' in expr_spec:
            return convert_arithmetic_op(expr_spec)
        
        raise InvalidExpressionError(
            message="Expression must contain 'field', 'value', 'func', or 'op'",
            path='',
            expression=expr_spec,
        )
    
    raise InvalidExpressionError(
        message=f'Expression must be string or dict, got {type(expr_spec).__name__}',
        path='',
        expression={'type': type(expr_spec).__name__, 'value': repr(expr_spec)},
    )


def convert_field_reference(field: str) -> exp.Expression:
    """Convert field reference to sqlglot column expression."""
    if field == '*':
        return exp.Star()
    if '.' in field:
        table, column = field.split('.', 1)
        return exp.column(column, table=table)
    return exp.column(field)


def convert_literal_value(value: Any) -> exp.Expression:
    """Convert literal value to sqlglot expression."""
    match value:
        case bool():
            return exp.Boolean(this=value)
        case int() | float():
            return exp.Literal.number(value)
        case _:
            return exp.Literal.string(str(value))


def convert_function_call(expr_spec: dict[str, Any]) -> exp.Expression:
    """Convert function call to sqlglot expression."""
    func = expr_spec['func']
    logger.debug(f'Converting function call: {func}')
    
    args = [
        converted
        for arg in expr_spec.get('args', [])
        if (converted := jsql_expression_to_sqlglot(arg)) is not None
    ]
    
    func_class = getattr(exp, func.upper(), None)
    if func_class and issubclass(func_class, exp.Func):
        return func_class(*args)
    
    return exp.Anonymous(this=func, expressions=args)


def convert_arithmetic_op(expr_spec: dict[str, Any]) -> exp.Expression:
    """
    Convert arithmetic operation to sqlglot expression.
    
    Raises:
        MissingFieldError: If left or right operand is missing
        UnknownOperatorError: If operator is not supported
    """
    from namerec.uma.jsql.conversion_exceptions import MissingFieldError
    
    op = expr_spec.get('op')
    if not op:
        raise MissingFieldError('op', path='op', context='arithmetic operation')
    
    if 'left' not in expr_spec:
        raise MissingFieldError('left', path='left', context='arithmetic operation')
    if 'right' not in expr_spec:
        raise MissingFieldError('right', path='right', context='arithmetic operation')
    
    left = jsql_expression_to_sqlglot(expr_spec['left'])
    right = jsql_expression_to_sqlglot(expr_spec['right'])
    
    operator_class = ARITHMETIC_OP_TO_SQLGLOT.get(op)
    if not operator_class:
        raise UnknownOperatorError(
            operator=op,
            path='op',
            supported=list(ARITHMETIC_OP_TO_SQLGLOT.keys()),
        )
    
    return operator_class(this=left, expression=right)


# SQL ‚Üí JSQL conversions

def sqlglot_expression_to_jsql(expr: exp.Expression) -> JSQLExpression:
    """
    Convert sqlglot expression to JSQL expression.
    
    Raises:
        InvalidExpressionError: If expression structure is invalid
        UnsupportedOperationError: If expression type is not supported
    """
    from namerec.uma.jsql.conversion_exceptions import UnsupportedOperationError
    
    # Aliased expressions
    if isinstance(expr, exp.Alias):
        base_expr = sqlglot_expression_to_jsql(expr.this)
        base_expr['alias'] = expr.alias
        return base_expr
    
    # Column references
    if isinstance(expr, exp.Column):
        result: JSQLExpression = {'field': expr.name}
        if expr.table:
            result['field'] = f'{expr.table}.{expr.name}'
        return result
    
    # Literals
    if isinstance(expr, exp.Literal):
        return {'value': expr.this}
    
    # Star (SELECT *)
    if isinstance(expr, exp.Star):
        return {'field': '*'}
    
    # Functions
    if isinstance(expr, exp.Func):
        func_name = expr.sql_name()
        args = [
            converted
            for arg in expr.args.values()
            if isinstance(arg, exp.Expression)
            and (converted := sqlglot_expression_to_jsql(arg)) is not None
        ]
        return {'func': func_name, 'args': args}
    
    # Binary operations
    if isinstance(expr, (exp.Add, exp.Sub, exp.Mul, exp.Div)):
        op = SQLGLOT_TO_ARITHMETIC.get(type(expr))
        if not op:
            raise UnknownOperatorError(
                operator=type(expr).__name__,
                path='',
                supported=list(SQLGLOT_TO_ARITHMETIC.values()),
            )
        
        return {
            'op': op,
            'left': sqlglot_expression_to_jsql(expr.left),
            'right': sqlglot_expression_to_jsql(expr.right),
        }
    
    raise UnsupportedOperationError(
        operation=f'Expression type: {type(expr).__name__}',
        reason='This expression type is not supported in JSQL conversion',
        path='',
    )
```

**–§–∞–π–ª:** `src/namerec/uma/jsql/converter/conditions.py`

```python
"""Condition conversion utilities."""

import logging
from typing import Any

import sqlglot.expressions as exp

from namerec.uma.jsql.constants import LOGICAL_OPERATORS
from namerec.uma.jsql.constants import JSQLOperator
from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError
from namerec.uma.jsql.conversion_exceptions import MissingFieldError
from namerec.uma.jsql.conversion_exceptions import UnknownOperatorError
from namerec.uma.jsql.conversion_exceptions import UnsupportedOperationError
from namerec.uma.jsql.converter.expressions import jsql_expression_to_sqlglot
from namerec.uma.jsql.converter.expressions import sqlglot_expression_to_jsql
from namerec.uma.jsql.converter.operators import COMPARISON_OP_TO_SQLGLOT
from namerec.uma.jsql.converter.operators import LOGICAL_OP_TO_SQLGLOT
from namerec.uma.jsql.converter.operators import SQLGLOT_TO_COMPARISON

logger = logging.getLogger(__name__)


def jsql_condition_to_sqlglot(cond_spec: dict[str, Any]) -> exp.Expression:
    """
    Convert JSQL condition to sqlglot expression.
    
    Raises:
        InvalidExpressionError: If condition structure is invalid
        MissingFieldError: If required operator field is missing
    """
    if not isinstance(cond_spec, dict):
        raise InvalidExpressionError(
            message=f'Condition must be a dict, got {type(cond_spec).__name__}',
            path='',
            expression={'type': type(cond_spec).__name__, 'value': repr(cond_spec)},
        )
    
    if 'op' not in cond_spec:
        raise MissingFieldError('op', path='op', context='condition')
    
    op = cond_spec['op']
    
    if op in LOGICAL_OPERATORS:
        return convert_logical_operator(op, cond_spec)
    
    return convert_comparison_operator(op, cond_spec)


def convert_logical_operator(op: str, cond_spec: dict[str, Any]) -> exp.Expression:
    """Convert logical operator (AND/OR/NOT) to sqlglot expression."""
    logger.debug(f'Converting logical operator: {op}')
    
    # AND/OR operators
    if op in (JSQLOperator.AND.value, JSQLOperator.OR.value):
        if 'conditions' not in cond_spec:
            raise MissingFieldError('conditions', path='conditions', context=f'{op} operator')
        
        conditions = cond_spec['conditions']
        if not conditions:
            raise InvalidExpressionError(
                message=f'{op} operator requires at least one condition',
                path='conditions',
            )
        
        result = jsql_condition_to_sqlglot(conditions[0])
        operator_class = LOGICAL_OP_TO_SQLGLOT.get(op)
        if not operator_class:
            raise UnknownOperatorError(
                operator=op,
                path='op',
                supported=list(LOGICAL_OP_TO_SQLGLOT.keys()),
            )
        
        for cond in conditions[1:]:
            next_cond = jsql_condition_to_sqlglot(cond)
            result = operator_class(this=result, expression=next_cond)
        
        return result
    
    # NOT operator
    if op == JSQLOperator.NOT.value:
        if 'condition' not in cond_spec:
            raise MissingFieldError('condition', path='condition', context='NOT operator')
        
        condition = jsql_condition_to_sqlglot(cond_spec['condition'])
        return exp.Not(this=condition)
    
    raise UnknownOperatorError(
        operator=op,
        path='op',
        supported=[JSQLOperator.AND.value, JSQLOperator.OR.value, JSQLOperator.NOT.value],
    )


def convert_comparison_operator(op: str, cond_spec: dict[str, Any]) -> exp.Expression:
    """Convert comparison operator to sqlglot expression."""
    logger.debug(f'Converting comparison operator: {op}')
    
    # BETWEEN has special structure
    if op == JSQLOperator.BETWEEN.value:
        if 'expr' not in cond_spec:
            raise MissingFieldError('expr', path='expr', context='BETWEEN operator')
        if 'low' not in cond_spec:
            raise MissingFieldError('low', path='low', context='BETWEEN operator')
        if 'high' not in cond_spec:
            raise MissingFieldError('high', path='high', context='BETWEEN operator')
        
        expr = jsql_expression_to_sqlglot(cond_spec['expr'])
        low_expr = jsql_expression_to_sqlglot(cond_spec['low'])
        high_expr = jsql_expression_to_sqlglot(cond_spec['high'])
        
        return exp.Between(this=expr, low=low_expr, high=high_expr)
    
    # Get left and right operands (new or old format)
    if 'left' in cond_spec and 'right' in cond_spec:
        left_expr = jsql_expression_to_sqlglot(cond_spec['left'])
        right_expr = jsql_expression_to_sqlglot(cond_spec['right'])
    elif 'field' in cond_spec:
        left_expr = jsql_expression_to_sqlglot(cond_spec['field'])
        if 'value' in cond_spec:
            right_expr = jsql_expression_to_sqlglot({'value': cond_spec['value']})
        elif 'right_field' in cond_spec:
            right_expr = jsql_expression_to_sqlglot(cond_spec['right_field'])
        else:
            raise MissingFieldError(
                'value or right_field',
                path='',
                context='comparison requires right operand',
            )
    else:
        raise MissingFieldError(
            'left/right or field',
            path='',
            context='comparison operation requires operands',
        )
    
    # Standard comparison operators
    operator_class = COMPARISON_OP_TO_SQLGLOT.get(op)
    if operator_class:
        return operator_class(this=left_expr, expression=right_expr)
    
    # Special operators
    if op == JSQLOperator.IN.value:
        if 'values' not in cond_spec:
            raise MissingFieldError('values', path='values', context='IN operator')
        values = cond_spec['values']
        val_exprs = [jsql_expression_to_sqlglot({'value': v}) for v in values]
        return exp.In(this=left_expr, expressions=val_exprs)
    
    if op == JSQLOperator.LIKE.value:
        if 'pattern' not in cond_spec:
            raise MissingFieldError('pattern', path='pattern', context='LIKE operator')
        pattern = cond_spec['pattern']
        return exp.Like(this=left_expr, expression=exp.Literal.string(pattern))
    
    if op == JSQLOperator.IS_NULL.value:
        return exp.Is(this=left_expr, expression=exp.Null())
    
    if op == JSQLOperator.IS_NOT_NULL.value:
        return exp.Not(this=exp.Is(this=left_expr, expression=exp.Null()))
    
    supported = list(COMPARISON_OP_TO_SQLGLOT.keys()) + [
        JSQLOperator.IN.value,
        JSQLOperator.BETWEEN.value,
        JSQLOperator.LIKE.value,
        JSQLOperator.IS_NULL.value,
        JSQLOperator.IS_NOT_NULL.value,
    ]
    raise UnknownOperatorError(operator=op, path='op', supported=supported)


# SQL ‚Üí JSQL conversions

def sqlglot_condition_to_jsql(expr: exp.Expression) -> dict[str, Any]:
    """Convert sqlglot condition to JSQL condition."""
    # AND/OR
    if isinstance(expr, exp.And):
        return {
            'op': JSQLOperator.AND.value,
            'conditions': [
                sqlglot_condition_to_jsql(expr.left),
                sqlglot_condition_to_jsql(expr.right),
            ],
        }
    
    if isinstance(expr, exp.Or):
        return {
            'op': JSQLOperator.OR.value,
            'conditions': [
                sqlglot_condition_to_jsql(expr.left),
                sqlglot_condition_to_jsql(expr.right),
            ],
        }
    
    # NOT
    if isinstance(expr, exp.Not):
        return {
            'op': JSQLOperator.NOT.value,
            'condition': sqlglot_condition_to_jsql(expr.this),
        }
    
    # Comparison operators
    if isinstance(expr, (exp.EQ, exp.NEQ, exp.GT, exp.GTE, exp.LT, exp.LTE)):
        op = SQLGLOT_TO_COMPARISON.get(type(expr))
        if not op:
            raise UnknownOperatorError(
                operator=type(expr).__name__,
                path='',
                supported=list(SQLGLOT_TO_COMPARISON.values()),
            )
        
        left = sqlglot_expression_to_jsql(expr.left)
        right = sqlglot_expression_to_jsql(expr.right)
        
        if 'field' not in left:
            raise InvalidExpressionError(
                message='Comparison left side must be a field reference',
                path='left',
                expression=left,
            )
        
        result: dict[str, Any] = {'field': left['field'], 'op': op}
        
        if 'value' in right:
            result['value'] = right['value']
        elif 'field' in right:
            result['right_field'] = right['field']
        else:
            raise InvalidExpressionError(
                message='Comparison right side must be a value or field',
                path='right',
                expression=right,
            )
        
        return result
    
    # IN
    if isinstance(expr, exp.In):
        left = sqlglot_expression_to_jsql(expr.this)
        if 'field' not in left:
            raise InvalidExpressionError(
                message='IN left side must be a field reference',
                path='left',
                expression=left,
            )
        
        values = []
        if isinstance(expr.expressions, list):
            for val_expr in expr.expressions:
                val = sqlglot_expression_to_jsql(val_expr)
                if 'value' not in val:
                    raise InvalidExpressionError(
                        message='IN values must be literals',
                        path='values',
                        expression=val,
                    )
                values.append(val['value'])
        
        return {
            'field': left['field'],
            'op': JSQLOperator.IN.value,
            'values': values,
        }
    
    # LIKE
    if isinstance(expr, exp.Like):
        left = sqlglot_expression_to_jsql(expr.this)
        right = sqlglot_expression_to_jsql(expr.expression)
        
        if 'field' not in left:
            raise InvalidExpressionError(
                message='LIKE left side must be a field reference',
                path='left',
                expression=left,
            )
        
        if 'value' not in right:
            raise InvalidExpressionError(
                message='LIKE right side must be a string literal',
                path='right',
                expression=right,
            )
        
        return {
            'field': left['field'],
            'op': JSQLOperator.LIKE.value,
            'pattern': right['value'],
        }
    
    # IS NULL / IS NOT NULL
    if isinstance(expr, exp.Is):
        left = sqlglot_expression_to_jsql(expr.this)
        if 'field' not in left:
            raise InvalidExpressionError(
                message='IS NULL left side must be a field reference',
                path='left',
                expression=left,
            )
        
        if isinstance(expr.expression, exp.Null):
            return {
                'field': left['field'],
                'op': JSQLOperator.IS_NULL.value,
            }
        
        raise InvalidExpressionError(
            message='IS expression must be IS NULL',
            path='expression',
            expression={'type': type(expr.expression).__name__},
        )
    
    raise UnsupportedOperationError(
        operation=f'Condition type: {type(expr).__name__}',
        reason='This condition type is not supported in JSQL conversion',
        path='',
    )
```

**–§–∞–π–ª:** `src/namerec/uma/jsql/converter/jsql_to_sql.py`

```python
"""JSQL to SQL conversion."""

import logging

import sqlglot
import sqlglot.expressions as exp
import sqlparse

from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError
from namerec.uma.jsql.conversion_exceptions import MissingFieldError
from namerec.uma.jsql.converter.conditions import jsql_condition_to_sqlglot
from namerec.uma.jsql.converter.expressions import jsql_expression_to_sqlglot
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLQuery

logger = logging.getLogger(__name__)


def jsql_to_sql(jsql: JSQLQuery, dialect: str = 'generic') -> str:
    """
    Convert JSQL query to SQL string.
    
    Args:
        jsql: JSQL query dictionary
        dialect: SQL dialect (generic, postgresql, mysql, sqlite, etc.)
    
    Returns:
        Formatted SQL string
    
    Raises:
        JSQLSyntaxError: If JSQL syntax is invalid
    """
    logger.info(f'Converting JSQL to SQL, dialect={dialect}')
    logger.debug(f'Input JSQL: {jsql}')
    
    try:
        # Build SELECT expression
        select_exprs = _build_select(jsql.get('select', []))
        
        # Build FROM expression
        from_expr = _build_from(jsql.get('from'))
        
        # Start building query
        query = exp.Select(expressions=select_exprs)
        query = query.from_(from_expr)
        
        # Add WHERE clause
        if where_spec := jsql.get('where'):
            where_expr = jsql_condition_to_sqlglot(where_spec)
            query = query.where(where_expr)
        
        # Add JOINs
        if joins := jsql.get('joins'):
            for join_spec in joins:
                join_expr = _build_join(join_spec)
                query = query.join(
                    join_expr['table'],
                    on=join_expr.get('on'),
                    join_type=join_expr.get('type', JoinType.INNER.value),
                )
        
        # Add GROUP BY
        if group_by := jsql.get('group_by'):
            for group_expr_spec in group_by:
                group_expr = jsql_expression_to_sqlglot(group_expr_spec)
                if group_expr:
                    query = query.group_by(group_expr)
        
        # Add HAVING
        if having_spec := jsql.get('having'):
            having_expr = jsql_condition_to_sqlglot(having_spec)
            query.args['having'] = exp.Having(this=having_expr)
        
        # Add ORDER BY
        if order_by := jsql.get('order_by'):
            for order_spec in order_by:
                if isinstance(order_spec, dict):
                    order_expr = jsql_expression_to_sqlglot(order_spec.get('field') or order_spec)
                    direction = order_spec.get('direction', OrderDirection.ASC.value).upper()
                else:
                    order_expr = jsql_expression_to_sqlglot(order_spec)
                    direction = OrderDirection.ASC.value.upper()
                
                if order_expr:
                    desc = direction == OrderDirection.DESC.value.upper()
                    query = query.order_by(order_expr, desc=desc)
        
        # Add LIMIT
        if limit := jsql.get('limit'):
            query.args['limit'] = exp.Limit(expression=exp.Literal.number(limit))
        
        # Add OFFSET
        if offset := jsql.get('offset'):
            query.args['offset'] = exp.Offset(expression=exp.Literal.number(offset))
        
        # Generate SQL
        sql_str = query.sql(dialect=dialect if dialect != 'generic' else None, pretty=True)
        
        # Format for readability
        formatted_sql = sqlparse.format(
            sql_str,
            reindent=True,
            keyword_case='upper',
        )
        
        logger.info(f'Successfully converted JSQL to SQL ({dialect})')
        logger.debug(f'Generated SQL:\n{formatted_sql}')
        return formatted_sql
    
    except JSQLSyntaxError:
        raise
    except Exception as e:
        logger.error(f'Unexpected error during JSQL conversion: {e}', exc_info=True)
        raise JSQLSyntaxError(
            message=f'Failed to convert JSQL to SQL: {e!s}',
            path='',
        ) from e


def _build_select(select_spec: list | None) -> list[exp.Expression]:
    """Convert JSQL SELECT to sqlglot expressions."""
    if not select_spec:
        return [exp.Star()]
    
    result = []
    for field_spec in select_spec:
        field_expr = jsql_expression_to_sqlglot(field_spec)
        if field_expr:
            alias = field_spec.get('alias') if isinstance(field_spec, dict) else None
            if alias:
                field_expr = exp.alias_(field_expr, alias)
            result.append(field_expr)
    
    return result if result else [exp.Star()]


def _build_from(from_spec: str | dict | None) -> exp.Table:
    """Convert JSQL FROM to sqlglot table."""
    if not from_spec:
        raise MissingFieldError('from', path='from', context='SELECT query requires FROM clause')
    
    if isinstance(from_spec, str):
        return exp.table_(from_spec)
    
    if isinstance(from_spec, dict):
        if 'entity' not in from_spec:
            raise MissingFieldError('entity', path='from.entity', context='FROM with alias')
        
        entity = from_spec['entity']
        alias = from_spec.get('alias')
        table = exp.table_(entity)
        if alias:
            table = exp.alias_(table, alias, table=True)
        return table
    
    raise InvalidExpressionError(
        message=f'FROM must be string or dict, got {type(from_spec).__name__}',
        path='from',
        expression={'type': type(from_spec).__name__, 'value': repr(from_spec)},
    )


def _build_join(join_spec: dict) -> dict:
    """Convert JSQL JOIN to sqlglot join components."""
    if not isinstance(join_spec, dict):
        raise InvalidExpressionError(
            message=f'JOIN spec must be dict, got {type(join_spec).__name__}',
            path='joins',
            expression={'type': type(join_spec).__name__, 'value': repr(join_spec)},
        )
    
    if 'entity' not in join_spec:
        raise MissingFieldError('entity', path='joins.entity', context='JOIN')
    
    entity = join_spec['entity']
    join_type = join_spec.get('type', JoinType.INNER.value).upper()
    
    table = exp.table_(entity)
    if alias := join_spec.get('alias'):
        table = exp.alias_(table, alias, table=True)
    
    on_cond = None
    if on_spec := join_spec.get('on'):
        on_cond = jsql_condition_to_sqlglot(on_spec)
    
    return {
        'table': table,
        'on': on_cond,
        'type': join_type,
    }
```

**–§–∞–π–ª:** `src/namerec/uma/jsql/converter/sql_to_jsql.py`

```python
"""SQL to JSQL conversion."""

import logging

import sqlglot
import sqlglot.expressions as exp

from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError
from namerec.uma.jsql.converter.conditions import sqlglot_condition_to_jsql
from namerec.uma.jsql.converter.expressions import sqlglot_expression_to_jsql
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.types import JSQLQuery

logger = logging.getLogger(__name__)

# Join type mapping
SQLGLOT_JOIN_SIDE_TO_TYPE: dict[str, str] = {
    'LEFT': JoinType.LEFT.value,
    'RIGHT': JoinType.RIGHT.value,
    'FULL': JoinType.FULL.value,
}


def sql_to_jsql(sql: str, dialect: str = 'generic') -> JSQLQuery:
    """
    Convert SQL query to JSQL dictionary.
    
    Args:
        sql: SQL query string
        dialect: SQL dialect (generic, postgresql, mysql, sqlite, etc.)
    
    Returns:
        JSQL query dictionary
    
    Raises:
        JSQLSyntaxError: If SQL cannot be parsed or converted
    """
    logger.info(f'Converting SQL to JSQL, dialect={dialect}')
    logger.debug(f'Input SQL: {sql}')
    
    try:
        # Parse SQL with sqlglot
        read_dialect = None if dialect == 'generic' else dialect
        parsed = sqlglot.parse_one(sql, read=read_dialect)
        
        if not isinstance(parsed, exp.Select):
            raise JSQLSyntaxError(
                message='Only SELECT queries are supported',
                path='',
            )
        
        # Convert to JSQL
        jsql: JSQLQuery = {}
        
        # FROM clause
        if from_expr := parsed.args.get('from_'):
            jsql['from'] = _convert_from(from_expr)
        
        # SELECT clause
        if parsed.expressions:
            select_fields = [
                sqlglot_expression_to_jsql(expr)
                for expr in parsed.expressions
            ]
            if select_fields:
                jsql['select'] = select_fields
        
        # WHERE clause
        if parsed.args.get('where'):
            where_expr = parsed.args['where'].this
            jsql['where'] = sqlglot_condition_to_jsql(where_expr)
        
        # JOIN clauses
        if parsed.args.get('joins'):
            joins = [_convert_join(join) for join in parsed.args['joins']]
            if joins:
                jsql['joins'] = joins
        
        # ORDER BY clause
        if parsed.args.get('order'):
            order_by = [
                _convert_order(order_expr)
                for order_expr in parsed.args['order'].expressions
            ]
            if order_by:
                jsql['order_by'] = order_by
        
        # LIMIT clause
        if parsed.args.get('limit'):
            limit_expr = parsed.args['limit'].expression
            if isinstance(limit_expr, exp.Literal):
                jsql['limit'] = int(limit_expr.this)
        
        # OFFSET clause
        if parsed.args.get('offset'):
            offset_expr = parsed.args['offset'].expression
            if isinstance(offset_expr, exp.Literal):
                jsql['offset'] = int(offset_expr.this)
        
        # GROUP BY clause
        if parsed.args.get('group'):
            group_by = [
                sqlglot_expression_to_jsql(group_expr)
                for group_expr in parsed.args['group'].expressions
            ]
            if group_by:
                jsql['group_by'] = group_by
        
        # HAVING clause
        if parsed.args.get('having'):
            having_expr = parsed.args['having'].this
            jsql['having'] = sqlglot_condition_to_jsql(having_expr)
        
        logger.info('Successfully converted SQL to JSQL')
        logger.debug(f'Generated JSQL: {jsql}')
        return jsql
    
    except JSQLSyntaxError:
        raise
    except Exception as e:
        logger.error(f'Unexpected error during SQL parsing: {e}', exc_info=True)
        raise JSQLSyntaxError(
            message=f'Failed to parse SQL: {e!s}',
            path='',
        ) from e


def _convert_from(from_expr: exp.From) -> str | dict:
    """Convert FROM expression to JSQL."""
    if isinstance(from_expr, exp.From):
        table = from_expr.this
        if isinstance(table, exp.Table):
            if table.alias:
                return {
                    'entity': table.name,
                    'alias': table.alias,
                }
            return table.name
    raise InvalidExpressionError(
        message=f'Unsupported FROM type: {type(from_expr).__name__}',
        path='from',
        expression={'type': type(from_expr).__name__},
    )


def _convert_join(join: exp.Join) -> dict:
    """Convert JOIN expression to JSQL."""
    if not isinstance(join, exp.Join):
        raise InvalidExpressionError(
            message=f'Expected exp.Join, got {type(join).__name__}',
            path='joins',
            expression={'type': type(join).__name__},
        )
    
    # Get join type
    join_type = JoinType.INNER.value
    if join.side:
        join_type = SQLGLOT_JOIN_SIDE_TO_TYPE.get(join.side, JoinType.INNER.value)
    
    # Get joined table
    table = join.this
    if not isinstance(table, exp.Table):
        raise InvalidExpressionError(
            message=f'JOIN table must be exp.Table, got {type(table).__name__}',
            path='joins.this',
            expression={'type': type(table).__name__},
        )
    
    result = {
        'type': join_type,
        'entity': table.name,
    }
    
    if table.alias:
        result['alias'] = table.alias
    
    # Get ON condition
    if join.args.get('on'):
        on_arg = join.args['on']
        
        if isinstance(on_arg, (exp.EQ, exp.NEQ, exp.GT, exp.GTE, exp.LT, exp.LTE,
                               exp.And, exp.Or, exp.Not, exp.In, exp.Like, exp.Is)):
            on_expr = on_arg
        elif hasattr(on_arg, 'this') and on_arg.this is not None:
            on_expr = on_arg.this
        else:
            on_expr = on_arg
        
        result['on'] = sqlglot_condition_to_jsql(on_expr)
    
    return result


def _convert_order(order_expr: exp.Ordered) -> dict:
    """Convert ORDER BY expression to JSQL."""
    if not isinstance(order_expr, exp.Ordered):
        raise InvalidExpressionError(
            message=f'Expected exp.Ordered, got {type(order_expr).__name__}',
            path='order_by',
            expression={'type': type(order_expr).__name__},
        )
    
    field_expr = sqlglot_expression_to_jsql(order_expr.this)
    result = field_expr.copy()
    direction = OrderDirection.DESC if order_expr.args.get('desc') else OrderDirection.ASC
    result['direction'] = direction.value.upper()
    
    return result
```

**–û–±–Ω–æ–≤–∏—Ç—å –∏–º–ø–æ—Ä—Ç—ã:** –í—Å–µ —Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É—é—Ç –∏–∑ `converter.py`, –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω—ã:

```python
# –°—Ç–∞—Ä—ã–π –∏–º–ø–æ—Ä—Ç
from namerec.uma.jsql.converter import jsql_to_sql, sql_to_jsql

# –ù–æ–≤—ã–π –∏–º–ø–æ—Ä—Ç (—Ç–∞–∫–æ–π –∂–µ, –±–ª–∞–≥–æ–¥–∞—Ä—è __init__.py)
from namerec.uma.jsql.converter import jsql_to_sql, sql_to_jsql
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –ö–∞–∂–¥—ã–π –º–æ–¥—É–ª—å < 400 —Å—Ç—Ä–æ–∫
- –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å
- –ü—Ä–æ—â–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 6-8 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (–æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —á–µ—Ä–µ–∑ `__init__.py`)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 4: –ù–∞—Ä—É—à–µ–Ω–∏–µ SRP –≤ DefaultMetadataProvider

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è

`DefaultMetadataProvider` —Å–º–µ—à–∏–≤–∞–µ—Ç:
1. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—ç—à–µ–º
2. –†–µ—Ñ–ª–µ–∫—Å–∏—é –ë–î
3. –ü—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–∞
4. –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 4A: –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

**–ù–æ–≤—ã–π —Ñ–∞–π–ª:** `src/namerec/uma/metadata/cache.py`

```python
"""Metadata cache manager."""

from typing import Any

from sqlalchemy import MetaData
from sqlalchemy import Table


class MetadataCache:
    """
    Cache for SQLAlchemy metadata and tables.
    
    Features:
    - Per-namespace caching
    - Lazy loading support
    - Thread-safe operations
    """
    
    def __init__(self, max_namespaces: int = 100) -> None:
        """
        Initialize metadata cache.
        
        Args:
            max_namespaces: Maximum number of namespaces to cache
        """
        self._max_namespaces = max_namespaces
        self._metadata_cache: dict[str, MetaData] = {}
        self._tables_cache: dict[str, dict[str, Table]] = {}
    
    def has_metadata(self, namespace: str) -> bool:
        """Check if metadata is cached for namespace."""
        return namespace in self._metadata_cache
    
    def get_metadata(self, namespace: str) -> MetaData | None:
        """Get cached metadata for namespace."""
        return self._metadata_cache.get(namespace)
    
    def set_metadata(self, namespace: str, metadata: MetaData) -> None:
        """Cache metadata for namespace."""
        # Implement LRU eviction if cache is full
        if len(self._metadata_cache) >= self._max_namespaces:
            # Remove oldest namespace
            oldest = next(iter(self._metadata_cache))
            self.clear_namespace(oldest)
        
        self._metadata_cache[namespace] = metadata
        self._tables_cache[namespace] = {t.name: t for t in metadata.tables.values()}
    
    def get_table(self, namespace: str, table_name: str) -> Table | None:
        """Get cached table for namespace."""
        if namespace not in self._tables_cache:
            return None
        return self._tables_cache[namespace].get(table_name)
    
    def list_tables(self, namespace: str) -> list[str]:
        """List all cached table names for namespace."""
        if namespace not in self._tables_cache:
            return []
        return sorted(self._tables_cache[namespace].keys())
    
    def clear_namespace(self, namespace: str) -> None:
        """Clear cache for namespace."""
        self._metadata_cache.pop(namespace, None)
        self._tables_cache.pop(namespace, None)
    
    def clear_all(self) -> None:
        """Clear all caches."""
        self._metadata_cache.clear()
        self._tables_cache.clear()
```

**–ù–æ–≤—ã–π —Ñ–∞–π–ª:** `src/namerec/uma/metadata/reflector.py`

```python
"""Database schema reflector."""

from sqlalchemy import Engine
from sqlalchemy import MetaData


class DatabaseReflector:
    """
    Reflects database schema using SQLAlchemy.
    
    Handles both sync and async engines.
    """
    
    def __init__(self, schema: str | None = None) -> None:
        """
        Initialize reflector.
        
        Args:
            schema: PostgreSQL schema name (None = default/public)
        """
        self._schema = schema
    
    async def reflect(self, engine: Engine) -> MetaData:
        """
        Reflect database schema.
        
        Args:
            engine: SQLAlchemy Engine
        
        Returns:
            Reflected MetaData object
        
        Raises:
            RuntimeError: If reflection fails
        """
        try:
            metadata = MetaData()
            
            # Check if engine is async or sync
            if hasattr(engine.dialect, 'is_async') and engine.dialect.is_async:
                # Async engine
                async with engine.begin() as conn:
                    await conn.run_sync(metadata.reflect, schema=self._schema)
            else:
                # Sync engine
                metadata.reflect(bind=engine, schema=self._schema)
            
            return metadata
        
        except Exception as e:
            msg = f'Failed to reflect database schema: {e}'
            raise RuntimeError(msg) from e
```

**–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ñ–∞–π–ª:** `src/namerec/uma/metadata.py`

```python
"""Metadata providers for UMA."""

from sqlalchemy import Engine
from sqlalchemy import MetaData
from sqlalchemy import Table

from namerec.uma.core.context import UMAContext
from namerec.uma.core.exceptions import UMANotFoundError
from namerec.uma.core.types import EntityName
from namerec.uma.core.types import Operation
from namerec.uma.metadata.cache import MetadataCache
from namerec.uma.metadata.reflector import DatabaseReflector


class DefaultMetadataProvider:
    """
    Default metadata provider with lazy loading.
    
    Delegates to specialized components:
    - MetadataCache: caching of metadata and tables
    - DatabaseReflector: database schema reflection
    
    Can be extended to provide additional metadata from external sources.
    """
    
    def __init__(
        self,
        schema: str | None = None,
        metadata_store: dict[str, dict] | None = None,
        cache: MetadataCache | None = None,
        reflector: DatabaseReflector | None = None,
    ) -> None:
        """
        Initialize metadata provider.
        
        Args:
            schema: PostgreSQL schema name (None = default/public)
            metadata_store: Optional dictionary with custom metadata
            cache: Optional custom cache (default: new MetadataCache())
            reflector: Optional custom reflector (default: new DatabaseReflector())
        """
        self._schema = schema
        self._metadata_store = metadata_store or {}
        
        # Use dependency injection for components
        self._cache = cache or MetadataCache()
        self._reflector = reflector or DatabaseReflector(schema=schema)
    
    @property
    def schema(self) -> str | None:
        """Get schema name."""
        return self._schema
    
    @property
    def cache(self) -> MetadataCache:
        """Get cache component."""
        return self._cache
    
    @property
    def reflector(self) -> DatabaseReflector:
        """Get reflector component."""
        return self._reflector
    
    async def get_metadata(
        self,
        entity_name: EntityName,
        context: UMAContext,  # noqa: ARG002
    ) -> dict:
        """Get metadata for an entity."""
        key = str(entity_name)
        return self._metadata_store.get(key, {})
    
    def set_metadata(
        self,
        entity_name: str | EntityName,
        metadata: dict,
    ) -> None:
        """Set custom metadata for an entity."""
        key = str(entity_name) if isinstance(entity_name, EntityName) else entity_name
        self._metadata_store[key] = metadata
    
    def update_metadata(
        self,
        entity_name: str | EntityName,
        metadata: dict,
    ) -> None:
        """Update (merge) metadata for an entity."""
        key = str(entity_name) if isinstance(entity_name, EntityName) else entity_name
        if key in self._metadata_store:
            self._metadata_store[key].update(metadata)
        else:
            self._metadata_store[key] = metadata
    
    def clear_metadata(self, entity_name: str | EntityName) -> None:
        """Clear metadata for an entity."""
        key = str(entity_name) if isinstance(entity_name, EntityName) else entity_name
        self._metadata_store.pop(key, None)
    
    async def get_table(
        self,
        entity_name: EntityName,
        engine: Engine,
        context: UMAContext | None = None,
    ) -> Table:
        """
        Get SQLAlchemy Table object for entity (lazy loading).
        
        Raises:
            UMANotFoundError: If table not found
        """
        # Determine namespace
        if entity_name.namespace:
            namespace = entity_name.namespace
        elif context is not None:
            namespace = context.namespace
        else:
            namespace = 'default'
        
        # Check cache
        if table := self._cache.get_table(namespace, entity_name.entity):
            return table
        
        # Load metadata if not cached
        if not self._cache.has_metadata(namespace):
            await self._load_metadata(namespace, engine, context)
        
        # Check again after loading
        if table := self._cache.get_table(namespace, entity_name.entity):
            return table
        
        # Not found
        raise UMANotFoundError(
            str(entity_name),
            f'Table "{entity_name.entity}" not found in namespace "{namespace}"',
        )
    
    async def list_entities(
        self,
        namespace: str,
        context: UMAContext,
    ) -> list[str]:
        """List all entities in namespace."""
        # Load metadata if needed
        if not self._cache.has_metadata(namespace):
            await self._load_metadata(namespace, context.engine, context)
        
        return self._cache.list_tables(namespace)
    
    async def entity_exists(
        self,
        entity_name: EntityName,
        context: UMAContext,
    ) -> bool:
        """Check if entity exists."""
        try:
            await self.get_table(entity_name, context.engine, context)
            return True
        except UMANotFoundError:
            return False
    
    async def preload(self, engine: Engine, namespace: str = 'default') -> None:
        """Preload metadata (optional, for production)."""
        if not self._cache.has_metadata(namespace):
            await self._load_metadata(namespace, engine)
    
    async def _load_metadata(
        self,
        namespace: str,
        engine: Engine,
        context: UMAContext | None = None,
    ) -> None:
        """Load metadata from database."""
        # Use reflector to reflect schema
        metadata = await self._reflector.reflect(engine)
        
        # Cache metadata
        self._cache.set_metadata(namespace, metadata)
        
        # Also cache in context if provided (for JSQL parser compatibility)
        if context is not None:
            context._set_metadata(metadata)
    
    def can(
        self,
        entity_name: str,
        operation: Operation | str,
        context: UMAContext,  # noqa: ARG002
    ) -> bool:
        """
        Check access to operation.
        
        Base implementation allows everything.
        Override in subclass for real access control.
        """
        # Special case: listing entities
        if entity_name == '' and (operation == Operation.META or operation == 'meta'):
            return True
        
        # Base implementation: allow everything
        return True
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
- –ú–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å cache/reflector –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
- LRU-–∫—ç—à –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–∞–º—è—Ç–∏

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 3-4 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (–æ–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 5: –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–ª–æ–Ω–æ–∫

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è

–í `parser.py` –º–µ—Ç–æ–¥ `_resolve_column` –¥–µ–ª–∞–µ—Ç –ª–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫:

```python
# O(n*m) –≥–¥–µ n - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∞–±–ª–∏—Ü, m - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ª–æ–Ω–æ–∫
for table in self.table_aliases.values():
    if hasattr(table, 'columns') and field_spec in table.columns:
        return table.columns[field_spec]
```

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 5A: –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫

**–û–±–Ω–æ–≤–∏—Ç—å —Ñ–∞–π–ª:** `src/namerec/uma/jsql/parser.py`

```python
class JSQLParser:
    """Parser for JSQL (JSON-SQL) queries."""
    
    def __init__(self, context: UMAContext) -> None:
        """Initialize JSQL parser."""
        self.context = context
        self.ctes: dict[str, Select] = {}
        self.table_aliases: dict[str, Any] = {}
        self.select_aliases: dict[str, ColumnElement] = {}
        
        # NEW: Column index for O(1) lookups
        self._column_index: dict[str, list[tuple[str, ColumnElement]]] = {}
        
        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = {
            # ... existing handlers
        }
    
    def _register_table_alias(
        self,
        alias_name: str,
        table: Any,
        *additional_aliases: str,
    ) -> None:
        """
        Register table alias for column resolution.
        
        Also builds column index for fast lookups.
        """
        self.table_aliases[alias_name] = table
        for additional_alias in additional_aliases:
            self.table_aliases[additional_alias] = table
        
        # NEW: Index columns for fast lookup
        if hasattr(table, 'columns'):
            for col in table.columns:
                col_name = col.name
                if col_name not in self._column_index:
                    self._column_index[col_name] = []
                self._column_index[col_name].append((alias_name, col))
    
    async def _resolve_column(
        self,
        field_spec: str,
        from_clause: Any,
    ) -> Column | ColumnElement:
        """
        Resolve column reference (e.g., 'users.id' or 'id').
        
        Uses column index for O(1) lookup instead of O(n*m).
        """
        # Qualified column (table.column)
        if '.' in field_spec:
            table_name, column_name = field_spec.split('.', 1)
            
            # Check table aliases first
            if table_name in self.table_aliases:
                table = self.table_aliases[table_name]
                if hasattr(table, 'columns') and column_name in table.columns:
                    return table.columns[column_name]
            
            # Check CTEs
            if table_name in self.ctes:
                cte = self.ctes[table_name]
                if hasattr(cte, 'columns') and column_name in cte.columns:
                    return cte.columns[column_name]
            
            # Load table via metadata provider
            entity_name = parse_entity_name(table_name)
            try:
                table = await self._get_table_async(entity_name)
                if column_name in table.columns:
                    return table.columns[column_name]
            except Exception as e:
                raise JSQLSyntaxError(f'Column "{field_spec}" not found: {e}') from e
            
            raise JSQLSyntaxError(f'Column "{column_name}" not found in table "{table_name}"')
        
        # NEW: Unqualified column - use index for O(1) lookup
        if field_spec in self._column_index:
            candidates = self._column_index[field_spec]
            
            if len(candidates) == 1:
                # Unique column - return it
                return candidates[0][1]
            
            if len(candidates) > 1:
                # Ambiguous column - need qualification
                tables = ', '.join(c[0] for c in candidates)
                raise JSQLSyntaxError(
                    f'Ambiguous column "{field_spec}" - found in multiple tables: {tables}. '
                    f'Please qualify the column (e.g., table_name.{field_spec})'
                )
        
        # Fallback: check FROM clause
        if from_clause is not None and hasattr(from_clause, 'columns'):
            if field_spec in from_clause.columns:
                return from_clause.columns[field_spec]
        
        raise JSQLSyntaxError(f'Column "{field_spec}" not found in any registered table')
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- O(1) –≤–º–µ—Å—Ç–æ O(n*m) –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–ª–æ–Ω–æ–∫
- –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∞–º–±–∏–≥—É–æ–∑–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫
- –õ—É—á—à–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 2-3 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ (—É–ª—É—á—à–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 6: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –∞–ª–∏–∞—Å–æ–≤

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è

–õ–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–ª–∏–∞—Å–æ–≤ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –≤ `converter.py` –∏ `parser.py`.

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 6A: –ö–ª–∞—Å—Å AliasManager

**–ù–æ–≤—ã–π —Ñ–∞–π–ª:** `src/namerec/uma/jsql/alias_manager.py`

```python
"""Alias management for JSQL queries."""

from typing import Any

from sqlalchemy.sql import ColumnElement

from namerec.uma.jsql.exceptions import JSQLSyntaxError


class AliasManager:
    """
    Manages table and column aliases during query parsing.
    
    Provides:
    - Table alias registration and lookup
    - Column index for fast resolution
    - Ambiguity detection
    """
    
    def __init__(self) -> None:
        """Initialize alias manager."""
        self._table_aliases: dict[str, Any] = {}
        self._column_index: dict[str, list[tuple[str, ColumnElement]]] = {}
        self._select_aliases: dict[str, ColumnElement] = {}
    
    def register_table(
        self,
        alias: str,
        table: Any,
        *additional_aliases: str,
    ) -> None:
        """
        Register table with alias(es).
        
        Args:
            alias: Primary alias name
            table: Table object
            *additional_aliases: Additional alias names
        """
        # Register primary alias
        self._table_aliases[alias] = table
        
        # Register additional aliases
        for add_alias in additional_aliases:
            self._table_aliases[add_alias] = table
        
        # Index columns for fast lookup
        if hasattr(table, 'columns'):
            for col in table.columns:
                col_name = col.name
                if col_name not in self._column_index:
                    self._column_index[col_name] = []
                self._column_index[col_name].append((alias, col))
    
    def get_table(self, alias: str) -> Any | None:
        """Get table by alias."""
        return self._table_aliases.get(alias)
    
    def has_table(self, alias: str) -> bool:
        """Check if table alias exists."""
        return alias in self._table_aliases
    
    def resolve_column(
        self,
        column_name: str,
        table_alias: str | None = None,
    ) -> ColumnElement:
        """
        Resolve column by name.
        
        Args:
            column_name: Column name
            table_alias: Optional table alias for qualification
        
        Returns:
            Resolved column element
        
        Raises:
            JSQLSyntaxError: If column not found or ambiguous
        """
        # Qualified lookup (table.column)
        if table_alias:
            if table_alias not in self._table_aliases:
                raise JSQLSyntaxError(f'Table alias "{table_alias}" not found')
            
            table = self._table_aliases[table_alias]
            if hasattr(table, 'columns') and column_name in table.columns:
                return table.columns[column_name]
            
            raise JSQLSyntaxError(
                f'Column "{column_name}" not found in table "{table_alias}"'
            )
        
        # Unqualified lookup - use index
        if column_name not in self._column_index:
            raise JSQLSyntaxError(f'Column "{column_name}" not found in any table')
        
        candidates = self._column_index[column_name]
        
        if len(candidates) == 1:
            return candidates[0][1]
        
        # Ambiguous column
        tables = ', '.join(c[0] for c in candidates)
        raise JSQLSyntaxError(
            f'Ambiguous column "{column_name}" - found in tables: {tables}. '
            f'Please qualify (e.g., table.{column_name})'
        )
    
    def register_select_alias(self, alias: str, column: ColumnElement) -> None:
        """Register SELECT column alias."""
        self._select_aliases[alias] = column
    
    def get_select_alias(self, alias: str) -> ColumnElement | None:
        """Get SELECT column by alias."""
        return self._select_aliases.get(alias)
    
    def has_select_alias(self, alias: str) -> bool:
        """Check if SELECT alias exists."""
        return alias in self._select_aliases
    
    def list_tables(self) -> list[str]:
        """List all registered table aliases."""
        return list(self._table_aliases.keys())
    
    def list_columns(self, table_alias: str | None = None) -> list[str]:
        """
        List columns.
        
        Args:
            table_alias: Optional table alias to filter by
        
        Returns:
            List of column names
        """
        if table_alias:
            if table_alias not in self._table_aliases:
                return []
            table = self._table_aliases[table_alias]
            if hasattr(table, 'columns'):
                return [col.name for col in table.columns]
            return []
        
        # All columns
        return list(self._column_index.keys())
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ parser.py:**

```python
from namerec.uma.jsql.alias_manager import AliasManager

class JSQLParser:
    """Parser for JSQL (JSON-SQL) queries."""
    
    def __init__(self, context: UMAContext) -> None:
        """Initialize JSQL parser."""
        self.context = context
        self.ctes: dict[str, Select] = {}
        
        # NEW: Use AliasManager
        self._aliases = AliasManager()
        
        # Operator handler dispatch table
        self._condition_handlers: dict[JSQLOperator, Callable] = { ... }
    
    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """Register table alias."""
        self._aliases.register_table(alias_name, table, *additional_aliases)
    
    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """Resolve column reference."""
        # Parse qualified column
        if '.' in field_spec:
            table_name, column_name = field_spec.split('.', 1)
            
            # Try alias manager first
            if self._aliases.has_table(table_name):
                try:
                    return self._aliases.resolve_column(column_name, table_name)
                except JSQLSyntaxError:
                    pass
            
            # Check CTEs
            if table_name in self.ctes:
                cte = self.ctes[table_name]
                if hasattr(cte, 'columns') and column_name in cte.columns:
                    return cte.columns[column_name]
            
            # Load table via metadata provider
            # ... (existing logic)
        
        # Unqualified column - use alias manager
        try:
            return self._aliases.resolve_column(field_spec)
        except JSQLSyntaxError:
            pass
        
        # Fallback: check FROM clause
        if from_clause is not None and hasattr(from_clause, 'columns'):
            if field_spec in from_clause.columns:
                return from_clause.columns[field_spec]
        
        raise JSQLSyntaxError(f'Column "{field_spec}" not found')
    
    def _apply_alias(self, expression: ColumnElement, alias_name: str | None) -> ColumnElement:
        """Apply alias to expression."""
        if alias_name:
            labeled_expr = expression.label(alias_name)
            # Register with alias manager
            self._aliases.register_select_alias(alias_name, labeled_expr)
            return labeled_expr
        return expression
    
    async def _resolve_field_or_alias(self, field_name: str) -> ColumnElement:
        """Resolve field name or SELECT alias."""
        # Check SELECT aliases first
        if self._aliases.has_select_alias(field_name):
            return self._aliases.get_select_alias(field_name)
        
        # Otherwise resolve as column
        return await self._resolve_column(field_name, None)
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –ï–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–ª–∏–∞—Å–∞–º–∏
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å
- –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–π –∏ –∞–º–±–∏–≥—É–æ–∑–Ω–æ—Å—Ç–µ–π
- –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —Ä–∞–∑–Ω—ã—Ö –º–æ–¥—É–ª—è—Ö

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 3-4 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 8: –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤

### –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ 8A: Query Cache

**–ù–æ–≤—ã–π —Ñ–∞–π–ª:** `src/namerec/uma/jsql/query_cache.py`

```python
"""Query cache for parsed JSQL queries."""

import hashlib
import json
from typing import Any

from sqlalchemy import Select

from namerec.uma.jsql.types import JSQLQuery


class QueryCache:
    """
    Cache for parsed JSQL queries.
    
    Caches SQLAlchemy Select objects by JSQL structure (without parameters).
    Provides significant performance improvement for repeated queries.
    """
    
    def __init__(self, max_size: int = 1000) -> None:
        """
        Initialize query cache.
        
        Args:
            max_size: Maximum number of queries to cache
        """
        self._max_size = max_size
        self._cache: dict[str, Select] = {}
        self._access_count: dict[str, int] = {}
    
    def _make_cache_key(self, jsql: JSQLQuery) -> str:
        """
        Create cache key from JSQL.
        
        Removes parameters and dynamic values to create stable key.
        """
        # Create normalized version without parameters
        normalized = self._normalize_jsql(jsql)
        
        # Hash for compact key
        json_str = json.dumps(normalized, sort_keys=True)
        return hashlib.sha256(json_str.encode()).hexdigest()
    
    def _normalize_jsql(self, jsql: JSQLQuery) -> dict[str, Any]:
        """
        Normalize JSQL for caching.
        
        Removes dynamic values but keeps structure.
        """
        normalized: dict[str, Any] = {}
        
        # Keep structural fields
        for key in ['from', 'select', 'joins', 'group_by', 'order_by', 'limit', 'offset']:
            if key in jsql:
                normalized[key] = jsql[key]
        
        # Normalize WHERE clause (remove actual values)
        if 'where' in jsql:
            normalized['where'] = self._normalize_condition(jsql['where'])
        
        # Don't include debug flag in cache key
        return normalized
    
    def _normalize_condition(self, condition: dict[str, Any]) -> dict[str, Any]:
        """Normalize condition by removing actual values."""
        normalized = {'op': condition.get('op')}
        
        # Logical operators
        if 'conditions' in condition:
            normalized['conditions'] = [
                self._normalize_condition(c) for c in condition['conditions']
            ]
        
        if 'condition' in condition:
            normalized['condition'] = self._normalize_condition(condition['condition'])
        
        # Comparison operators - keep structure, remove values
        if 'field' in condition:
            normalized['field'] = condition['field']
        
        if 'left' in condition:
            normalized['left'] = condition['left']
        
        if 'right' in condition:
            # Keep structure marker, not actual value
            normalized['right'] = '<value>'
        
        if 'value' in condition:
            # Keep structure marker
            normalized['value'] = '<value>'
        
        return normalized
    
    def get(self, jsql: JSQLQuery) -> Select | None:
        """
        Get cached query.
        
        Args:
            jsql: JSQL query
        
        Returns:
            Cached Select object or None if not cached
        """
        key = self._make_cache_key(jsql)
        
        if key in self._cache:
            # Track access for LRU
            self._access_count[key] = self._access_count.get(key, 0) + 1
            return self._cache[key]
        
        return None
    
    def put(self, jsql: JSQLQuery, query: Select) -> None:
        """
        Cache query.
        
        Args:
            jsql: JSQL query
            query: Parsed Select object
        """
        key = self._make_cache_key(jsql)
        
        # Evict if cache is full
        if len(self._cache) >= self._max_size:
            # Remove least recently used
            lru_key = min(self._access_count, key=self._access_count.get)
            del self._cache[lru_key]
            del self._access_count[lru_key]
        
        self._cache[key] = query
        self._access_count[key] = 1
    
    def clear(self) -> None:
        """Clear cache."""
        self._cache.clear()
        self._access_count.clear()
    
    def stats(self) -> dict[str, Any]:
        """Get cache statistics."""
        return {
            'size': len(self._cache),
            'max_size': self._max_size,
            'total_accesses': sum(self._access_count.values()),
        }
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ executor.py:**

```python
from namerec.uma.jsql.query_cache import QueryCache

class JSQLExecutor:
    """Executor for JSQL queries."""
    
    def __init__(
        self,
        context: UMAContext,
        use_cache: bool = True,
        cache_size: int = 1000,
    ) -> None:
        """
        Initialize JSQL executor.
        
        Args:
            context: UMA execution context
            use_cache: Enable query caching
            cache_size: Maximum cache size
        """
        self.
```

```markdown
# –ü–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ UMA
**–î–∞—Ç–∞:** 2026-01-13  
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç:** –ü—Ä–æ–±–ª–µ–º—ã 1-6, –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ 8-10

---

## –ü—Ä–æ–±–ª–µ–º–∞ 1: –ù–∞—Ä—É—à–µ–Ω–∏–µ DRY –≤ `api.py`

### –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
–§—É–Ω–∫—Ü–∏–∏ `uma_read`, `uma_save`, `uma_delete`, `uma_entity_details` –∏–º–µ—é—Ç –∏–¥–µ–Ω—Ç–∏—á–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É:

```python
async def uma_read(entity_name: str, id_value: Any, user_context: Any = None, namespace: str | None = None) -> dict:
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    context = _create_context(entity.namespace, user_context)
    _check_access(str(entity), Operation.READ, context)
    handler = await get_registry().get_handler(entity, context)
    return await handler.read(entity, id_value, context)
```

### –†–µ—à–µ–Ω–∏–µ

**–í–∞—Ä–∏–∞–Ω—Ç A: –ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è-–¥–∏—Å–ø–µ—Ç—á–µ—Ä**

```python
async def _dispatch_entity_operation(
    entity_name: str,
    operation: Operation,
    handler_method: str,
    namespace: str | None,
    user_context: Any,
    **operation_args: Any
) -> Any:
    """
    Common dispatcher for entity operations.
    
    Args:
        entity_name: Entity name (with or without namespace prefix)
        operation: Operation type for access control
        handler_method: Name of handler method to call
        namespace: Optional namespace override
        user_context: User context for access control
        **operation_args: Arguments to pass to handler method
    
    Returns:
        Result from handler method
    """
    # Parse entity name and resolve namespace
    entity = parse_entity_name(entity_name)
    if namespace and not entity.namespace:
        entity = EntityName(entity=entity.entity, namespace=namespace)
    
    # Create context and check access
    context = _create_context(entity.namespace, user_context)
    _check_access(str(entity), operation, context)
    
    # Execute operation
    handler = await get_registry().get_handler(entity, context)
    method = getattr(handler, handler_method)
    return await method(entity, context, **operation_args)


# Simplified API functions
async def uma_read(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Read a record by id."""
    return await _dispatch_entity_operation(
        entity_name=entity_name,
        operation=Operation.READ,
        handler_method='read',
        namespace=namespace,
        user_context=user_context,
        id_value=id_value,
    )


async def uma_save(
    entity_name: str,
    data: dict,
    user_context: Any = None,
    namespace: str | None = None,
) -> Any:
    """Save a record (create if id=None, otherwise update)."""
    # Determine operation type
    has_id = any(data.get(key) is not None for key in ['id', 'ID'])
    operation = Operation.UPDATE if has_id else Operation.CREATE
    
    return await _dispatch_entity_operation(
        entity_name=entity_name,
        operation=operation,
        handler_method='save',
        namespace=namespace,
        user_context=user_context,
        data=data,
    )


async def uma_delete(
    entity_name: str,
    id_value: Any,
    user_context: Any = None,
    namespace: str | None = None,
) -> bool:
    """Delete a record by id."""
    return await _dispatch_entity_operation(
        entity_name=entity_name,
        operation=Operation.DELETE,
        handler_method='delete',
        namespace=namespace,
        user_context=user_context,
        id_value=id_value,
    )


async def uma_entity_details(
    entity_name: str,
    user_context: Any = None,
    namespace: str | None = None,
) -> dict:
    """Get entity metadata."""
    return await _dispatch_entity_operation(
        entity_name=entity_name,
        operation=Operation.META,
        handler_method='meta',
        namespace=namespace,
        user_context=user_context,
    )
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∫–æ–¥–∞ —Å ~200 —Å—Ç—Ä–æ–∫ –¥–æ ~80 —Å—Ç—Ä–æ–∫
- –ï–¥–∏–Ω–∞—è —Ç–æ—á–∫–∞ –¥–ª—è –ª–æ–≥–∏–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏–∏
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 2-3 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ (–Ω–µ breaking change)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 2: –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

### –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
```python
# api.py
_registry: EntityRegistry | None = None

# namespace_config.py
_namespace_configs: Mapping[str, NamespaceConfig] | None = None
_default_namespace: str | None = None

# registry.py
_global_registry: EntityRegistry | None = None
```

### –†–µ—à–µ–Ω–∏–µ

**–°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è:**

```python
# src/namerec/uma/application.py

from dataclasses import dataclass, field
from typing import Any, Mapping

from namerec.uma.core.namespace_config import NamespaceConfig
from namerec.uma.core.types import EntityHandler, EntityName, Operation
from namerec.uma.core.utils import parse_entity_name
from namerec.uma.handlers.base import DefaultEntityHandler
from namerec.uma.registry import EntityRegistry


@dataclass
class UMAApplication:
    """
    UMA application instance.
    
    Encapsulates all UMA state and configuration.
    Replaces global variables with explicit dependency injection.
    """
    
    namespace_configs: Mapping[str, NamespaceConfig]
    default_namespace: str | None = None
    registry: EntityRegistry = field(default_factory=lambda: EntityRegistry(DefaultEntityHandler))
    
    def __post_init__(self) -> None:
        """Validate configuration."""
        if not self.namespace_configs:
            msg = 'At least one namespace configuration required'
            raise ValueError(msg)
        
        # Auto-set default namespace if single namespace
        if len(self.namespace_configs) == 1 and self.default_namespace is None:
            self.default_namespace = next(iter(self.namespace_configs.keys()))
    
    def get_namespace_config(self, namespace: str | None = None) -> NamespaceConfig:
        """Get namespace configuration."""
        if namespace is None:
            if self.default_namespace is None:
                msg = 'No default namespace configured'
                raise ValueError(msg)
            namespace = self.default_namespace
        
        if namespace not in self.namespace_configs:
            available = ', '.join(self.namespace_configs.keys())
            msg = f'Namespace "{namespace}" not found. Available: {available}'
            raise ValueError(msg)
        
        return self.namespace_configs[namespace]
    
    # API Methods
    async def read(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """Read a record by id."""
        return await self._dispatch_operation(
            entity_name=entity_name,
            operation=Operation.READ,
            handler_method='read',
            namespace=namespace,
            user_context=user_context,
            id_value=id_value,
        )
    
    async def save(
        self,
        entity_name: str,
        data: dict,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> Any:
        """Save a record."""
        has_id = any(data.get(key) is not None for key in ['id', 'ID'])
        operation = Operation.UPDATE if has_id else Operation.CREATE
        
        return await self._dispatch_operation(
            entity_name=entity_name,
            operation=operation,
            handler_method='save',
            namespace=namespace,
            user_context=user_context,
            data=data,
        )
    
    async def delete(
        self,
        entity_name: str,
        id_value: Any,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> bool:
        """Delete a record by id."""
        return await self._dispatch_operation(
            entity_name=entity_name,
            operation=Operation.DELETE,
            handler_method='delete',
            namespace=namespace,
            user_context=user_context,
            id_value=id_value,
        )
    
    async def entity_details(
        self,
        entity_name: str,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """Get entity metadata."""
        return await self._dispatch_operation(
            entity_name=entity_name,
            operation=Operation.META,
            handler_method='meta',
            namespace=namespace,
            user_context=user_context,
        )
    
    async def entity_list(
        self,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> list[str]:
        """Get list of all available entities."""
        from namerec.uma.core.context import UMAContext
        
        config = self.get_namespace_config(namespace)
        actual_namespace = namespace or self.default_namespace
        
        context = UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
        )
        
        # Check access
        if hasattr(config.metadata_provider, 'can'):
            if not config.metadata_provider.can('', Operation.META, context):
                from namerec.uma.core.exceptions import UMAAccessDeniedError
                raise UMAAccessDeniedError('', Operation.META.value)
        
        entities = await config.metadata_provider.list_entities(actual_namespace, context)
        
        # Format with namespace prefix if not default
        if actual_namespace != self.default_namespace:
            return [f'{actual_namespace}:{e}' for e in entities]
        
        return entities
    
    async def select(
        self,
        jsql: dict,
        params: dict | None = None,
        user_context: Any = None,
        namespace: str | None = None,
    ) -> dict:
        """Execute JSQL query."""
        from namerec.uma.jsql.executor import JSQLExecutor
        from namerec.uma.core.context import UMAContext
        
        # Extract entity_name from JSQL
        entity_name = jsql.get('from')
        if not entity_name:
            msg = "JSQL must contain 'from' field"
            raise ValueError(msg)
        
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)
        
        # Get config and create context
        config = self.get_namespace_config(entity.namespace)
        actual_namespace = entity.namespace or self.default_namespace
        
        context = UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
        )
        
        # Check access
        if hasattr(config.metadata_provider, 'can'):
            if not config.metadata_provider.can(str(entity), Operation.SELECT, context):
                from namerec.uma.core.exceptions import UMAAccessDeniedError
                raise UMAAccessDeniedError(str(entity), Operation.SELECT.value)
        
        # Execute JSQL query
        executor = JSQLExecutor(context)
        result = await executor.execute(jsql, params)
        
        return result.to_dict()
    
    # Internal helper
    async def _dispatch_operation(
        self,
        entity_name: str,
        operation: Operation,
        handler_method: str,
        namespace: str | None,
        user_context: Any,
        **operation_args: Any
    ) -> Any:
        """Common dispatcher for entity operations."""
        from namerec.uma.core.context import UMAContext
        
        # Parse entity name
        entity = parse_entity_name(entity_name)
        if namespace and not entity.namespace:
            entity = EntityName(entity=entity.entity, namespace=namespace)
        
        # Get config and create context
        config = self.get_namespace_config(entity.namespace)
        actual_namespace = entity.namespace or self.default_namespace
        
        context = UMAContext(
            engine=config.engine,
            metadata_provider=config.metadata_provider,
            namespace=actual_namespace,
            user_context=user_context,
        )
        
        # Check access
        if hasattr(config.metadata_provider, 'can'):
            if not config.metadata_provider.can(str(entity), operation, context):
                from namerec.uma.core.exceptions import UMAAccessDeniedError
                raise UMAAccessDeniedError(str(entity), operation.value)
        
        # Get handler and execute
        handler = await self.registry.get_handler(entity, context)
        method = getattr(handler, handler_method)
        return await method(entity, **operation_args, context=context)
```

**–û–±–Ω–æ–≤–∏—Ç—å API –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏:**

```python
# src/namerec/uma/api.py

from typing import Any
from namerec.uma.application import UMAApplication
from namerec.uma.core.namespace_config import NamespaceConfig

# Global application instance (for backward compatibility)
_app: UMAApplication | None = None


def uma_initialize(
    namespace_configs: dict[str, NamespaceConfig],
    default_handler: type | None = None,
) -> UMAApplication:
    """
    Initialize UMA application.
    
    Returns UMAApplication instance that should be used directly.
    Also sets global instance for backward compatibility.
    """
    global _app
    
    app = UMAApplication(
        namespace_configs=namespace_configs,
    )
    
    if default_handler:
        app.registry.set_default_handler(default_handler)
    
    _app = app
    return app


def get_app() -> UMAApplication:
    """Get initialized UMA application."""
    if _app is None:
        msg = 'UMA not initialized. Call uma_initialize() first.'
        raise RuntimeError(msg)
    return _app


# Backward compatible API (delegates to app)
async def uma_read(entity_name: str, id_value: Any, user_context: Any = None, namespace: str | None = None) -> dict:
    """Read a record by id."""
    return await get_app().read(entity_name, id_value, user_context, namespace)


async def uma_save(entity_name: str, data: dict, user_context: Any = None, namespace: str | None = None) -> Any:
    """Save a record."""
    return await get_app().save(entity_name, data, user_context, namespace)


async def uma_delete(entity_name: str, id_value: Any, user_context: Any = None, namespace: str | None = None) -> bool:
    """Delete a record."""
    return await get_app().delete(entity_name, id_value, user_context, namespace)


# ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ (–Ω–æ–≤—ã–π —Å—Ç–∏–ª—å):**

```python
# –í–º–µ—Å—Ç–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
app = uma_initialize({
    'main': NamespaceConfig(engine=engine, metadata_provider=provider)
})

# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ app
result = await app.read('users', id=1)
result = await app.select({'from': 'users', 'select': [{'field': '*'}]})

# –ò–ª–∏ —Å—Ç–∞—Ä—ã–π —Å—Ç–∏–ª—å (—á–µ—Ä–µ–∑ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏)
result = await uma_read('users', id=1)
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤
- –û–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 8-10 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –°—Ä–µ–¥–Ω–∏–µ (breaking change –¥–ª—è advanced use cases)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 3: –ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π `converter.py`

### –†–µ—à–µ–Ω–∏–µ: –†–∞–∑–±–∏—Ç—å –Ω–∞ –º–æ–¥—É–ª–∏

**–ù–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:**

```
jsql/converter/
‚îú‚îÄ‚îÄ __init__.py                 # Public API
‚îú‚îÄ‚îÄ jsql_to_sql.py             # JSQL ‚Üí SQL (–≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è)
‚îú‚îÄ‚îÄ sql_to_jsql.py             # SQL ‚Üí JSQL (–≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è)
‚îú‚îÄ‚îÄ expressions.py             # –ö–æ–Ω–≤–µ—Ä—Å–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏–π
‚îú‚îÄ‚îÄ conditions.py              # –ö–æ–Ω–≤–µ—Ä—Å–∏—è —É—Å–ª–æ–≤–∏–π
‚îú‚îÄ‚îÄ operators.py               # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
‚îú‚îÄ‚îÄ joins.py                   # –û–±—Ä–∞–±–æ—Ç–∫–∞ JOIN'–æ–≤
‚îî‚îÄ‚îÄ constants.py               # –ú–∞–ø–ø–∏–Ω–≥–∏ –∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã (–ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –∏–∑ jsql/constants.py)
```

**–î–µ—Ç–∞–ª–∏ —Å–º. –≤ —Ñ–∞–π–ª–µ REFACTORING_PLAN_PART2.md**

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 6-8 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ (—á–∏—Å—Ç–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 4: `DefaultMetadataProvider` - –Ω–∞—Ä—É—à–µ–Ω–∏–µ SRP

### –†–µ—à–µ–Ω–∏–µ: –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

```python
# src/namerec/uma/metadata/cache.py
from sqlalchemy import MetaData, Table

class MetadataCache:
    """Cache for database metadata and tables."""
    
    def __init__(self, max_size: int = 100) -> None:
        self._metadata_cache: dict[str, MetaData] = {}
        self._tables_cache: dict[str, dict[str, Table]] = {}
        self._max_size = max_size
    
    def get_metadata(self, namespace: str) -> MetaData | None:
        """Get cached metadata for namespace."""
        return self._metadata_cache.get(namespace)
    
    def set_metadata(self, namespace: str, metadata: MetaData) -> None:
        """Cache metadata for namespace."""
        self._metadata_cache[namespace] = metadata
        self._tables_cache[namespace] = {t.name: t for t in metadata.tables.values()}
    
    def get_table(self, namespace: str, table_name: str) -> Table | None:
        """Get cached table."""
        return self._tables_cache.get(namespace, {}).get(table_name)
    
    def list_tables(self, namespace: str) -> list[str]:
        """List all tables in namespace."""
        return sorted(self._tables_cache.get(namespace, {}).keys())


# src/namerec/uma/metadata/reflector.py
class DatabaseReflector:
    """Reflects database schema using SQLAlchemy."""
    
    def __init__(self, schema: str | None = None) -> None:
        self._schema = schema
    
    async def reflect(self, engine: Engine) -> MetaData:
        """Reflect database schema."""
        metadata = MetaData()
        
        if hasattr(engine.dialect, 'is_async') and engine.dialect.is_async:
            async with engine.begin() as conn:
                await conn.run_sync(metadata.reflect, schema=self._schema)
        else:
            metadata.reflect(bind=engine, schema=self._schema)
        
        return metadata


# src/namerec/uma/metadata/provider.py
class DefaultMetadataProvider:
    """
    Default metadata provider with lazy loading.
    Now uses composition instead of doing everything itself.
    """
    
    def __init__(
        self,
        schema: str | None = None,
        metadata_store: dict[str, dict] | None = None,
        cache_size: int = 100,
    ) -> None:
        self._schema = schema
        self._metadata_store = metadata_store or {}
        
        # Components
        self._cache = MetadataCache(max_size=cache_size)
        self._reflector = DatabaseReflector(schema=schema)
    
    async def get_table(self, entity_name: EntityName, engine: Engine, context: UMAContext | None = None) -> Table:
        """Get SQLAlchemy Table object."""
        namespace = entity_name.namespace or (context.namespace if context else 'default')
        
        # Check cache
        if table := self._cache.get_table(namespace, entity_name.entity):
            return table
        
        # Load metadata if not cached
        if not self._cache.get_metadata(namespace):
            await self._load_metadata(namespace, engine, context)
        
        # Check again after loading
        if table := self._cache.get_table(namespace, entity_name.entity):
            return table
        
        raise UMANotFoundError(str(entity_name), f'Table not found: {entity_name.entity}')
    
    async def _load_metadata(self, namespace: str, engine: Engine, context: UMAContext | None = None) -> None:
        """Load metadata using reflector and cache it."""
        metadata = await self._reflector.reflect(engine)
        self._cache.set_metadata(namespace, metadata)
        
        if context:
            context._set_metadata(metadata)
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π
- –õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
- –ú–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –∫—ç—à –Ω–∞ Redis, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 4-5 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ (–≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥)

---

## –ü—Ä–æ–±–ª–µ–º–∞ 5: –ù–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –∫–æ–ª–æ–Ω–æ–∫ –≤ `parser.py`

### –†–µ—à–µ–Ω–∏–µ: –°–æ–∑–¥–∞—Ç—å –∏–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫

```python
# –í –∫–ª–∞—Å—Å–µ JSQLParser –¥–æ–±–∞–≤–∏—Ç—å:

class JSQLParser:
    def __init__(self, context: UMAContext) -> None:
        self.context = context
        self.ctes: dict[str, Select] = {}
        self.table_aliases: dict[str, Any] = {}
        self.select_aliases: dict[str, ColumnElement] = {}
        
        # NEW: Column index for O(1) lookups
        self._column_index: dict[str, list[tuple[str, ColumnElement]]] = {}
    
    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """Register table alias and index its columns."""
        # Register alias
        self.table_aliases[alias_name] = table
        for additional_alias in additional_aliases:
            self.table_aliases[additional_alias] = table
        
        # NEW: Index columns for fast lookup
        if hasattr(table, 'columns'):
            for col in table.columns:
                if col.name not in self._column_index:
                    self._column_index[col.name] = []
                self._column_index[col.name].append((alias_name, col))
    
    async def _resolve_column(self, field_spec: str, from_clause: Any) -> Column | ColumnElement:
        """Resolve column reference with O(1) lookup."""
        # Qualified column (table.column)
        if '.' in field_spec:
            table_name, column_name = field_spec.split('.', 1)
            
            # Check table aliases
            if table_name in self.table_aliases:
                table = self.table_aliases[table_name]
                if hasattr(table, 'columns') and column_name in table.columns:
                    return table.columns[column_name]
            
            # Check CTEs
            if table_name in self.ctes:
                cte = self.ctes[table_name]
                if hasattr(cte, 'columns') and column_name in cte.columns:
                    return cte.columns[column_name]
            
            raise JSQLSyntaxError(f'Column "{field_spec}" not found')
        
        # NEW: Unqualified column - use index for O(1) lookup
        if candidates := self._column_index.get(field_spec):
            if len(candidates) == 1:
                return candidates[0][1]
            
            # Multiple matches - ambiguous
            tables = [c[0] for c in candidates]
            raise JSQLSyntaxError(
                f'Ambiguous column "{field_spec}" found in tables: {", ".join(tables)}. '
                f'Please qualify with table name.'
            )
        
        # Fallback to FROM clause
        if from_clause is not None and hasattr(from_clause, 'columns'):
            if field_spec in from_clause.columns:
                return from_clause.columns[field_spec]
        
        raise JSQLSyntaxError(f'Column "{field_spec}" not found')
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞: O(n*m) ‚Üí O(1)
- –õ—É—á—à–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (—Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± ambiguous columns)
- –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ –ø—Ä–∏ –±–æ–ª—å—à–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ JOIN'–æ–≤

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 3-4 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

---

## –ü—Ä–æ–±–ª–µ–º–∞ 6: –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –∞–ª–∏–∞—Å–æ–≤

### –†–µ—à–µ–Ω–∏–µ: –°–æ–∑–¥–∞—Ç—å `AliasManager`

```python
# src/namerec/uma/jsql/alias_manager.py

from typing import Any
from sqlalchemy import Column
from sqlalchemy.sql import ColumnElement

class AliasManager:
    """
    Manages table and column aliases for query parsing.
    Eliminates duplication between converter and parser.
    """
    
    def __init__(self) -> None:
        self._table_aliases: dict[str, Any] = {}
        self._column_index: dict[str, list[tuple[str, ColumnElement]]] = {}
        self._select_aliases: dict[str, ColumnElement] = {}
    
    def register_table(self, alias: str, table: Any, *additional_aliases: str) -> None:
        """Register table with one or more aliases."""
        self._table_aliases[alias] = table
        for additional_alias in additional_aliases:
            self._table_aliases[additional_alias] = table
        
        # Index columns
        if hasattr(table, 'columns'):
            for col in table.columns:
                if col.name not in self._column_index:
                    self._column_index[col.name] = []
                self._column_index[col.name].append((alias, col))
    
    def register_select_alias(self, alias: str, expression: ColumnElement) -> None:
        """Register SELECT clause alias."""
        self._select_aliases[alias] = expression
    
    def resolve_column(self, field_spec: str, from_clause: Any = None) -> ColumnElement:
        """
        Resolve column reference.
        
        Supports:
        - Qualified: table.column
        - Unqualified: column
        - SELECT aliases
        """
        # Check SELECT aliases first
        if field_spec in self._select_aliases:
            return self._select_aliases[field_spec]
        
        # Qualified column
        if '.' in field_spec:
            table_name, column_name = field_spec.split('.', 1)
            if table_name in self._table_aliases:
                table = self._table_aliases[table_name]
                if hasattr(table, 'columns') and column_name in table.columns:
                    return table.columns[column_name]
            raise ValueError(f'Column not found: {field_spec}')
        
        # Unqualified - use index
        if candidates := self._column_index.get(field_spec):
            if len(candidates) == 1:
                return candidates[0][1]
            tables = [c[0] for c in candidates]
            raise ValueError(f'Ambiguous column "{field_spec}" in: {", ".join(tables)}')
        
        # Fallback to FROM clause
        if from_clause and hasattr(from_clause, 'columns') and field_spec in from_clause.columns:
            return from_clause.columns[field_spec]
        
        raise ValueError(f'Column not found: {field_spec}')
    
    def get_table(self, alias: str) -> Any:
        """Get table by alias."""
        return self._table_aliases.get(alias)
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ parser.py:**

```python
class JSQLParser:
    def __init__(self, context: UMAContext) -> None:
        self.context = context
        self.ctes: dict[str, Select] = {}
        self.alias_manager = AliasManager()  # NEW
        
        # OLD - remove these:
        # self.table_aliases: dict[str, Any] = {}
        # self.select_aliases: dict[str, ColumnElement] = {}
    
    def _register_table_alias(self, alias_name: str, table: Any, *additional_aliases: str) -> None:
        """Register table alias."""
        self.alias_manager.register_table(alias_name, table, *additional_aliases)
    
    async def _resolve_column(self, field_spec: str, from_clause: Any) -> ColumnElement:
        """Resolve column reference."""
        try:
            return self.alias_manager.resolve_column(field_spec, from_clause)
        except ValueError as e:
            raise JSQLSyntaxError(str(e)) from e
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –ï–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–ª–∏–∞—Å–∞–º–∏
- –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ converter.py
- –ü—Ä–æ—â–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 2-3 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 8: –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

### –†–µ—à–µ–Ω–∏–µ

```python
# src/namerec/uma/jsql/query_cache.py

import hashlib
import json
from typing import Any
from sqlalchemy import Select
from functools import lru_cache

class JSQLQueryCache:
    """Cache for parsed JSQL queries."""
    
    def __init__(self, max_size: int = 1000) -> None:
        self._cache: dict[str, Select] = {}
        self._max_size = max_size
    
    def make_key(self, jsql: dict) -> str:
        """Create cache key from JSQL (excluding params)."""
        # Remove debug and params from cache key
        cache_jsql = {k: v for k, v in jsql.items() if k not in ('debug', 'params')}
        # Stable JSON serialization
        json_str = json.dumps(cache_jsql, sort_keys=True)
        return hashlib.sha256(json_str.encode()).hexdigest()
    
    def get(self, key: str) -> Select | None:
        """Get cached query."""
        return self._cache.get(key)
    
    def set(self, key: str, query: Select) -> None:
        """Cache query with LRU eviction."""
        if len(self._cache) >= self._max_size:
            # Remove oldest item (simple FIFO, could use collections.OrderedDict)
            first_key = next(iter(self._cache))
            del self._cache[first_key]
        self._cache[key] = query


# –í JSQLExecutor:

class JSQLExecutor:
    def __init__(self, context: UMAContext, enable_cache: bool = True) -> None:
        self.context = context
        self.parser = JSQLParser(context)
        self._cache = JSQLQueryCache() if enable_cache else None
    
    async def execute(self, jsql: dict, params: dict | None = None) -> QueryResult:
        """Execute JSQL query with caching."""
        try:
            # Try cache first
            cache_key = None
            if self._cache:
                cache_key = self._cache.make_key(jsql)
                if cached_query := self._cache.get(cache_key):
                    # Use cached query
                    query = cached_query
                else:
                    # Parse and cache
                    query = await self.parser.parse(jsql, params)
                    self._cache.set(cache_key, query)
            else:
                # No cache - just parse
                query = await self.parser.parse(jsql, params)
            
            # Generate debug SQL if requested
            debug_sql: str | None = None
            if jsql.get('debug', False):
                debug_sql = self._compile_query_to_sql(query)
            
            # Execute query
            async with self.context.engine.connect() as conn:
                result = await conn.execute(query)
                query_result = JSQLResultBuilder.build_result(result, query, debug_sql)
                return query_result
        
        except (JSQLExecutionError, JSQLSyntaxError):
            raise
        except Exception as e:
            raise JSQLExecutionError(
                message=f'Failed to execute JSQL query: {e!s}',
                query=jsql,
                original_error=e,
            ) from e
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –£—Å–∫–æ—Ä–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤
- –û—Å–æ–±–µ–Ω–Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –¥–ª—è dashboard-–ø–æ–¥–æ–±–Ω—ã—Ö UI
- –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –≤–∫–ª—é—á–µ–Ω–∏–µ (–¥–ª—è –¥–µ–±–∞–≥–∞ –º–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å)

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 4-5 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 9: –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã—Ö –∏–º–ø–æ—Ä—Ç–æ–≤

### –¢–µ–∫—É—â–∞—è –ø—Ä–æ–±–ª–µ–º–∞

```
registry.py ‚Üí handlers/base.py (–∏–º–ø–æ—Ä—Ç –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏)
utils.py ‚Üí api.py ‚Üí registry.py (–∏–º–ø–æ—Ä—Ç –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏)
parser.py ‚Üí utils.py (–∏–º–ø–æ—Ä—Ç –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏)
```

### –†–µ—à–µ–Ω–∏–µ: –†–µ–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

**–ù–æ–≤–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:**

```
Level 1: core/types.py, core/exceptions.py
         ‚Üì
Level 2: core/context.py, core/namespace_config.py
         ‚Üì
Level 3: core/utils.py, metadata.py
         ‚Üì
Level 4: handlers/base.py, handlers/virtual.py
         ‚Üì
Level 5: registry.py
         ‚Üì
Level 6: jsql/* (parser, executor, etc.)
         ‚Üì
Level 7: application.py
         ‚Üì
Level 8: api.py (backward compatibility layer)
```

**–ò–∑–º–µ–Ω–µ–Ω–∏—è:**

1. **–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å `get_table` –∏–∑ utils –≤ metadata provider:**

```python
# metadata.py
class DefaultMetadataProvider:
    async def get_table(self, entity_name: EntityName, engine: Engine, context: UMAContext | None = None) -> Table:
        """Get table - now primary method, not helper."""
        ...

# utils.py - remove get_table, replace with direct calls to metadata_provider
```

2. **–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å registry –≤ application:**

```python
# –í–º–µ—Å—Ç–æ get_registry() –≤ utils.py
# –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å app.registry –≤ application.py
```

3. **–£–¥–∞–ª–∏—Ç—å –∏–º–ø–æ—Ä—Ç—ã –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–π** - –≤—Å–µ –∏–º–ø–æ—Ä—Ç—ã –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- –ß–∏—Å—Ç–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
- –ù–µ—Ç —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã—Ö –∏–º–ø–æ—Ä—Ç–æ–≤
- –ë—ã—Å—Ç—Ä–µ–µ –∑–∞–ø—É—Å–∫ (–∏–º–ø–æ—Ä—Ç—ã –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —Å—Ä–∞–∑—É)

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 3-4 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –°—Ä–µ–¥–Ω–∏–µ (–Ω—É–∂–Ω–æ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ)

---

## –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 10: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ Builder/Factory

### Builder –¥–ª—è UMAContext

```python
# src/namerec/uma/builders.py

from dataclasses import dataclass, field
from typing import Any
from sqlalchemy import Engine
from namerec.uma.core.context import UMAContext
from namerec.uma.core.types import MetadataProvider

@dataclass
class UMAContextBuilder:
    """
    Builder for UMAContext.
    Simplifies creation and makes testing easier.
    """
    
    _engine: Engine | None = None
    _metadata_provider: MetadataProvider | None = None
    _namespace: str = 'default'
    _user_context: Any = None
    _cache: Any = None
    _extra: dict[str, Any] = field(default_factory=dict)
    
    def with_engine(self, engine: Engine) -> 'UMAContextBuilder':
        """Set engine."""
        self._engine = engine
        return self
    
    def with_metadata_provider(self, provider: MetadataProvider) -> 'UMAContextBuilder':
        """Set metadata provider."""
        self._metadata_provider = provider
        return self
    
    def with_namespace(self, namespace: str) -> 'UMAContextBuilder':
        """Set namespace."""
        self._namespace = namespace
        return self
    
    def with_user_context(self, user_context: Any) -> 'UMAContextBuilder':
        """Set user context."""
        self._user_context = user_context
        return self
    
    def with_cache(self, cache: Any) -> 'UMAContextBuilder':
        """Set cache."""
        self._cache = cache
        return self
    
    def with_extra(self, **kwargs: Any) -> 'UMAContextBuilder':
        """Add extra fields."""
        self._extra.update(kwargs)
        return self
    
    def build(self) -> UMAContext:
        """Build UMAContext instance."""
        if not self._engine:
            raise ValueError('Engine is required')
        if not self._metadata_provider:
            raise ValueError('MetadataProvider is required')
        if not self._namespace:
            raise ValueError('Namespace is required')
        
        return UMAContext(
            engine=self._engine,
            metadata_provider=self._metadata_provider,
            namespace=self._namespace,
            user_context=self._user_context,
            cache=self._cache,
            extra=self._extra,
        )


# Factory –¥–ª—è JSQLExecutor
class JSQLExecutorFactory:
    """Factory for creating JSQLExecutor instances."""
    
    @staticmethod
    def create(
        context: UMAContext,
        enable_cache: bool = True,
        cache_size: int = 1000,
    ) -> 'JSQLExecutor':
        """Create JSQLExecutor with configuration."""
        from namerec.uma.jsql.executor import JSQLExecutor
        return JSQLExecutor(context, enable_cache=enable_cache, cache_size=cache_size)
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**

```python
# Testing
context = (UMAContextBuilder()
    .with_engine(test_engine)
    .with_metadata_provider(test_provider)
    .with_namespace('test')
    .with_user_context({'user_id': 123})
    .build())

# Production
executor = JSQLExecutorFactory.create(
    context=context,
    enable_cache=True,
    cache_size=5000,
)
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:**
- Fluent interface –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
- –õ–µ–≥—á–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∏–∫—Å—Ç—É—Ä—ã
- –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 2-3 —á–∞—Å–∞  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

---

## –ò—Ç–æ–≥–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞

| –ü—Ä–æ–±–ª–µ–º–∞/–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è | –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç | –ß–∞—Å—ã | –†–∏—Å–∫ | –ü–æ–ª—å–∑–∞ |
|----------------------|-----------|------|------|--------|
| 1. DRY –≤ api.py | üî¥ –í—ã—Å–æ–∫–∏–π | 2-3 | –ù–∏–∑–∫–∏–π | –í—ã—Å–æ–∫–∞—è |
| 2. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ | üî¥ –í—ã—Å–æ–∫–∏–π | 8-10 | –°—Ä–µ–¥–Ω–∏–π | –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è |
| 3. –†–∞–∑–±–∏—Ç—å converter.py | üî¥ –í—ã—Å–æ–∫–∏–π | 6-8 | –ù–∏–∑–∫–∏–π | –í—ã—Å–æ–∫–∞—è |
| 4. –†–∞–∑–±–∏—Ç—å MetadataProvider | üü† –°—Ä–µ–¥–Ω–∏–π | 4-5 | –ù–∏–∑–∫–∏–π | –°—Ä–µ–¥–Ω—è—è |
| 5. –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫ | üü† –°—Ä–µ–¥–Ω–∏–π | 3-4 | –ù–∏–∑–∫–∏–π | –í—ã—Å–æ–∫–∞—è |
| 6. AliasManager | üü† –°—Ä–µ–¥–Ω–∏–π | 2-3 | –ù–∏–∑–∫–∏–π | –°—Ä–µ–¥–Ω—è—è |
| 8. –ö—ç—à –∑–∞–ø—Ä–æ—Å–æ–≤ | üü° –ù–∏–∑–∫–∏–π | 4-5 | –ù–∏–∑–∫–∏–π | –°—Ä–µ–¥–Ω—è—è |
| 9. –¶–∏—Ä–∫—É–ª—è—Ä–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã | üü° –ù–∏–∑–∫–∏–π | 3-4 | –°—Ä–µ–¥–Ω–∏–π | –°—Ä–µ–¥–Ω—è—è |
| 10. Builder/Factory | üü° –ù–∏–∑–∫–∏–π | 2-3 | –ù–∏–∑–∫–∏–π | –ù–∏–∑–∫–∞—è |

**–ò–¢–û–ì–û:** 37-47 —á–∞—Å–æ–≤ (5-6 —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π)

---

## –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –ø–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

### –§–∞–∑–∞ 1: Quick wins (1 –¥–µ–Ω—å)
1. –ü—Ä–æ–±–ª–µ–º–∞ 1: DRY –≤ api.py
2. –ü—Ä–æ–±–ª–µ–º–∞ 6: AliasManager
3. –ü—Ä–æ–±–ª–µ–º–∞ 5: –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫

### –§–∞–∑–∞ 2: –í–∞–∂–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ (2-3 –¥–Ω—è)
4. –ü—Ä–æ–±–ª–µ–º–∞ 3: –†–∞–∑–±–∏—Ç—å converter.py
5. –ü—Ä–æ–±–ª–µ–º–∞ 4: –†–∞–∑–±–∏—Ç—å MetadataProvider

### –§–∞–∑–∞ 3: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (2 –¥–Ω—è)
6. –ü—Ä–æ–±–ª–µ–º–∞ 2: –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ‚Üí UMAApplication
7. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 9: –£—Å—Ç—Ä–∞–Ω–∏—Ç—å —Ü–∏—Ä–∫—É–ª—è—Ä–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã

### –§–∞–∑–∞ 4: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
8. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 8: –ö—ç—à –∑–∞–ø—Ä–æ—Å–æ–≤
9. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 10: Builder/Factory

---

**–ö–æ–Ω–µ—Ü –ø–ª–∞–Ω–∞**

```

```markdown
# –ü–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ - –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–±–ª–µ–º—ã 3

## –ü—Ä–æ–±–ª–µ–º–∞ 3: –†–∞–∑–±–∏–µ–Ω–∏–µ –≥–∏–≥–∞–Ω—Ç—Å–∫–æ–≥–æ `converter.py` (1033 —Å—Ç—Ä–æ–∫–∏)

### –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

**–¢–µ–∫—É—â–∏–π —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç:**
- JSQL ‚Üí SQL –∫–æ–Ω–≤–µ—Ä—Å–∏—é (—Å—Ç—Ä–æ–∫–∏ 74-192)
- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è JSQL ‚Üí SQL (—Å—Ç—Ä–æ–∫–∏ 194-582)
- SQL ‚Üí JSQL –∫–æ–Ω–≤–µ—Ä—Å–∏—é (—Å—Ç—Ä–æ–∫–∏ 584-720)
- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è SQL ‚Üí JSQL (—Å—Ç—Ä–æ–∫–∏ 723-1033)
- –ú–∞–ø–ø–∏–Ω–≥–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ (—Å—Ç—Ä–æ–∫–∏ 28-72)

### –ù–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π

```
jsql/converter/
‚îú‚îÄ‚îÄ __init__.py                 # Public API, re-exports
‚îú‚îÄ‚îÄ types.py                    # Shared types
‚îú‚îÄ‚îÄ constants.py                # Operator mappings (–ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –∏–∑ jsql/constants.py)
‚îú‚îÄ‚îÄ jsql_to_sql.py             # Main function jsql_to_sql()
‚îú‚îÄ‚îÄ sql_to_jsql.py             # Main function sql_to_jsql()
‚îú‚îÄ‚îÄ expressions.py             # Expression conversion (both directions)
‚îú‚îÄ‚îÄ conditions.py              # Condition conversion (both directions)
‚îú‚îÄ‚îÄ operators.py               # Operator handlers (both directions)
‚îî‚îÄ‚îÄ joins.py                   # JOIN conversion (both directions)
```

---

## –î–µ—Ç–∞–ª—å–Ω–∞—è —Ä–∞–∑–±–∏–≤–∫–∞ —Ñ–∞–π–ª–æ–≤

### 1. `jsql/converter/__init__.py`

```python
"""
JSQL ‚Üî SQL conversion utilities.

Public API for bidirectional conversion between JSQL and SQL formats.
"""

from namerec.uma.jsql.converter.jsql_to_sql import jsql_to_sql
from namerec.uma.jsql.converter.sql_to_jsql import sql_to_jsql

__all__ = ['jsql_to_sql', 'sql_to_jsql']
```

---

### 2. `jsql/converter/constants.py`

–ü–µ—Ä–µ–Ω–µ—Å—Ç–∏ –≤—Å–µ –º–∞–ø–ø–∏–Ω–≥–∏ –∏–∑ `jsql/constants.py` –∏ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ:

```python
"""Operator and type mappings for JSQL ‚Üî SQL conversion."""

from enum import Enum
import sqlglot.expressions as exp
from namerec.uma.jsql.constants import JSQLOperator

# JSQL ‚Üí SQLGlot mappings
ARITHMETIC_OP_TO_SQLGLOT: dict[str, type[exp.Expression]] = {
    JSQLOperator.ADD.value: exp.Add,
    JSQLOperator.SUB.value: exp.Sub,
    JSQLOperator.MUL.value: exp.Mul,
    JSQLOperator.DIV.value: exp.Div,
}

COMPARISON_OP_TO_SQLGLOT: dict[str, type[exp.Expression]] = {
    JSQLOperator.EQ.value: exp.EQ,
    JSQLOperator.NE.value: exp.NEQ,
    JSQLOperator.GT.value: exp.GT,
    JSQLOperator.GE.value: exp.GTE,
    JSQLOperator.LT.value: exp.LT,
    JSQLOperator.LE.value: exp.LTE,
}

LOGICAL_OP_TO_SQLGLOT: dict[str, type[exp.Expression]] = {
    JSQLOperator.AND.value: exp.And,
    JSQLOperator.OR.value: exp.Or,
}

# SQLGlot ‚Üí JSQL mappings (reverse)
SQLGLOT_TO_ARITHMETIC: dict[type[exp.Expression], str] = {
    v: k for k, v in ARITHMETIC_OP_TO_SQLGLOT.items()
}

SQLGLOT_TO_COMPARISON: dict[type[exp.Expression], str] = {
    v: k for k, v in COMPARISON_OP_TO_SQLGLOT.items()
}

SQLGLOT_TO_LOGICAL: dict[type[exp.Expression], str] = {
    v: k for k, v in LOGICAL_OP_TO_SQLGLOT.items()
}

# Join type mappings
SQLGLOT_JOIN_SIDE_TO_TYPE: dict[str, str] = {
    'LEFT': 'LEFT',
    'RIGHT': 'RIGHT',
    'FULL': 'FULL',
}
```

---

### 3. `jsql/converter/expressions.py`

```python
"""Expression conversion utilities for JSQL ‚Üî SQL."""

import logging
from typing import Any
import sqlglot.expressions as exp

from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError, UnknownOperatorError
from namerec.uma.jsql.converter.constants import (
    ARITHMETIC_OP_TO_SQLGLOT,
    SQLGLOT_TO_ARITHMETIC,
)

logger = logging.getLogger(__name__)


# ===== JSQL ‚Üí SQL =====

def jsql_expression_to_sqlglot(expr_spec: dict[str, Any] | str) -> exp.Expression:
    """
    Convert JSQL expression to sqlglot expression.
    
    Handles:
    - Field references: {"field": "name"} or "name"
    - Literals: {"value": 123}
    - Functions: {"func": "COUNT", "args": [...]}
    - Arithmetic: {"op": "+", "left": {...}, "right": {...}}
    """
    if isinstance(expr_spec, str):
        return convert_field_reference(expr_spec)
    
    if isinstance(expr_spec, dict):
        if 'field' in expr_spec:
            return convert_field_reference(expr_spec['field'])
        if 'value' in expr_spec:
            return convert_literal_value(expr_spec['value'])
        if 'func' in expr_spec:
            return convert_function_call(expr_spec)
        if 'op' in expr_spec:
            return convert_arithmetic_op(expr_spec)
        
        raise InvalidExpressionError(
            message="Expression must contain: 'field', 'value', 'func', or 'op'",
            path='',
            expression=expr_spec
        )
    
    raise InvalidExpressionError(
        message=f'Expression must be string or dict, got {type(expr_spec).__name__}',
        path='',
        expression={'type': type(expr_spec).__name__}
    )


def convert_field_reference(field: str) -> exp.Expression:
    """Convert field reference to sqlglot column."""
    if field == '*':
        return exp.Star()
    if '.' in field:
        table, column = field.split('.', 1)
        return exp.column(column, table=table)
    return exp.column(field)


def convert_literal_value(value: Any) -> exp.Expression:
    """Convert literal value to sqlglot expression."""
    match value:
        case bool():
            return exp.Boolean(this=value)
        case int() | float():
            return exp.Literal.number(value)
        case _:
            return exp.Literal.string(str(value))


def convert_function_call(expr_spec: dict[str, Any]) -> exp.Expression:
    """Convert function call to sqlglot expression."""
    func = expr_spec['func']
    logger.debug(f'Converting function: {func}')
    
    # Convert args
    args = [
        converted
        for arg in expr_spec.get('args', [])
        if (converted := jsql_expression_to_sqlglot(arg)) is not None
    ]
    
    # Try specific sqlglot function class
    func_class = getattr(exp, func.upper(), None)
    if func_class and issubclass(func_class, exp.Func):
        return func_class(*args)
    
    # Fallback to Anonymous function
    return exp.Anonymous(this=func, expressions=args)


def convert_arithmetic_op(expr_spec: dict[str, Any]) -> exp.Expression:
    """Convert arithmetic operation to sqlglot expression."""
    from namerec.uma.jsql.conversion_exceptions import MissingFieldError
    
    op = expr_spec.get('op')
    if not op:
        raise MissingFieldError('op', path='op', context='arithmetic operation')
    
    if 'left' not in expr_spec:
        raise MissingFieldError('left', path='left', context='arithmetic operation')
    if 'right' not in expr_spec:
        raise MissingFieldError('right', path='right', context='arithmetic operation')
    
    left = jsql_expression_to_sqlglot(expr_spec['left'])
    right = jsql_expression_to_sqlglot(expr_spec['right'])
    
    operator_class = ARITHMETIC_OP_TO_SQLGLOT.get(op)
    if not operator_class:
        raise UnknownOperatorError(
            operator=op,
            path='op',
            supported=list(ARITHMETIC_OP_TO_SQLGLOT.keys())
        )
    
    return operator_class(this=left, expression=right)


# ===== SQL ‚Üí JSQL =====

def sqlglot_expression_to_jsql(expr: exp.Expression) -> dict[str, Any]:
    """
    Convert sqlglot expression to JSQL.
    
    Raises:
        InvalidExpressionError: If expression type not supported
        UnknownOperatorError: If operator not recognized
    """
    from namerec.uma.jsql.conversion_exceptions import UnsupportedOperationError
    
    # Aliased expressions
    if isinstance(expr, exp.Alias):
        base_expr = sqlglot_expression_to_jsql(expr.this)
        base_expr['alias'] = expr.alias
        return base_expr
    
    # Column references
    if isinstance(expr, exp.Column):
        result = {'field': expr.name}
        if expr.table:
            result['field'] = f'{expr.table}.{expr.name}'
        return result
    
    # Literals
    if isinstance(expr, exp.Literal):
        return {'value': expr.this}
    
    # Star
    if isinstance(expr, exp.Star):
        return {'field': '*'}
    
    # Functions
    if isinstance(expr, exp.Func):
        func_name = expr.sql_name()
        args = [
            converted
            for arg in expr.args.values()
            if isinstance(arg, exp.Expression) and (converted := sqlglot_expression_to_jsql(arg)) is not None
        ]
        return {'func': func_name, 'args': args}
    
    # Arithmetic operations
    if isinstance(expr, (exp.Add, exp.Sub, exp.Mul, exp.Div)):
        op = SQLGLOT_TO_ARITHMETIC.get(type(expr))
        if not op:
            raise UnknownOperatorError(
                operator=type(expr).__name__,
                path='',
                supported=list(SQLGLOT_TO_ARITHMETIC.values())
            )
        
        return {
            'op': op,
            'left': sqlglot_expression_to_jsql(expr.left),
            'right': sqlglot_expression_to_jsql(expr.right),
        }
    
    # Unsupported
    raise UnsupportedOperationError(
        operation=f'Expression type: {type(expr).__name__}',
        reason='This expression type is not supported',
        path=''
    )
```

---

### 4. `jsql/converter/conditions.py`

```python
"""Condition conversion utilities for JSQL ‚Üî SQL."""

import logging
from typing import Any
import sqlglot.expressions as exp

from namerec.uma.jsql.constants import JSQLOperator, LOGICAL_OPERATORS
from namerec.uma.jsql.conversion_exceptions import (
    InvalidExpressionError,
    MissingFieldError,
    UnknownOperatorError,
)
from namerec.uma.jsql.converter.constants import (
    COMPARISON_OP_TO_SQLGLOT,
    LOGICAL_OP_TO_SQLGLOT,
    SQLGLOT_TO_COMPARISON,
)
from namerec.uma.jsql.converter.expressions import (
    jsql_expression_to_sqlglot,
    sqlglot_expression_to_jsql,
)

logger = logging.getLogger(__name__)


# ===== JSQL ‚Üí SQL =====

def jsql_condition_to_sqlglot(cond_spec: dict[str, Any]) -> exp.Expression:
    """
    Convert JSQL condition to sqlglot expression.
    
    Handles:
    - Logical: AND, OR, NOT
    - Comparison: =, !=, <, >, <=, >=
    - Special: IN, LIKE, BETWEEN, IS NULL, IS NOT NULL
    """
    if not isinstance(cond_spec, dict):
        raise InvalidExpressionError(
            message=f'Condition must be dict, got {type(cond_spec).__name__}',
            path='',
            expression={'type': type(cond_spec).__name__}
        )
    
    if 'op' not in cond_spec:
        raise MissingFieldError('op', path='op', context='condition')
    
    op = cond_spec['op']
    
    # Logical operators
    if op in LOGICAL_OPERATORS:
        return convert_logical_operator(op, cond_spec)
    
    # Comparison operators
    return convert_comparison_operator(op, cond_spec)


def convert_logical_operator(op: str, cond_spec: dict[str, Any]) -> exp.Expression:
    """Convert logical operator (AND/OR/NOT)."""
    logger.debug(f'Converting logical operator: {op}')
    
    # AND/OR
    if op in (JSQLOperator.AND.value, JSQLOperator.OR.value):
        if 'conditions' not in cond_spec:
            raise MissingFieldError('conditions', path='conditions', context=f'{op} operator')
        
        conditions = cond_spec['conditions']
        if not conditions:
            raise InvalidExpressionError(
                message=f'{op} operator requires at least one condition',
                path='conditions'
            )
        
        result = jsql_condition_to_sqlglot(conditions[0])
        operator_class = LOGICAL_OP_TO_SQLGLOT[op]
        
        for cond in conditions[1:]:
            next_cond = jsql_condition_to_sqlglot(cond)
            result = operator_class(this=result, expression=next_cond)
        
        return result
    
    # NOT
    if op == JSQLOperator.NOT.value:
        if 'condition' not in cond_spec:
            raise MissingFieldError('condition', path='condition', context='NOT operator')
        
        condition = jsql_condition_to_sqlglot(cond_spec['condition'])
        return exp.Not(this=condition)
    
    raise UnknownOperatorError(
        operator=op,
        path='op',
        supported=[JSQLOperator.AND.value, JSQLOperator.OR.value, JSQLOperator.NOT.value]
    )


def convert_comparison_operator(op: str, cond_spec: dict[str, Any]) -> exp.Expression:
    """
    Convert comparison operator.
    
    Supports old and new JSQL formats:
    - Old: {"op": "=", "field": "x", "value": 1}
    - New: {"op": "=", "left": {"field": "x"}, "right": {"value": 1}}
    """
    logger.debug(f'Converting comparison operator: {op}')
    
    # BETWEEN has special structure
    if op == JSQLOperator.BETWEEN.value:
        if 'expr' not in cond_spec:
            raise MissingFieldError('expr', path='expr', context='BETWEEN')
        if 'low' not in cond_spec:
            raise MissingFieldError('low', path='low', context='BETWEEN')
        if 'high' not in cond_spec:
            raise MissingFieldError('high', path='high', context='BETWEEN')
        
        expr = jsql_expression_to_sqlglot(cond_spec['expr'])
        low_expr = jsql_expression_to_sqlglot(cond_spec['low'])
        high_expr = jsql_expression_to_sqlglot(cond_spec['high'])
        
        return exp.Between(this=expr, low=low_expr, high=high_expr)
    
    # Get left/right expressions (support both formats)
    if 'left' in cond_spec and 'right' in cond_spec:
        # New format
        left_expr = jsql_expression_to_sqlglot(cond_spec['left'])
        right_expr = jsql_expression_to_sqlglot(cond_spec['right'])
    elif 'field' in cond_spec:
        # Old format
        left_expr = jsql_expression_to_sqlglot(cond_spec['field'])
        
        if 'value' in cond_spec:
            right_expr = jsql_expression_to_sqlglot({'value': cond_spec['value']})
        elif 'right_field' in cond_spec:
            right_expr = jsql_expression_to_sqlglot(cond_spec['right_field'])
        else:
            raise MissingFieldError(
                'value or right_field',
                path='',
                context='comparison requires right operand'
            )
    else:
        raise MissingFieldError(
            'left/right or field',
            path='',
            context='comparison requires operands'
        )
    
    # Standard comparison operators
    if operator_class := COMPARISON_OP_TO_SQLGLOT.get(op):
        return operator_class(this=left_expr, expression=right_expr)
    
    # Special operators
    if op == JSQLOperator.IN.value:
        if 'values' not in cond_spec:
            raise MissingFieldError('values', path='values', context='IN operator')
        val_exprs = [jsql_expression_to_sqlglot({'value': v}) for v in cond_spec['values']]
        return exp.In(this=left_expr, expressions=val_exprs)
    
    if op == JSQLOperator.LIKE.value:
        if 'pattern' not in cond_spec:
            raise MissingFieldError('pattern', path='pattern', context='LIKE operator')
        return exp.Like(this=left_expr, expression=exp.Literal.string(cond_spec['pattern']))
    
    if op == JSQLOperator.IS_NULL.value:
        return exp.Is(this=left_expr, expression=exp.Null())
    
    if op == JSQLOperator.IS_NOT_NULL.value:
        return exp.Not(this=exp.Is(this=left_expr, expression=exp.Null()))
    
    # Unknown operator
    supported = list(COMPARISON_OP_TO_SQLGLOT.keys()) + [
        JSQLOperator.IN.value,
        JSQLOperator.BETWEEN.value,
        JSQLOperator.LIKE.value,
        JSQLOperator.IS_NULL.value,
        JSQLOperator.IS_NOT_NULL.value,
    ]
    raise UnknownOperatorError(operator=op, path='op', supported=supported)


# ===== SQL ‚Üí JSQL =====

def sqlglot_condition_to_jsql(expr: exp.Expression) -> dict[str, Any]:
    """
    Convert sqlglot condition to JSQL.
    
    Handles all comparison and logical operators.
    """
    from namerec.uma.jsql.conversion_exceptions import UnsupportedOperationError
    
    # AND/OR
    if isinstance(expr, exp.And):
        return {
            'op': JSQLOperator.AND.value,
            'conditions': [
                sqlglot_condition_to_jsql(expr.left),
                sqlglot_condition_to_jsql(expr.right),
            ],
        }
    
    if isinstance(expr, exp.Or):
        return {
            'op': JSQLOperator.OR.value,
            'conditions': [
                sqlglot_condition_to_jsql(expr.left),
                sqlglot_condition_to_jsql(expr.right),
            ],
        }
    
    # NOT
    if isinstance(expr, exp.Not):
        return {
            'op': JSQLOperator.NOT.value,
            'condition': sqlglot_condition_to_jsql(expr.this),
        }
    
    # Comparison operators
    if isinstance(expr, (exp.EQ, exp.NEQ, exp.GT, exp.GTE, exp.LT, exp.LTE)):
        op = SQLGLOT_TO_COMPARISON[type(expr)]
        left = sqlglot_expression_to_jsql(expr.left)
        right = sqlglot_expression_to_jsql(expr.right)
        
        if 'field' not in left:
            raise InvalidExpressionError(
                message='Left side must be field',
                path='left',
                expression=left
            )
        
        result = {'field': left['field'], 'op': op}
        
        if 'value' in right:
            result['value'] = right['value']
        elif 'field' in right:
            result['right_field'] = right['field']
        else:
            raise InvalidExpressionError(
                message='Right side must be value or field',
                path='right',
                expression=right
            )
        
        return result
    
    # IN
    if isinstance(expr, exp.In):
        left = sqlglot_expression_to_jsql(expr.this)
        if 'field' not in left:
            raise InvalidExpressionError(
                message='IN left side must be field',
                path='left',
                expression=left
            )
        
        values = []
        for val_expr in expr.expressions:
            val = sqlglot_expression_to_jsql(val_expr)
            if 'value' not in val:
                raise InvalidExpressionError(
                    message='IN values must be literals',
                    path='values',
                    expression=val
                )
            values.append(val['value'])
        
        return {
            'field': left['field'],
            'op': JSQLOperator.IN.value,
            'values': values,
        }
    
    # LIKE
    if isinstance(expr, exp.Like):
        left = sqlglot_expression_to_jsql(expr.this)
        right = sqlglot_expression_to_jsql(expr.expression)
        
        if 'field' not in left or 'value' not in right:
            raise InvalidExpressionError(
                message='LIKE requires field and value',
                path='',
                expression={'left': left, 'right': right}
            )
        
        return {
            'field': left['field'],
            'op': JSQLOperator.LIKE.value,
            'pattern': right['value'],
        }
    
    # IS NULL
    if isinstance(expr, exp.Is) and isinstance(expr.expression, exp.Null):
        left = sqlglot_expression_to_jsql(expr.this)
        if 'field' not in left:
            raise InvalidExpressionError(
                message='IS NULL requires field',
                path='left',
                expression=left
            )
        
        return {
            'field': left['field'],
            'op': JSQLOperator.IS_NULL.value,
        }
    
    # Unsupported
    raise UnsupportedOperationError(
        operation=f'Condition type: {type(expr).__name__}',
        reason='Condition type not supported',
        path=''
    )
```

---

### 5. `jsql/converter/joins.py`

```python
"""JOIN conversion utilities for JSQL ‚Üî SQL."""

import logging
from typing import Any
import sqlglot.expressions as exp

from namerec.uma.jsql.constants import JoinType
from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError, MissingFieldError
from namerec.uma.jsql.converter.conditions import jsql_condition_to_sqlglot, sqlglot_condition_to_jsql
from namerec.uma.jsql.converter.constants import SQLGLOT_JOIN_SIDE_TO_TYPE

logger = logging.getLogger(__name__)


# ===== JSQL ‚Üí SQL =====

def jsql_join_to_sqlglot(join_spec: dict[str, Any]) -> dict[str, Any]:
    """
    Convert JSQL JOIN to sqlglot join components.
    
    Returns dict with:
    - table: sqlglot Table expression
    - on: sqlglot condition (optional)
    - type: join type string
    """
    if not isinstance(join_spec, dict):
        raise InvalidExpressionError(
            message=f'JOIN must be dict, got {type(join_spec).__name__}',
            path='joins',
            expression={'type': type(join_spec).__name__}
        )
    
    if 'entity' not in join_spec:
        raise MissingFieldError('entity', path='joins.entity', context='JOIN')
    
    entity = join_spec['entity']
    join_type = join_spec.get('type', JoinType.INNER.value).upper()
    logger.debug(f'Converting {join_type} JOIN to {entity}')
    
    # Build table expression
    table = exp.table_(entity)
    if alias := join_spec.get('alias'):
        table = exp.alias_(table, alias, table=True)
    
    # Build ON condition
    on_cond = None
    if on_spec := join_spec.get('on'):
        on_cond = jsql_condition_to_sqlglot(on_spec)
    
    return {
        'table': table,
        'on': on_cond,
        'type': join_type,
    }


# ===== SQL ‚Üí JSQL =====

def sqlglot_join_to_jsql(join: exp.Join) -> dict[str, Any]:
    """
    Convert sqlglot JOIN to JSQL.
    
    Returns JSQL join specification.
    """
    if not isinstance(join, exp.Join):
        raise InvalidExpressionError(
            message=f'Expected exp.Join, got {type(join).__name__}',
            path='joins',
            expression={'type': type(join).__name__}
        )
    
    # Get join type
    join_type = JoinType.INNER.value
    if join.side:
        join_type = SQLGLOT_JOIN_SIDE_TO_TYPE.get(join.side, JoinType.INNER.value)
    
    # Get joined table
    table = join.this
    if not isinstance(table, exp.Table):
        raise InvalidExpressionError(
            message=f'JOIN table must be Table, got {type(table).__name__}',
            path='joins.this',
            expression={'type': type(table).__name__}
        )
    
    result: dict[str, Any] = {
        'type': join_type,
        'entity': table.name,
    }
    
    if table.alias:
        result['alias'] = table.alias
    
    # Get ON condition
    if join.args.get('on'):
        on_arg = join.args['on']
        
        # Determine actual condition expression
        if isinstance(on_arg, (exp.EQ, exp.NEQ, exp.GT, exp.GTE, exp.LT, exp.LTE, 
                              exp.And, exp.Or, exp.Not, exp.In, exp.Like, exp.Is)):
            on_expr = on_arg
        elif hasattr(on_arg, 'this') and on_arg.this is not None:
            on_expr = on_arg.this
        else:
            on_expr = on_arg
        
        on_jsql = sqlglot_condition_to_jsql(on_expr)
        result['on'] = on_jsql
    
    return result
```

---

### 6. `jsql/converter/jsql_to_sql.py`

```python
"""Main function for JSQL ‚Üí SQL conversion."""

import logging
import sqlparse
import sqlglot.expressions as exp

from namerec.uma.jsql.constants import JoinType, OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.converter.expressions import jsql_expression_to_sqlglot
from namerec.uma.jsql.converter.conditions import jsql_condition_to_sqlglot
from namerec.uma.jsql.converter.joins import jsql_join_to_sqlglot

logger = logging.getLogger(__name__)


def jsql_to_sql(jsql: dict, dialect: str = 'generic') -> str:
    """
    Convert JSQL query to SQL string.
    
    Args:
        jsql: JSQL query dictionary
        dialect: SQL dialect (generic, postgresql, mysql, sqlite, etc.)
    
    Returns:
        Formatted SQL string
    
    Raises:
        JSQLSyntaxError: If JSQL syntax is invalid
    """
    logger.info(f'Converting JSQL to SQL, dialect={dialect}')
    logger.debug(f'Input JSQL: {jsql}')
    
    try:
        # Build SELECT expressions
        select_exprs = _build_select(jsql.get('select', []))
        
        # Build FROM expression
        from_expr = _build_from(jsql.get('from'))
        
        # Start building query
        query = exp.Select(expressions=select_exprs)
        query = query.from_(from_expr)
        
        # Add WHERE
        if where_spec := jsql.get('where'):
            where_expr = jsql_condition_to_sqlglot(where_spec)
            query = query.where(where_expr)
        
        # Add JOINs
        if joins := jsql.get('joins'):
            for join_spec in joins:
                join_expr = jsql_join_to_sqlglot(join_spec)
                query = query.join(
                    join_expr['table'],
                    on=join_expr.get('on'),
                    join_type=join_expr.get('type', JoinType.INNER.value),
                )
        
        # Add GROUP BY
        if group_by := jsql.get('group_by'):
            for group_expr_spec in group_by:
                group_expr = jsql_expression_to_sqlglot(group_expr_spec)
                if group_expr:
                    query = query.group_by(group_expr)
        
        # Add HAVING
        if having_spec := jsql.get('having'):
            having_expr = jsql_condition_to_sqlglot(having_spec)
            query.args['having'] = exp.Having(this=having_expr)
        
        # Add ORDER BY
        if order_by := jsql.get('order_by'):
            for order_spec in order_by:
                if isinstance(order_spec, dict):
                    order_expr = jsql_expression_to_sqlglot(order_spec.get('field') or order_spec)
                    direction = order_spec.get('direction', OrderDirection.ASC.value).upper()
                else:
                    order_expr = jsql_expression_to_sqlglot(order_spec)
                    direction = OrderDirection.ASC.value.upper()
                
                if order_expr:
                    desc = direction == OrderDirection.DESC.value.upper()
                    query = query.order_by(order_expr, desc=desc)
        
        # Add LIMIT/OFFSET
        if limit := jsql.get('limit'):
            query.args['limit'] = exp.Limit(expression=exp.Literal.number(limit))
        
        if offset := jsql.get('offset'):
            query.args['offset'] = exp.Offset(expression=exp.Literal.number(offset))
        
        # Generate SQL
        sql_str = query.sql(dialect=dialect if dialect != 'generic' else None, pretty=True)
        
        # Format
        formatted_sql = sqlparse.format(
            sql_str,
            reindent=True,
            keyword_case='upper',
        )
        
        logger.info(f'Successfully converted JSQL to SQL ({dialect})')
        return formatted_sql
    
    except JSQLSyntaxError:
        raise
    except Exception as e:
        logger.error(f'Conversion error: {e}', exc_info=True)
        raise JSQLSyntaxError(
            message=f'Failed to convert JSQL to SQL: {e!s}',
            path='',
        ) from e


def _build_select(select_spec: list | None) -> list[exp.Expression]:
    """Build SELECT clause expressions."""
    if not select_spec:
        return [exp.Star()]
    
    result = []
    for field_spec in select_spec:
        field_expr = jsql_expression_to_sqlglot(field_spec)
        if field_expr:
            alias = field_spec.get('alias') if isinstance(field_spec, dict) else None
            if alias:
                field_expr = exp.alias_(field_expr, alias)
            result.append(field_expr)
    
    return result if result else [exp.Star()]


def _build_from(from_spec: str | dict | None) -> exp.Table:
    """Build FROM clause expression."""
    from namerec.uma.jsql.conversion_exceptions import MissingFieldError, InvalidExpressionError
    
    if not from_spec:
        raise MissingFieldError('from', path='from', context='SELECT requires FROM')
    
    if isinstance(from_spec, str):
        return exp.table_(from_spec)
    
    if isinstance(from_spec, dict):
        if 'entity' not in from_spec:
            raise MissingFieldError('entity', path='from.entity', context='FROM with alias')
        
        entity = from_spec['entity']
        alias = from_spec.get('alias')
        table = exp.table_(entity)
        if alias:
            table = exp.alias_(table, alias, table=True)
        return table
    
    raise InvalidExpressionError(
        message=f'FROM must be string or dict, got {type(from_spec).__name__}',
        path='from',
        expression={'type': type(from_spec).__name__}
    )
```

---

### 7. `jsql/converter/sql_to_jsql.py`

```python
"""Main function for SQL ‚Üí JSQL conversion."""

import logging
import sqlglot
import sqlglot.expressions as exp

from namerec.uma.jsql.constants import OrderDirection
from namerec.uma.jsql.exceptions import JSQLSyntaxError
from namerec.uma.jsql.converter.expressions import sqlglot_expression_to_jsql
from namerec.uma.jsql.converter.conditions import sqlglot_condition_to_jsql
from namerec.uma.jsql.converter.joins import sqlglot_join_to_jsql

logger = logging.getLogger(__name__)


def sql_to_jsql(sql: str, dialect: str = 'generic') -> dict:
    """
    Convert SQL query to JSQL dictionary.
    
    Args:
        sql: SQL query string
        dialect: SQL dialect (generic, postgresql, mysql, sqlite, etc.)
    
    Returns:
        JSQL query dictionary
    
    Raises:
        JSQLSyntaxError: If SQL cannot be parsed
    """
    logger.info(f'Converting SQL to JSQL, dialect={dialect}')
    logger.debug(f'Input SQL: {sql}')
    
    try:
        # Parse SQL
        read_dialect = None if dialect == 'generic' else dialect
        parsed = sqlglot.parse_one(sql, read=read_dialect)
        
        if not isinstance(parsed, exp.Select):
            raise JSQLSyntaxError(
                message='Only SELECT queries are supported',
                path='',
            )
        
        # Convert to JSQL
        jsql: dict = {}
        
        # FROM clause
        if from_expr := parsed.args.get('from_'):
            jsql['from'] = _convert_from(from_expr)
        
        # SELECT clause
        if parsed.expressions:
            jsql['select'] = [sqlglot_expression_to_jsql(expr) for expr in parsed.expressions]
        
        # WHERE clause
        if parsed.args.get('where'):
            where_expr = parsed.args['where'].this
            jsql['where'] = sqlglot_condition_to_jsql(where_expr)
        
        # JOIN clauses
        if parsed.args.get('joins'):
            jsql['joins'] = [sqlglot_join_to_jsql(join) for join in parsed.args['joins']]
        
        # ORDER BY clause
        if parsed.args.get('order'):
            jsql['order_by'] = [_convert_order(order_expr) for order_expr in parsed.args['order'].expressions]
        
        # LIMIT/OFFSET
        if parsed.args.get('limit'):
            limit_expr = parsed.args['limit'].expression
            if isinstance(limit_expr, exp.Literal):
                jsql['limit'] = int(limit_expr.this)
        
        if parsed.args.get('offset'):
            offset_expr = parsed.args['offset'].expression
            if isinstance(offset_expr, exp.Literal):
                jsql['offset'] = int(offset_expr.this)
        
        # GROUP BY
        if parsed.args.get('group'):
            jsql['group_by'] = [sqlglot_expression_to_jsql(g) for g in parsed.args['group'].expressions]
        
        # HAVING
        if parsed.args.get('having'):
            having_expr = parsed.args['having'].this
            jsql['having'] = sqlglot_condition_to_jsql(having_expr)
        
        logger.info('Successfully converted SQL to JSQL')
        return jsql
    
    except JSQLSyntaxError:
        raise
    except Exception as e:
        logger.error(f'Parsing error: {e}', exc_info=True)
        raise JSQLSyntaxError(
            message=f'Failed to parse SQL: {e!s}',
            path='',
        ) from e


def _convert_from(from_expr: exp.From) -> str | dict:
    """Convert FROM clause."""
    if isinstance(from_expr, exp.From):
        table = from_expr.this
        if isinstance(table, exp.Table):
            if table.alias:
                return {'entity': table.name, 'alias': table.alias}
            return table.name
    return 'unknown'


def _convert_order(order_expr: exp.Ordered) -> dict:
    """Convert ORDER BY expression."""
    from namerec.uma.jsql.conversion_exceptions import InvalidExpressionError
    
    if not isinstance(order_expr, exp.Ordered):
        raise InvalidExpressionError(
            message=f'Expected Ordered, got {type(order_expr).__name__}',
            path='order_by',
            expression={'type': type(order_expr).__name__}
        )
    
    field_expr = sqlglot_expression_to_jsql(order_expr.this)
    result = field_expr.copy()
    direction = OrderDirection.DESC if order_expr.args.get('desc') else OrderDirection.ASC
    result['direction'] = direction.value.upper()
    
    return result
```

---

## –†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞

### –î–æ:
```
jsql/
‚îú‚îÄ‚îÄ converter.py (1033 —Å—Ç—Ä–æ–∫–∏, –≤—Å—ë –≤ –æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ)
‚îî‚îÄ‚îÄ ...
```

### –ü–æ—Å–ª–µ:
```
jsql/
‚îú‚îÄ‚îÄ converter/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py (12 —Å—Ç—Ä–æ–∫ - public API)
‚îÇ   ‚îú‚îÄ‚îÄ constants.py (60 —Å—Ç—Ä–æ–∫ - –º–∞–ø–ø–∏–Ω–≥–∏)
‚îÇ   ‚îú‚îÄ‚îÄ expressions.py (180 —Å—Ç—Ä–æ–∫ - –≤—ã—Ä–∞–∂–µ–Ω–∏—è)
‚îÇ   ‚îú‚îÄ‚îÄ conditions.py (260 —Å—Ç—Ä–æ–∫ - —É—Å–ª–æ–≤–∏—è)
‚îÇ   ‚îú‚îÄ‚îÄ joins.py (120 —Å—Ç—Ä–æ–∫ - JOIN'—ã)
‚îÇ   ‚îú‚îÄ‚îÄ jsql_to_sql.py (150 —Å—Ç—Ä–æ–∫ - JSQL‚ÜíSQL)
‚îÇ   ‚îî‚îÄ‚îÄ sql_to_jsql.py (140 —Å—Ç—Ä–æ–∫ - SQL‚ÜíJSQL)
‚îî‚îÄ‚îÄ ...
```

### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:

1. **–ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π**
   - –ö–∞–∂–¥—ã–π –º–æ–¥—É–ª—å –æ—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –æ–¥–∏–Ω –∞—Å–ø–µ–∫—Ç –∫–æ–Ω–≤–µ—Ä—Å–∏–∏
   - –õ–µ–≥—á–µ –ø–æ–Ω—è—Ç—å –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å

2. **–ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞**
   - `expressions.py` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏ –≤ JSQL‚ÜíSQL –∏ –≤ SQL‚ÜíJSQL
   - `conditions.py` - –æ–±—â–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –æ–±–æ–∏—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π

3. **–õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å**
   - –ú–æ–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π –º–æ–¥—É–ª—å –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ
   - –ú–æ–∫–∏ –∏ —Ñ–∏–∫—Å—Ç—É—Ä—ã –ø—Ä–æ—â–µ

4. **–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞**
   - –†–∞–∑–Ω—ã–µ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º–æ–≥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–¥ —Ä–∞–∑–Ω—ã–º–∏ –º–æ–¥—É–ª—è–º–∏

5. **–ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –∫–æ–¥—É**
   - –õ–µ–≥–∫–æ –Ω–∞–π—Ç–∏ –Ω—É–∂–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
   - IDE –ª—É—á—à–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –Ω–µ–±–æ–ª—å—à–∏–º–∏ —Ñ–∞–π–ª–∞–º–∏

---

**–¢—Ä—É–¥–æ–∑–∞—Ç—Ä–∞—Ç—ã:** 6-8 —á–∞—Å–æ–≤  
**–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ (—á–∏—Å—Ç–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥, API –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è)

```

–û—Ç–ª–∏—á–Ω–æ! –°–æ–∑–¥–∞–ª –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏ –∫–æ–¥–∞:

## üìã –°–æ–∑–¥–∞–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã:

1. **`CODE_REVIEW_2026-01-13.md`** - –ü–æ–ª–Ω—ã–π code review —Å –≤—ã—è–≤–ª–µ–Ω–Ω—ã–º–∏ –ø—Ä–æ–±–ª–µ–º–∞–º–∏
2. **`REFACTORING_PLAN.md`** - –î–µ—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ –ø—Ä–æ–±–ª–µ–º–∞–º 1-6 –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º 8-10
3. **`REFACTORING_PLAN_PART2.md`** - –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–∑–±–∏–µ–Ω–∏—è `converter.py` –Ω–∞ –º–æ–¥—É–ª–∏

## üìä –ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞ –ø–ª–∞–Ω–∞:

### –ü—Ä–æ–±–ª–µ–º–∞ 1: DRY –≤ `api.py` (2-3 —á–∞—Å–∞) üî¥
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é-–¥–∏—Å–ø–µ—Ç—á–µ—Ä `_dispatch_entity_operation`
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∫–æ–¥–∞ —Å ~200 –¥–æ ~80 —Å—Ç—Ä–æ–∫
- **–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

### –ü—Ä–æ–±–ª–µ–º–∞ 2: –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (8-10 —á–∞—Å–æ–≤) üî¥
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å –∫–ª–∞—Å—Å `UMAApplication` —Å –∏–Ω–∫–∞–ø—Å—É–ª—è—Ü–∏–µ–π –≤—Å–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–Ω—Å—Ç–∞–Ω—Å–æ–≤, –ª–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å
- **–†–∏—Å–∫–∏:** –°—Ä–µ–¥–Ω–∏–µ (breaking change –¥–ª—è advanced use cases)
- **–û–±—Ä–∞—Ç–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:** –°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ —á–µ—Ä–µ–∑ –¥–µ–ª–µ–≥–∏—Ä—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏

### –ü—Ä–æ–±–ª–µ–º–∞ 3: –†–∞–∑–±–∏—Ç—å `converter.py` (6-8 —á–∞—Å–æ–≤) üî¥
- **–†–µ—à–µ–Ω–∏–µ:** –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ 7 –º–æ–¥—É–ª–µ–π:
  - `__init__.py` - public API
  - `constants.py` - –º–∞–ø–ø–∏–Ω–≥–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
  - `expressions.py` - –∫–æ–Ω–≤–µ—Ä—Å–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏–π (180 —Å—Ç—Ä–æ–∫)
  - `conditions.py` - –∫–æ–Ω–≤–µ—Ä—Å–∏—è —É—Å–ª–æ–≤–∏–π (260 —Å—Ç—Ä–æ–∫)
  - `joins.py` - –∫–æ–Ω–≤–µ—Ä—Å–∏—è JOIN'–æ–≤ (120 —Å—Ç—Ä–æ–∫)
  - `jsql_to_sql.py` - –≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è JSQL‚ÜíSQL (150 —Å—Ç—Ä–æ–∫)
  - `sql_to_jsql.py` - –≥–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è SQL‚ÜíJSQL (140 —Å—Ç—Ä–æ–∫)
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–µ–π, –ª–µ–≥—á–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å
- **–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ (–≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥)

### –ü—Ä–æ–±–ª–µ–º–∞ 4: –†–∞–∑–±–∏—Ç—å `MetadataProvider` (4-5 —á–∞—Å–æ–≤) üü†
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å 3 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞:
  - `MetadataCache` - –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
  - `DatabaseReflector` - —Ä–µ—Ñ–ª–µ–∫—Å–∏—è –ë–î
  - `DefaultMetadataProvider` - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–æ–º–ø–æ–∑–∏—Ü–∏—é)
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ú–æ–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ –∑–∞–º–µ–Ω—è—Ç—å –∫–∞–∂–¥—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –æ—Ç–¥–µ–ª—å–Ω–æ
- **–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

### –ü—Ä–æ–±–ª–µ–º–∞ 5: –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫ –≤ parser (3-4 —á–∞—Å–∞) üü†
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å `_column_index: dict[str, list[tuple[str, ColumnElement]]]`
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** O(n*m) ‚Üí O(1), –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ –ø—Ä–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö JOIN'–∞—Ö
- **–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

### –ü—Ä–æ–±–ª–µ–º–∞ 6: AliasManager (2-3 —á–∞—Å–∞) üü†
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å –∫–ª–∞—Å—Å `AliasManager` –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–ª–∏–∞—Å–∞–º–∏
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ï–¥–∏–Ω–∞—è –ª–æ–≥–∏–∫–∞, –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ converter.py –∏ parser.py
- **–†–∏—Å–∫–∏:** –ù–∏–∑–∫–∏–µ

### –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 8: –ö—ç—à –∑–∞–ø—Ä–æ—Å–æ–≤ (4-5 —á–∞—Å–æ–≤) üü°
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å `JSQLQueryCache` —Å LRU-eviction
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –£—Å–∫–æ—Ä–µ–Ω–∏–µ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤ (dashboard-like UI)
- **–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ:** –ú–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å –¥–ª—è –¥–µ–±–∞–≥–∞

### –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 9: –¶–∏—Ä–∫—É–ª—è—Ä–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã (3-4 —á–∞—Å–∞) üü°
- **–†–µ—à–µ–Ω–∏–µ:** –†–µ–æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –∏–µ—Ä–∞—Ä—Ö–∏—é –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (8 —É—Ä–æ–≤–Ω–µ–π)
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ß–∏—Å—Ç–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è, –±—ã—Å—Ç—Ä–µ–µ –∑–∞–ø—É—Å–∫, –ø—Ä–æ—â–µ —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è
- **–†–∏—Å–∫–∏:** –°—Ä–µ–¥–Ω–∏–µ

### –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 10: Builder/Factory (2-3 —á–∞—Å–∞) üü°
- **–†–µ—à–µ–Ω–∏–µ:** –°–æ–∑–¥–∞—Ç—å `UMAContextBuilder` –∏ `JSQLExecutorFactory`
- **–†–µ–∑—É–ª—å—Ç–∞—Ç:** Fluent interface, –ª–µ–≥—á–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ —Ñ–∏–∫—Å—Ç—É—Ä—ã

## üéØ –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –ø–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:

### –§–∞–∑–∞ 1: Quick wins (1 –¥–µ–Ω—å)
1. ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ 1: DRY –≤ api.py
2. ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ 6: AliasManager
3. ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ 5: –ò–Ω–¥–µ–∫—Å –∫–æ–ª–æ–Ω–æ–∫

### –§–∞–∑–∞ 2: –í–∞–∂–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ (2-3 –¥–Ω—è)
4. ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ 3: –†–∞–∑–±–∏—Ç—å converter.py
5. ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ 4: –†–∞–∑–±–∏—Ç—å MetadataProvider

### –§–∞–∑–∞ 3: –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è (2 –¥–Ω—è)
6. ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ 2: UMAApplication
7. ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 9: –¶–∏—Ä–∫—É–ª—è—Ä–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã

### –§–∞–∑–∞ 4: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
8. ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 8: –ö—ç—à –∑–∞–ø—Ä–æ—Å–æ–≤
9. ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è 10: Builder/Factory

## üìà –ò—Ç–æ–≥–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞:

- **–í—Å–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏:** 37-47 —á–∞—Å–æ–≤ (5-6 —Ä–∞–±–æ—á–∏—Ö –¥–Ω–µ–π)
- **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–æ–±–ª–µ–º —É—Å—Ç—Ä–∞–Ω–µ–Ω–æ:** 3
- **–í–∞–∂–Ω—ã—Ö –ø—Ä–æ–±–ª–µ–º —É—Å—Ç—Ä–∞–Ω–µ–Ω–æ:** 3
- **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ:** 3

–•–æ—á–µ—à—å –Ω–∞—á–∞—Ç—å —Å –∫–∞–∫–æ–π-—Ç–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã? –†–µ–∫–æ–º–µ–Ω–¥—É—é –Ω–∞—á–∞—Ç—å —Å **–§–∞–∑—ã 1** - —ç—Ç–æ –¥–∞—Å—Ç –±—ã—Å—Ç—Ä—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∏—Å–∫–∏.

